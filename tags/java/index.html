<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>标签: Java - Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Hexo"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Hexo"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Hexo","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/lrj1996123"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">Java</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-12T02:50:48.000Z" title="2021-4-12 10:50:48 ├F10: AM┤">2021-04-12</time>发表</span><span class="level-item"><time dateTime="2021-04-13T14:13:42.825Z" title="2021-4-13 10:13:42 ├F10: PM┤">2021-04-13</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span><span class="level-item">14 分钟读完 (大约2127个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/12/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/">Java高并发程序设计4</a></h1><div class="content"><h2 id="提高锁性能的建议"><a href="#提高锁性能的建议" class="headerlink" title="提高锁性能的建议"></a>提高锁性能的建议</h2><h3 id="减少锁持有时间"><a href="#减少锁持有时间" class="headerlink" title="减少锁持有时间"></a>减少锁持有时间</h3><p>只在必要时进行同步，将不需要做同步的代码块挪出同步控制块</p>
<p>有条件地进行锁申请</p>
<h3 id="减小锁粒度"><a href="#减小锁粒度" class="headerlink" title="减小锁粒度"></a>减小锁粒度</h3><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>对于HashMap，get()和put()来说，对整个HashMap加锁，但是加锁粒度太大</p>
<p>ConcurrentHashMap内部细分了若干个小的HashMap，称为**段(SEGMENT)**，默认16个</p>
<p>put操作：根据hashcode得到该表项应该存放在哪个段中，然后对该段加锁并完成操作。只要多个put操作在不同段，就可以并行</p>
<p>减小锁粒度问题：获取全局锁时消耗资源会很多，例如size(),需要访问16个段的锁再求和（实际情况是先使用无锁方式求和，如果失败再加锁），所以ConcurrentHashMap适合<strong>获取全局信息方法调用不频繁的并发情况</strong></p>
<h3 id="读写锁替换独占锁"><a href="#读写锁替换独占锁" class="headerlink" title="读写锁替换独占锁"></a>读写锁替换独占锁</h3><p><strong>分割系统功能点</strong>来减小锁粒度</p>
<p>读操作本身不会影响数据完整性和一致性</p>
<p>情况：读多写少的场合</p>
<h3 id="锁分离"><a href="#锁分离" class="headerlink" title="锁分离"></a>锁分离</h3><p>对于不相干的操作，用不同的锁处理</p>
<p>例如：LinkedBlockingQueue</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>锁细化问题：对同一锁不停请求、同步和释放，本身也会消耗资源</p>
<p>解决方法：锁粗化，对同一个锁不断请求，改为<strong>所有锁操作整合成一个锁请求</strong>，例如把循环内的锁放到循环外</p>
<h2 id="Java虚拟机锁优化"><a href="#Java虚拟机锁优化" class="headerlink" title="Java虚拟机锁优化"></a>Java虚拟机锁优化</h2><h3 id="锁偏向"><a href="#锁偏向" class="headerlink" title="锁偏向"></a>锁偏向</h3><p>线程获得锁-&gt;锁进入偏向模式（对象头MarkWord中CAS更新记录owner）-&gt;该线程再次请求锁，无需同步操作</p>
<p>节省锁申请的操作，提高程序性能</p>
<p>适合场景：几乎没有锁竞争的场合</p>
<p>-XX:+UseBiasedLocking开启偏向锁</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>与重量级锁相比，不需要申请互斥量</p>
<p>锁偏向请求失败-&gt;将对象头部（Mark Word）CAS更新指向当前线程堆栈内部(锁记录)-&gt;如果指向成功则顺利进入临界区，失败则锁膨胀</p>
<p>锁膨胀：轻的量级锁转为重的量级锁</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>轻量级锁请求失败，则进行最后一次</p>
<p>自旋：当前线程做几次空循环来等待锁释放，若干次循环后，若可以获得锁则进入临界区，若获得不了则挂起</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>将无用的锁舍弃</p>
<p>逃逸分析：观察某个变量是否会逃出某个作用域</p>
<p>如果没有，则删除锁，如果有（例如通过返回值逃出），变量有可能被其他线程访问，这样就不能所消除</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>特点：局部变量，只有当前线程可以访问，自然线程安全</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseDate</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParseDate</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="keyword">this</span>.i = i;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(tl.get() == <span class="keyword">null</span>)&#123;</span><br><span class="line">                tl.set(<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));<span class="comment">//每个线程分配不同的对象，ThreadLocal只是起到线程简单的容器作用，如果分配相同的对象实例，也不能保证线程安全</span></span><br><span class="line">            &#125;</span><br><span class="line">            Date t = tl.get().parse(<span class="string">&quot;2015-03-29 19:29:&quot;</span> + i%<span class="number">60</span>);</span><br><span class="line">            System.out.println(i + <span class="string">&quot;:&quot;</span> + t);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ParseExeception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>ThreadLocal的get和set方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span></span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);<span class="comment">//线程私有，保存当前所在线程的所有局部变量，代表一个ThreadLocal变量集合</span></span><br><span class="line">    <span class="keyword">if</span>(map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);<span class="comment">//设置当前线程ThreadLocal的局部变量</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);<span class="comment">//线程私有，保存当前所在线程的所有局部变量，代表一个ThreadLocal变量集合</span></span><br><span class="line">    <span class="keyword">if</span>(map != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);<span class="comment">//根据ThreadLocal自身获取map存储的键值对（ThreadLocal，线程的局部变量）</span></span><br><span class="line">        <span class="keyword">if</span>(e != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (T)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题：变量保存在每个线程ThreadLocalMap内部，只要线程不退出，对象的引用就一直存在</p>
<p>问题导致：变量（可能是很大的对象）保存到ThreadLocalMap内，线程一直保持启动则变量无法被回收，可能会引发内存泄漏</p>
<p>解决方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.remove()或obj=<span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>如果对ThreadLocal设置为null，其对应的所有线程的局部变量都可能被回收（第二次gc）</p>
<p>原因：ThreadLocalMap内部每个Entry都是弱引用类型，如果失去key对应的ThreadLocal强引用，则可能会被回收</p>
<p>ThreadLocal可以提升处理多线程处理相同变量的不同变量值的效率</p>
<h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><p>鉴别线程冲突的乐观策略：比较交换（CAS）</p>
<h3 id="比较变换"><a href="#比较变换" class="headerlink" title="比较变换"></a>比较变换</h3><p>优点：线程相互影响比锁小，完全没有锁竞争带来的系统开销，也没有线程之间频繁调度的开销</p>
<p>过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CAS(V,E,N)，V表示要更新的变量，E表示预期值，N表示新值</span><br><span class="line">仅当V值等于E值时，才会将V的值设为N，如果V和E不同，说明其他线程已经更新了V，则当前线程什么都不做。</span><br><span class="line">最后，CAS返回当前V的真实值</span><br><span class="line">多线程CAS操作一个变量，只有一个会胜出，其他失败，失败的线程不会挂起而是被告知失败，允许再次尝试或放弃</span><br></pre></td></tr></table></figure>

<h3 id="无锁的线程安全整数：AtomicInteger"><a href="#无锁的线程安全整数：AtomicInteger" class="headerlink" title="无锁的线程安全整数：AtomicInteger"></a>无锁的线程安全整数：AtomicInteger</h3><p>JDK实现了一些CAS操作的线程安全的类型</p>
<p>对其修改的任何操作都是用CAS指令进行</p>
<p>incrementAndGet()内部实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="keyword">int</span> current = get();</span><br><span class="line">        <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>死循环：对于不成功的操作，需要不断尝试</p>
<h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><p>封装不安全的操作：指针操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> expected, <span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>o：给定对象</p>
<p>offset：偏移量，快速定位对象中的字段</p>
<p>expected：期望值</p>
<p>x：要设置的值</p>
<p><strong>它是一个JDK内部使用的专属类，自己的应用程序无法使用</strong></p>
<h3 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h3><p>类似AtomicInteger，是一个对象引用的原子类，对其修改可以保证线程安全</p>
<p>CAS问题：线程获取数据，修改前数据被另一个线程修改了两次且第二次改回了旧值，这时线程仍然可以修改该数据。</p>
<p><strong>是否能修改对象数据，不仅取决于当前值，还跟对象的过程变化有关</strong></p>
<p>出问题的场景：老客户回馈活动，贵宾卡余额小于20元，赠送20元，该过程只能一次。CAS操作取出余额19元，增加20元之前被其他线程占用，先增加20元，后又消费了20元，导致CAS检查当前值和期望值相同，都是19元，然后就重复赠送了20元</p>
<h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h3><p>上述问题原因：对象在修改过程中丢失了状态信息</p>
<p>解决方法：数值被修改时，更新时间戳</p>
<p>CAS操作要求对象值和时间戳都必须满足期望值</p>
<h3 id="AtomicIntegerArray"><a href="#AtomicIntegerArray" class="headerlink" title="AtomicIntegerArray"></a>AtomicIntegerArray</h3><p>对数组的原子性操作</p>
<p>AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p>
<h3 id="AtomicIntegerFieldUpdater"><a href="#AtomicIntegerFieldUpdater" class="headerlink" title="AtomicIntegerFieldUpdater"></a>AtomicIntegerFieldUpdater</h3><p>开闭原则：功能增加是开放的，功能修改时保守的</p>
<p>AtomicIntegerFieldUpdater在极少改动原有代码情况下，让普通变量也享受CAS带来的线程安全性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Candidate</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;Candidate&gt; scoreUpdater = AtomicIntegerFieldUpdater.newUpdater(Candidate.class, <span class="string">&quot;score&quot;</span>);<span class="comment">//绑定score变量</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        scoreUpdater.incrementAndGet(stu);<span class="comment">//使用updater修改Candidate对象实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项</p>
<p>1.反射获得变量，该变量必须可见</p>
<p>2.变量必须是volatile类型，来保证变量被正确读取</p>
<p>3.CAS操作通过对象实例中的偏移量进行赋值，因此不支持static字段</p>
<h3 id="无锁实现Vector"><a href="#无锁实现Vector" class="headerlink" title="无锁实现Vector"></a>无锁实现Vector</h3><h3 id="SynchronousQueue实现原理"><a href="#SynchronousQueue实现原理" class="headerlink" title="SynchronousQueue实现原理"></a>SynchronousQueue实现原理</h3><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁问题：哲学家就餐"><a href="#死锁问题：哲学家就餐" class="headerlink" title="死锁问题：哲学家就餐"></a>死锁问题：哲学家就餐</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(fork1)&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(fork2)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;哲学家A吃饭&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(fork2)&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(fork1)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;哲学家B吃饭&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两哲学家互相占有对方请求的资源，导致死锁</p>
<p>结果：两线程阻塞</p>
<p>解决方法：使用无锁；通过重入锁的中断或限时等待</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-10T03:47:20.000Z" title="2021-4-10 11:47:20 ├F10: AM┤">2021-04-10</time>发表</span><span class="level-item"><time dateTime="2021-04-11T14:25:40.782Z" title="2021-4-11 10:25:40 ├F10: PM┤">2021-04-11</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span><span class="level-item">6 分钟读完 (大约840个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/10/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13-3/">Java高并发程序设计3-3</a></h1><div class="content"><h2 id="JDK并发容器"><a href="#JDK并发容器" class="headerlink" title="JDK并发容器"></a>JDK并发容器</h2><h3 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h3><p>ConcurrentHashMap:线程安全的HashMap</p>
<p>CopyOnWriteArrayList:线程安全，适合读多写少的场合</p>
<p>ConcurrentLinkedQueue:线程安全的LinkedList</p>
<p>BlockingQueue:阻塞队列，适合作为数据共享的通道</p>
<p>ConcurrentSkipListMap:跳表实现，是一个map，可以实现快速查找</p>
<p>此外Vector线程安全，Collection工具类可以帮助我们将任意集合包装成线程安全的集合</p>
<h3 id="线程安全HashMap"><a href="#线程安全HashMap" class="headerlink" title="线程安全HashMap"></a>线程安全HashMap</h3><p>简单的方法是使用Collections.synchronizedMap(new HashMap())来生成SynchronizedMap，其包装的hashmap是线程安全的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SynchronizedMap&lt;k,v&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;k,v&gt; m;</span><br><span class="line">    <span class="keyword">final</span> Object mutex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的mutex用来实现对map的互斥操作，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> v <span class="title">get</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(mutex)&#123;<span class="keyword">return</span> m.get(key);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题：线程安全但并发级别不高，可以用，但是并发数目多会导致很多线程等待，性能很低</p>
<p>这里使用更专业的<strong>ConcurrentHashMap</strong></p>
<h3 id="List线程安全"><a href="#List线程安全" class="headerlink" title="List线程安全"></a>List线程安全</h3><p>ArrayList和Vector都使用数组，区别是ArrayList线程不安全，Vector线程安全</p>
<p>对于LinkedList，这里可以</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; l = Collections.synchronizedList(<span class="keyword">new</span> LinkedList&lt;String&gt;());</span><br></pre></td></tr></table></figure>

<h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>等看第四章再看</p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>读操作数远远大于写，读操作要快，写操作慢一点没关系</p>
<p>目标：写入不会阻塞读取操作（可能会数据不一致），只有写入和写入之间需要的等待</p>
<p>方法：写入操作时自我复制，修改的内容写入副本，写完再用修改的副本替换原数据</p>
<p>读操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E)a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Object[] elements = getArray();<span class="comment">//volatile类型变量可以被读线程立刻察觉</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);<span class="comment">//获取副本</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);<span class="comment">//副本覆盖</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据共享通道：BlockingQueue"><a href="#数据共享通道：BlockingQueue" class="headerlink" title="数据共享通道：BlockingQueue"></a>数据共享通道：BlockingQueue</h3><p>问题：高并发环境下，多线程间如何数据共享</p>
<p>理解：业主给物业公司意见箱写信提意见，而不是直接找工作人员</p>
<p>意见箱：BlockingQueue线程</p>
<p><strong>ArrayBlockingQueue</strong></p>
<p>队列压入元素：offer()，队列满则返回false；put()，队列满则返等待，直到有空闲位置</p>
<p>队列弹出元素：poll()，队列为空直接返回null；take()，等待，直到队列内有可用元素</p>
<p>等待利用<strong>Condition的等待通知机制</strong>实现</p>
<p>队列物理上是一个数组，逻辑层面是一个环形结构</p>
<h3 id="跳表（SkipList）"><a href="#跳表（SkipList）" class="headerlink" title="跳表（SkipList）"></a>跳表（SkipList）</h3><p>作用：快速查找</p>
<p>与平衡树类似，但是平衡树在插入和删除后需要重新一次全局调整，跳表只需<strong>局部调整</strong></p>
<p>复杂度：O(logn)</p>
<p>并发条件下：跳表只需一个<strong>局部的锁</strong>，而平衡树需要<strong>全局锁</strong>  </p>
<p>查询从上层查，如果查到末尾或者下一个元素比目标大，则向下查询  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> ConcurrentSkipListMap&lt;Integer, Integer&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)&#123;</span><br><span class="line">    map.put(i, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet())&#123;</span><br><span class="line">    System.out.println(entry.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对跳表的遍历是有序的</p>
<p>所有对node的操作，使用CAS方法</p>
<p>Index类包装Node来组织表结构</p>
<p>每一层表头还需要一个名为HeadIndex数据结构，继承自Index，额外具有level属性表示当前链表第几层</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-08T02:25:16.000Z" title="2021-4-8 10:25:16 ├F10: AM┤">2021-04-08</time>发表</span><span class="level-item"><time dateTime="2021-04-10T03:44:38.174Z" title="2021-4-10 11:44:38 ├F10: AM┤">2021-04-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span><span class="level-item">15 分钟读完 (大约2322个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/08/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13-2/">Java高并发程序设计3-2</a></h1><div class="content"><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程本身占用内存，创建和关闭花费时间</p>
<p>必须在有限范围内增加线程数量，否则会拖垮系统，对系统有害</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>线程复用：需要时从池子中拿一个，完成工作时将线程退回到池子中，方便他人使用</p>
<h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>Executors类：线程池工厂，获取一个具有特定功能的线程池</p>
<p>ThreadPoolExecutor：表示一个线程池，可以调度任何对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回固定线程池，线程数量不变，提交新任务，若有空闲线程，则立即执行；若没有，则新任务暂存在一个任务队列中，待有空闲线程时执行队列中的任务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>;</span><br><span class="line"><span class="comment">//返回只有一个线程的线程池，多余任务保存在任务队列中，待线程空闲队列按先入先出执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//根据实际情况调整线程数量，提交新任务，空闲则复用，无空闲则创建</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//计划任务线程池，线程池大小为1，在ExecutorService基础上扩展了在给定时间执行某任务的功能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//指定数量的计划任务线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span>;</span><br></pre></td></tr></table></figure>

<p>1.<strong>固定大小线程池</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + <span class="string">&quot;:Thread ID:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyTask task = <span class="keyword">new</span> MyTask();</span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            es.submit(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给定线程池大小是5，5个线程同时执行，这里提交了10个任务，先执行5个，再执行5个，两者线程是复用的</p>
<p>2.<strong>计划任务</strong></p>
<p>可以根据时间需要调度线程</p>
<p>主要方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="keyword">long</span> delay, TimeUnit unit);<span class="comment">//给定时间任务调度</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit); <span class="comment">//对任务周期性调度，任务开始时initialDelay为起点，在之后的period周期时间调度下一次任务</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> delay, TimeUnit unit);<span class="comment">//对任务周期性调度，任务开始时initialDelay为起点，上一个任务结束后再经过delay时间后再进行任务调度</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService ses = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">ses.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(System.currentTimeMillis()/<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>如图，初始0延迟，每2秒执行一次线程任务</p>
<p>问题：如果任务执行时间超过2秒会发生什么？</p>
<p>答：任务会在上一个任务结束后立即被调用</p>
<p>注意：如果任务改成scheduleWithFixedDelay()执行8秒，周期2秒，任务实际间隔10秒</p>
<h3 id="核心线程池的内部实现"><a href="#核心线程池的内部实现" class="headerlink" title="核心线程池的内部实现"></a>核心线程池的内部实现</h3><p>以上方法都是ThreadPoolExecutor类的封装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,//指定了线程池中的线程数量</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> maximumPoolSize,//指定了线程池最大线程数量</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> keepAliveTime,//线程池数量超过corePoolSize，多余的线程存活时间</span></span></span><br><span class="line"><span class="function"><span class="params">                         TimeUnit unit,//keepAliveTime单位</span></span></span><br><span class="line"><span class="function"><span class="params">                         BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，被提交但尚未被执行</span></span></span><br><span class="line"><span class="function"><span class="params">                         ThreadFactory threadFactory,//线程工厂</span></span></span><br><span class="line"><span class="function"><span class="params">                         RejectedExecutionHandler handler)</span><span class="comment">//拒绝策略，如何拒绝任务</span></span></span><br></pre></td></tr></table></figure>

<p>workQueue是一个BlockingQueue接口的对象，仅用于存放Runnable，根据队列功能分类：</p>
<p>1.直接提交的队列：SynchronousQueue对象提供，没有容量，每插入一个都要等待一个删除操作，反之，每一个删除操作都要等待对应的插入操作，不会保存任务，而直接交给线程执行</p>
<p>2.有界的任务队列：ArrayBlockingQueue，线程数小于corePoolSize，否则加入队列，队列满再创建线程（小于maximumPoolSize）</p>
<p>3.无界的任务队列，LinkedBlockingQueue，线程小于corePoolSize，否则直接入队等待</p>
<p>4.优先任务队列：PriorityBlockingQueue，特殊的无界队列，根据任务优先级顺序先后执行</p>
<h4 id="线程池工作逻辑"><a href="#线程池工作逻辑" class="headerlink" title="线程池工作逻辑"></a>线程池工作逻辑</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span>(workerCountOf(c) &lt; corePoolSize)&#123;<span class="comment">//线程数小于corPoolSize，直接创建线程</span></span><br><span class="line">        <span class="keyword">if</span>(addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isRunning(c) &amp;&amp; workQueue.offer(command))&#123;<span class="comment">//进入等待队列</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span>(!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!addWorker(command, <span class="keyword">false</span>))<span class="comment">//进入等待队列失败（队列满），直接进入线程池，若再失败则拒绝</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><p>AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作</p>
<p>CallerRunsPolicy策略：只要线程池未关闭，直接在调用者线程中运行任务，可能会使性能下降</p>
<p>DiscardOldestPolicy策略：丢弃最老的一个请求（即将被执行的任务），并尝试再次提交当前任务</p>
<p>DiscardPolicy策略：默默地丢弃无法处理的任务</p>
<p>以上策略均实现了RejectedExecutionHandler接口，可以自己扩展</p>
<p>自定义线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es = </span><br><span class="line">    <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                           <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">10</span>),</span><br><span class="line">                           Executors.defaultThreadFactory(),</span><br><span class="line">                           <span class="keyword">new</span> RejectedExecutionHandler()&#123;</span><br><span class="line">                               <span class="meta">@Override</span></span><br><span class="line">                               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r,                                                            ThreadPoolExecutor executor)</span></span>&#123;</span><br><span class="line">                                   System.out.println(r.toString() + <span class="string">&quot; is                                                    discard&quot;</span>);</span><br><span class="line">                               &#125;</span><br><span class="line"></span><br><span class="line">                           &#125;);</span><br></pre></td></tr></table></figure>

<p>分析：5个常驻线程，最大线程数量是5个，这和固定大小线程池一样，但等待队列容量只有10来保证系统稳定，拒绝策略增加打印信息的小功能</p>
<h4 id="自定义线程创建：ThreadFactory"><a href="#自定义线程创建：ThreadFactory" class="headerlink" title="自定义线程创建：ThreadFactory"></a>自定义线程创建：ThreadFactory</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadFactory()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上自定义线程创建让每个线程都设置为守护线程</p>
<h4 id="扩展线程池"><a href="#扩展线程池" class="headerlink" title="扩展线程池"></a>扩展线程池</h4><p>扩展目的：监控任务执行的开始时间和结束时间，便于调试</p>
<p>ThreadPoolExecutor可以扩展，自身提供beforeExecute()、afterExecute()、terminated()三个接口用来对线程池进行控制</p>
<p>其在ThreadPoolExecutor.runWorker(Worker w)上实现，其中Worker实例正是工作线程。Worker.run方法调用上述runWorker实现每一个线程的固有工作</p>
<p>ThreadPoolEx重写三个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                            <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;())&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备执行&quot;</span> + ((MyTask) r).name);</span><br><span class="line">        <span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行完成&quot;</span> + ((MyTask) r).name);</span><br><span class="line">        <span class="keyword">super</span>.afterExecute(r, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程退出&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.terminated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="优化线程池线程数量"><a href="#优化线程池线程数量" class="headerlink" title="优化线程池线程数量"></a>优化线程池线程数量</h3><p>估算线程池大小：<br>$$<br>N_{cpu} = CPU数量<br>$$</p>
<p>$$<br>U_{cpu}=目标CPU的使用率，0\le U_{cpu} \le 1<br>$$</p>
<p>$$<br>W/C = 等待时间与计算时间的比率<br>$$</p>
<p>为保持处理器达到期望的使用率，最优线程池的大小等于<br>$$<br>N_{threads} = N_{cpu} \times U_{cpu} \times (1 + W/C)<br>$$</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().availableProcessors()<span class="comment">//取得CPU可用数量</span></span><br></pre></td></tr></table></figure>

<h3 id="线程池中寻找堆栈"><a href="#线程池中寻找堆栈" class="headerlink" title="线程池中寻找堆栈"></a>线程池中寻找堆栈</h3><p>线程池运行线程时一个线程出错可能会没有任何错误提示</p>
<p>“最鄙视那些出错不打印异常堆栈的行为！”</p>
<p>讨回堆栈</p>
<p><strong>1.放弃submit，改为execute</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pools.executes(<span class="keyword">new</span> Task());</span><br></pre></td></tr></table></figure>

<p><strong>2.改造submit方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Future re = pools.submit(<span class="keyword">new</span> Task());</span><br><span class="line">re.get();</span><br></pre></td></tr></table></figure>

<p>两种方法都可以得到部分堆栈信息（<strong>异常抛出位置</strong>）</p>
<p>如何确定任务提交的位置？</p>
<p>调度任务前，保存一下提交任务线程的堆栈信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TraceThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.execute(wrap(task, clientTrace(), Thread.currentThread().getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.submit(wrap(task, clientTrace(), Thread.currentThread().getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Exception <span class="title">clientTrace</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Client stack trace&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Runnable <span class="title">wrap</span><span class="params">(<span class="keyword">final</span> Runnable task, <span class="keyword">final</span> Exception clientStack, String clientThreadName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    clientStack.printStackTrace();</span><br><span class="line">                    <span class="keyword">throw</span> e;<span class="comment">//关键代码，抛出异常，挖出堆栈信息</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如图通过wrap包裹一下submit信息，让异常信息可以被打印出来，不仅得到了异常出现的位置，还得到了任务是哪里提交的，从而得到比较完整的异常信息</p>
<h3 id="分而治之：Fork-Join框架"><a href="#分而治之：Fork-Join框架" class="headerlink" title="分而治之：Fork/Join框架"></a>分而治之：Fork/Join框架</h3><p>fork：开启线程（子进程）,提交子任务；将任务分解成多个子任务，最终合并所有任务结果</p>
<p>join：等待线程执行完毕，返回结果</p>
<p>ForkJoinPool：分而治之线程池</p>
<p>ForkJoinTask：分而治之任务</p>
<p>RecursiveTask：ForkJoinTask子类，有返回值</p>
<p>RecursiveAction：ForkJoinTask子类，无返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span><span class="comment">//子类重写</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> canCompute = (end - start) &lt; THRESHOLD;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(canCompute)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">long</span> step = (end + start) / <span class="number">100</span>;</span><br><span class="line">        List&lt;CountTask&gt; subTasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> pos = start;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">long</span> lastOne = pos + step;</span><br><span class="line">            <span class="keyword">if</span>(lastOne &gt; end) lastOne = end;</span><br><span class="line">            CountTask subTask = <span class="keyword">new</span> CountTask(pos, lastOne);</span><br><span class="line">            pos += step + <span class="number">1</span>;</span><br><span class="line">            subTasks.add(subTask);</span><br><span class="line">            subTask.fork();<span class="comment">//所有子任务fork</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(CountTask t: subTasks)&#123;</span><br><span class="line">            sum += t.join();<span class="comment">//子任务join方法计算出结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;<span class="comment">//RecursiveTask子任务计算有一个返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子任务越多，性能会下降，可能会出现栈溢出异常</p>
<h3 id="Guava对线程池的扩展"><a href="#Guava对线程池的扩展" class="headerlink" title="Guava对线程池的扩展"></a>Guava对线程池的扩展</h3><p><strong>DirectExecutor线程池</strong></p>
<p>目的：抽象线程池，线程加入后，并没有创建线程，而使其在当前线程中执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Executor executor = MoreExecutors.directExecutor();</span><br><span class="line">    executor.execute(()-&gt;System.out.println(<span class="string">&quot;I am running in&quot;</span> + thread.currentThread.getName()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以注入不同的executor实现，无需修改代码使程序拥有不同行为</p>
<p><strong>Daemon线程池</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoreExecutors.getExitingExecutorService(executor);</span><br></pre></td></tr></table></figure>

<p>使得后台线程池的存在不会阻止进程结束执行</p>
<p><strong>扩展Future</strong></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-07T03:09:10.000Z" title="2021-4-7 11:09:10 ├F10: AM┤">2021-04-07</time>发表</span><span class="level-item"><time dateTime="2021-04-07T13:07:32.088Z" title="2021-4-7 9:07:32 ├F10: PM┤">2021-04-07</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span><span class="level-item">15 分钟读完 (大约2244个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/07/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/">Java高并发程序设计3</a></h1><div class="content"><h2 id="JDK并发包"><a href="#JDK并发包" class="headerlink" title="JDK并发包"></a>JDK并发包</h2><p>本章介绍JDK内部大量实用的框架，主要分为三个方面：</p>
<ul>
<li>同步控制工具</li>
<li>线程池相关</li>
<li>并发容器</li>
</ul>
<h3 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h3><h4 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReenterLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000000</span>; j++)&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> trows InterruptedException</span>&#123;</span><br><span class="line">        ReenterLock rl = <span class="keyword">new</span> ReenterLock();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(rl);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(rl);</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>灵活：开发人员必须手动指定何时加锁，何时释放锁（<strong>退出临界区时必须释放锁</strong>）</p>
<p>重入：一个线程可以连续多次获得锁，但也必须释放相同次数</p>
<p>释放次数多会出现IllegalMonitorStateException异常</p>
<p>释放次数少会使其他线程无法进入临界区</p>
<h5 id="重入锁高级功能"><a href="#重入锁高级功能" class="headerlink" title="重入锁高级功能"></a>重入锁高级功能</h5><p>1.<strong>中断响应</strong></p>
<p>线程等待锁——&gt;获得锁/<strong>被中断</strong></p>
<p>通过重入锁实现对等待状态的中断，甚至可以解决死锁问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.lockInterruptibly();</span><br></pre></td></tr></table></figure>

<p>通过以上代码，线程等待获得锁，如果两线程请求的锁都被对方占用而无法释放，导致死锁，则会使其中一个线程中断释放资源，防止死锁发生，但最后只有一个线程完成了任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.isHeldByCurrentThread();</span><br></pre></td></tr></table></figure>

<p>上述代码表示判断当前线程是否拥有该锁</p>
<p>2.<strong>锁申请等待限时</strong></p>
<p>trylock第一个参数是等待时长，第二个时时间单位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(lock.tryLock(<span class="number">5</span>,TimeUnit.SECONDS))&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法可以使锁请求最多等待5秒，如果超过5秒就会自动放弃</p>
<p>tryLock方法也可以无参调用，如果锁未被占用则直接获取，如果被占用则不会等待，直接放弃本次请求，从而解决死锁问题</p>
<p>3.<strong>公平锁</strong></p>
<p>非公平锁：锁可用时随机给一个线程</p>
<p>保证先到先得，后到后得，不会产生饥饿现象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span></span></span><br></pre></td></tr></table></figure>

<p>fair为true则为公平锁，公平锁必然要维护一个有序队列，成本高，所以默认非公平</p>
<p>重入锁实现三要素：</p>
<ol>
<li>原子状态，使用CAS存储锁状态，判断锁是否被别的线程持有</li>
<li>等待队列，没有请求到锁的线程会进入等待队列进行等待，释放锁后会唤醒一个线程</li>
<li>阻塞原语park()和unpark()，用来挂起和恢复线程。没有得到锁的线程将会被挂起</li>
</ol>
<p>内核或微核提供核外调用的过程或函数称为<em>原语</em>(primitive)。<em>原语</em>是一段用机器指令编写的完成特定功能的程序,在执行过程中不允许中断。 </p>
<h5 id="重入锁搭档：Condition"><a href="#重入锁搭档：Condition" class="headerlink" title="重入锁搭档：Condition"></a>重入锁搭档：Condition</h5><p>类似wait和notify，wait和notify适合与synchronized一起用，Condition与重入锁一起用</p>
<p>通过lock接口的Condition newCondition()方法生成与当前重入锁绑定的Condition实例</p>
<p>让线程在合适时间等待，特定时刻得到通知</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;<span class="comment">//当前线程等待同时释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;<span class="comment">//不会在等待过程中响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;<span class="comment">//唤醒等待线程，重新获得锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;<span class="comment">//唤醒所有等待线程</span></span><br></pre></td></tr></table></figure>

<p>Condition功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReenterLockCondition</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line">        <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">static</span> ReenterLockCondition instance = <span class="keyword">new</span> ReenterLockCondition();</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException ie)&#123;</span><br><span class="line">                ie.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">            Thread t1 = <span class="keyword">new</span> Thread(condition);</span><br><span class="line">            t1.start();</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            lock.lock();</span><br><span class="line">            condition.signal();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>await要求线程持有相关重入锁，执行后释放这把锁</p>
<p>signal要求线程先获得相关锁，调用后从Condition对象的等待队列中唤醒一个线程，使之尝试重新获得与之绑定的重入锁，所以signal之后需要通过unlock释放锁才能真正唤醒t1</p>
<h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>指定多个线程同时访问某个资源，锁的扩展</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits,<span class="meta">@Nullable</span> <span class="keyword">boolean</span> fair)</span></span></span><br></pre></td></tr></table></figure>

<p>其主要逻辑方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span></span>;<span class="comment">//尝试获得一个准入许可，若无法获得则等待，直到有线程释放许可或中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span></span>;<span class="comment">//不响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span></span>;<span class="comment">//尝试获得一个许可 成功true 失败false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span>;<span class="comment">//限定时间内尝试获得许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span><span class="comment">//许可释放 一个acquire对应一个release否则会发生泄露</span></span></span><br></pre></td></tr></table></figure>

<h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><p>JDK5提供的读写分离锁</p>
<p>重写锁和内部锁的读、写都是串行操作，但是读操作并没有破坏数据，所以不合理</p>
<p><strong>读写锁允许多个线程同时读</strong></p>
<p>但是考虑数据完整性，<strong>写写操作</strong>和<strong>读写操作</strong>依然需要相互等待和持有锁</p>
<table>
<thead>
<tr>
<th></th>
<th>读</th>
<th>写</th>
</tr>
</thead>
<tbody><tr>
<td>读</td>
<td>非阻塞</td>
<td>阻塞</td>
</tr>
<tr>
<td>写</td>
<td>阻塞</td>
<td>阻塞</td>
</tr>
</tbody></table>
<p>读操作次数远远大于写操作次数时，读写锁就可以发挥最大功效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Lock readLock = readWriteLock.readLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Lock writeLock = readWriteLock.writeLock();</span><br></pre></td></tr></table></figure>

<p>读写锁分离，使得读操作非常快</p>
<h5 id="倒计数器：CountDownLatch"><a href="#倒计数器：CountDownLatch" class="headerlink" title="倒计数器：CountDownLatch"></a>倒计数器：CountDownLatch</h5><p>控制线程，让线程等待直到倒计数结束，再开始执行</p>
<p>场景：火箭发射前需要各项准备工作完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch end = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        end.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        exec.submit(demo);</span><br><span class="line">    &#125;</span><br><span class="line">    end.await();<span class="comment">//等待检查</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Fire！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如图，countDown方法通知CountDownLatch，一个线程完成任务，倒计数减一，任务全部完成后，再点火发射火箭</p>
<h5 id="循环栅栏：CyclicBarrier"><a href="#循环栅栏：CyclicBarrier" class="headerlink" title="循环栅栏：CyclicBarrier"></a>循环栅栏：CyclicBarrier</h5><p>类似倒计数器，但是有循环特性：如设置为10，第一批10个线程结束后，计数器就会归零，接着凑下一批10个线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span></span></span><br></pre></td></tr></table></figure>

<p>barrierAction表示一次计数完成后，系统会执行的动作</p>
<p>关键代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier cyclic;<span class="comment">//在main函数传参创建</span></span><br><span class="line"><span class="comment">//等待所有士兵到齐</span></span><br><span class="line">cyclic.await();</span><br><span class="line">doWork();</span><br><span class="line"><span class="comment">//等待所有士兵完成工作</span></span><br><span class="line">cyclic.await();</span><br></pre></td></tr></table></figure>

<p>第一次await，每个士兵线程会等待，直到集合完毕，barrierAction会执行一次</p>
<p>第二次await，进行下一次计数，在doWork执行完毕后进行，主要目的是监控是否所有士兵都完成了任务</p>
<p>注意：如果手动中断一个线程，其他9个线程会抛出BrokenBarrierException异常，避免永久无所谓的等待</p>
<h5 id="线程阻塞工具类：LockSupport"><a href="#线程阻塞工具类：LockSupport" class="headerlink" title="线程阻塞工具类：LockSupport"></a>线程阻塞工具类：LockSupport</h5><p>任意位置线程阻塞，不需要获得某个对象的锁</p>
<p>静态方法park()可以阻塞当前线程</p>
<p>用LockSupport的park和unpark替换掉第二章suspend和resume方法，结果导致程序正常运行！而没有永久挂起</p>
<p>原因：LockSupport类使用了类似信号量的机制，每个线程准备一个许可，如果许可可用，park方法立刻返回，许可变为不可用；如果许可不可用，就会阻塞，而unpark方法使一个许可变得可用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">run()&#123;</span><br><span class="line">    LockSupport.park();<span class="comment">//直接调用阻塞线程</span></span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">    LockSupport.unpark(t1);<span class="comment">//直接调用解挂t1阻塞状态，如果unpark发生在park()之前，也可以使下次park()立刻返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了定时阻塞，还可以支持中断影响</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">run()&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(u)&#123;</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        <span class="keyword">if</span>(Thread.interrupted())&#123;<span class="comment">//中断后可以直接响应</span></span><br><span class="line">            System.out.println(getName() +<span class="string">&quot;被中断了&quot;</span>)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.interrupt();<span class="comment">//中断t1,t1执行结束，之后t2才可进入临界区</span></span><br><span class="line">    LockSupport.unpark(t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Guava下限流工具RateLimiter"><a href="#Guava下限流工具RateLimiter" class="headerlink" title="Guava下限流工具RateLimiter"></a>Guava下限流工具RateLimiter</h5><p>对于一个应用来说，每秒能处理的请求是有限的，一旦突破上限，甚至可能压垮系统，因此限流很有必要</p>
<p>漏桶算法：利用一个缓存区，无论请求速率如何，都先进入缓存区保存，然后以固定速率处理请求</p>
<p>令牌桶算法：桶中存放令牌，每个单位时间产生一定量令牌存入桶中，处理程序拿到令牌才可处理请求，而且桶容量有限，桶慢则丢弃令牌</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> RateLimiter limiter = RateLimiter.create(<span class="number">2</span>);<span class="comment">//每秒生产2个令牌</span></span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">        limiter.acquire();<span class="comment">//请求令牌</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开50个线程，可能只需半秒，但我们规定一秒只能开2个线程，所以acquire使得过剩的流量等待，直到合适的时候执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!limiter.tryAcquire())&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task()).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可如上图，通过tryAcquire方法，直接丢弃过载请求，尽可能避免系统崩溃 500ms内所有都可完成，所以这里只有一个输出</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-31T03:46:29.000Z" title="2021-3-31 11:46:29 ├F10: AM┤">2021-03-31</time>发表</span><span class="level-item"><time dateTime="2021-04-06T13:59:55.676Z" title="2021-4-6 9:59:55 ├F10: PM┤">2021-04-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span><span class="level-item">20 分钟读完 (大约3003个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/31/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/">Java高并发程序设计2</a></h1><div class="content"><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><p>进程：程序的一次执行过程，是系统进行资源分配和调度的基本单位，是线程的容器</p>
<p>线程：轻量级进程，是程序执行的最小单位，线程间切换和调度成本远小于进程，所以使用多线程进行并发程序设计  </p>
<h3 id="线程基本操作"><a href="#线程基本操作" class="headerlink" title="线程基本操作"></a>线程基本操作</h3><h4 id="新建线程启动"><a href="#新建线程启动" class="headerlink" title="新建线程启动"></a>新建线程启动</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> CreateThread());</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Oh, I am Runnable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中启动线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread();</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure>

<p>start()：新建一个线程并让线程执行run()方法</p>
<p>不要直接调用run()方法，它只会在当前线程中串行执行方法中的代码</p>
<h4 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h4><p>Thread.stop()方法终止线程，被废弃不推荐使用</p>
<p>原因：方法过于暴力，终止时可能并没有完成相关写操作</p>
<p>停止线程方法：在完成run所有写操作时stop,保证不会在setId和setName之间stop</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeObjectThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> stopme = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopMe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stopme = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stopme)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;exit by stop me&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span>(u)&#123;<span class="comment">//u为边缘区变量</span></span><br><span class="line">                <span class="keyword">int</span> v = (<span class="keyword">int</span>) (System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">                u.setId(v);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                u.setName(String.valueOf(v));</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h4><p>线程中断：不会立即退出，而是线程收到一个希望退出的通知，具体何时退出由线程自己决定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Interrupted!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如图，执行t1.interrupt()方法之后，通知t1被中断，具体何时中断可在while语句内控制</p>
<h5 id="Time-sleep-函数"><a href="#Time-sleep-函数" class="headerlink" title="Time.sleep()函数"></a>Time.sleep()函数</h5><p>线程休眠若干时间，期间如果中断会抛出InterruptedException中断异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Interrupted When Sleep&quot;</span>);</span><br><span class="line">    <span class="comment">//设置中断状态</span></span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<strong>捕获中断后，会清除中断标记</strong>，这时需要再次设置中断标记位</p>
<h4 id="等待和通知"><a href="#等待和通知" class="headerlink" title="等待和通知"></a>等待和通知</h4><p>obj.wait()：线程处于等待状态，线程停止运行</p>
<p>进入object对象的等待队列</p>
<p>必须包含在synchronized语句中，<strong>执行后会释放锁</strong></p>
<p>obj.notify()：线程结束等待，继续执行</p>
<p>等待队列中随机选择一个线程，将其唤醒（非公平）</p>
<p>无论是wait和notify必须首先获得目标对象的一个监视器（对象锁）</p>
<p>T1在wait方法执行前获取监视器，执行后释放，目的是使其他等待在obj对象上的线程不至于因为T1的休眠而全部无法正常执行</p>
<p>T2在notify方法执行前获取监视器，因为T1已经释放监视器，可以顺利获取，执行notify方法后尝试唤醒一个等待线程，这里唤醒T1，唤醒后T1先重新获取监视器（<strong>这里需等待T1释放监视器</strong>），再继续执行</p>
<h4 id="挂起和继续执行"><a href="#挂起和继续执行" class="headerlink" title="挂起和继续执行"></a>挂起和继续执行</h4><p>不推荐使用</p>
<p>suspend()线程暂停，不会释放任何锁资源，直到resume()方法之后，线程才会继续</p>
<p>然而如果resume方法意外地发生在suspend之前，就永远不会释放了</p>
<p>推荐使用wait+notify代替suspend和resume</p>
<h4 id="等待线程结束和谦让"><a href="#等待线程结束和谦让" class="headerlink" title="等待线程结束和谦让"></a>等待线程结束和谦让</h4><p>join()，不加超时参数，表示无限等待，会一直阻塞当前线程，直到目标线程执行完毕</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinMain</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        AddThread at = <span class="keyword">new</span> AddThread();</span><br><span class="line">        at.start();</span><br><span class="line">        at.join();<span class="comment">//主线程等待AddThread执行完毕</span></span><br><span class="line">        System.out.println(i);<span class="comment">//输出100000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>join方法实现的核心代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(isAlive())&#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使得调用线程（主线程）在被调用线程对象上进行等待，被调用线程执行完毕后，会在退出前调用notifyAll()方法通知所有等待线程继续执行</p>
<p>所以，不要在Thread对象实例上使用类似wait()方法或者notify()方法，会影响系统api工作</p>
<p>yield()：让出CPU，而非结束执行，会继续竞争cpu</p>
<h4 id="volatile与JMM"><a href="#volatile与JMM" class="headerlink" title="volatile与JMM"></a>volatile与JMM</h4><h5 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h5><p>该变量极有可能会被某些程序或线程修改，修改后系统想办法通知给其他线程，保障数据可见性，同时保障操作原子性（有限保障），防止数据被写坏,如之前的long类型，可以通过添加volatile修饰保证不会被写坏</p>
<p>参考： <a target="_blank" rel="noopener" href="https://blog.csdn.net/u012723673/article/details/80682208">https://blog.csdn.net/u012723673/article/details/80682208</a> </p>
<p>但是，volatile并不能替代锁，<strong>无法保证一些复合操作的原子性</strong></p>
<p>如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PlusTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10000</span>; k++)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> PlusTask());</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            threads[i].join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理论上应该输出100000，但是结果总是比100000小</p>
<p>原因：主线程阻塞，10个子线程互相抢占时间片，i++这种复合操作首先读取i变量，此时被其他线程抢占修改i并写入主存，在回来的时候i还是未修改的状态，导致两次修改相当于一次的</p>
<p>可以通过加synchronized同步锁，保证i++操作时阻塞其他线程，保障原子性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PlusTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10000</span>; k++)&#123;</span><br><span class="line">                increase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> PlusTask());</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            threads[i].join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但volatile可以保证数据的可见性和有序性</p>
<p>可见性在server模式下不可行</p>
<h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><p>线程很多，功能分配明确，可以将相同功能的线程放在一个线程组里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroupName</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ThreadGroup tg = <span class="keyword">new</span> ThreadGroup(<span class="string">&quot;PrintGroup&quot;</span>);<span class="comment">//创建名为PrintGroup的线程组</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(tg, <span class="keyword">new</span> ThreadGroupName(), <span class="string">&quot;T1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(tg, <span class="keyword">new</span> ThreadGroupName(), <span class="string">&quot;T2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        System.out.println(tg.activeCount());<span class="comment">//获得活动线程总数</span></span><br><span class="line">        tg.list();<span class="comment">//打印线程组所有线程信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String groupAndName = Thread.currentThread().getThreadGroup().getName()</span><br><span class="line">            + <span class="string">&quot;-&quot;</span> + Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I am &quot;</span> + groupAndName);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>stop()可以停止线程组中所有线程</p>
<h3 id="守护线程-Daemon"><a href="#守护线程-Daemon" class="headerlink" title="守护线程  Daemon"></a>守护线程  Daemon</h3><p>在后台默默地完成一些系统性任务：垃圾回收、JIT等</p>
<p>用户线程：工作线程，即完成程序应该要完成的业务操作，守护线程守护工作线程执行</p>
<p><strong>一个Java应用内只有守护线程，Java虚拟机就会自然退出</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonT</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;    </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;I am alive&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		Thread t = <span class="keyword">new</span> DaemonT();</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        </span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>必须start之前设置为守护线程</strong></p>
<p>这里只有主线程main为用户线程，2秒后主线程退出时，整个程序也随之结束</p>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>java内置三个静态变量表示线程优先级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">high.setPriority(MAX_PRIORITY);</span><br><span class="line">low.setPriority(MIN_PRIORITY);</span><br></pre></td></tr></table></figure>

<p>高优先级在大部分情况，都会首先完成任务，但也不一定</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>上文volatile模块提到的i++复合操作是线程不安全的</p>
<p>当线程A写入时，B不仅不能写，同时也不能读，A写完之前，B读取的一定是过期数据</p>
<p>synchronized实现线程间的同步，对同步的代码加锁，使得每一次只能有一个线程进入同步块</p>
<p>用法：</p>
<ul>
<li>指定加锁对象：对给定对象加锁，进入同步代码前要获得给定对象的锁</li>
<li>直接作用于实例方法：对当前实例加锁，进入同步代码前要获得当前实例的锁</li>
<li>直接作用于静态方法：对当前类加锁，进入同步代码前要获得当前类的锁</li>
</ul>
<p>上文synchronize代码也可以写成如下形式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountingSync</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AccountingSync instance = <span class="keyword">new</span> AccountingSync();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100000000</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(instance)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即直接对实例对象加锁，也可以单独封装i++为一个方法，单独给方法加锁</p>
<p>注意：<strong>两个线程操作的是一个实例，这样才能操作一个锁</strong></p>
<p>如果是以下情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AccountingSyncBad());</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AccountingSyncBad());</span><br></pre></td></tr></table></figure>

<p>两个线程指向不同实例，两个线程使用两把不同的锁</p>
<p>但如果将i++封装到静态方法里面然后run方法调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样两个实例执行的仍然是同一个类的静态方法，线程间仍然可以同步</p>
<h3 id="隐蔽的错误"><a href="#隐蔽的错误" class="headerlink" title="隐蔽的错误"></a>隐蔽的错误</h3><h4 id="无提示错误案例"><a href="#无提示错误案例" class="headerlink" title="无提示错误案例"></a>无提示错误案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v1=<span class="number">1073741827</span>;</span><br><span class="line"><span class="keyword">int</span> v2=<span class="number">1431655768</span>;</span><br><span class="line"><span class="keyword">int</span> ave=(v1+v2)/<span class="number">2</span>;<span class="comment">//输出-894784850</span></span><br></pre></td></tr></table></figure>

<p>v1加v2出现一个负数，</p>
<p>在一个复杂系统内部出现该问题，也无任何日志报错，导致问题难以解决</p>
<h4 id="并发下ArrayList"><a href="#并发下ArrayList" class="headerlink" title="并发下ArrayList"></a>并发下ArrayList</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Integer&gt; al = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2000000</span>; j++)&#123;</span><br><span class="line">            al.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread());</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">        System.out.println(al.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>t1和t2同时向一个ArrayList中添加容器，可能会得到三种结果</p>
<p>1.正常结束</p>
<p>2.抛出异常（ArrayIndexOutOfBound）</p>
<p>原因：扩容过程中，内部一致性遭到破坏，由于没有锁保护，另一个线程访问到了不一致的内部状态，导致越界</p>
<p>3.隐蔽错误，打印ArrayList大小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1793758</span></span><br></pre></td></tr></table></figure>

<p>由于多线程访问冲突，两个线程对ArrayList同一位置赋值导致</p>
<p>改进方法：<strong>用线程安全的Vector替代ArrayList</strong></p>
<h4 id="并发下HashMap"><a href="#并发下HashMap" class="headerlink" title="并发下HashMap"></a>并发下HashMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapMultiThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AddThread</span><span class="params">(<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; <span class="number">100000</span>; i += <span class="number">2</span>)&#123;</span><br><span class="line">                map.put(Integer.toString(i), Integer.toBinaryString(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> HashMapMultiThread.AddThread(<span class="number">0</span>));</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> HashMapMultiThread.AddThread(<span class="number">1</span>));</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">        System.out.println(map.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三种结果</p>
<ol>
<li>HashMap大小为100000</li>
<li>小于100000</li>
<li><strong>程序无法结束！！</strong></li>
</ol>
<p>原因：HashMap执行put方法的时候，可能会对HashMap进行扩容操作，扩容操作有一步为transfer方法，类似链表操作（Entry），transfer会改变每个元素的next指针，而且使同一hash值的链表元素逆序，两个线程扩容时调用两次transfer方法，导致第一个线程改变next，另一个线程通过该next遍历同一hash值的元素，结果是形成一个闭环结构！！两个key值互为对方的next，导致陷入死循环</p>
<p>解决方法：JDK8不会存在扩容时出现死循环但仍然线程不安全，建议使用ConcurrentHashMap代替HashMap</p>
<h3 id="错误的加锁"><a href="#错误的加锁" class="headerlink" title="错误的加锁"></a>错误的加锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BadLockOnInteger</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> BadLockOnInteger instance = <span class="keyword">new</span> BadLockOnInteger();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(i)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> THread(instance);</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使加锁，i值也比20000000要小 </p>
<p>原因：Integer不会被修改，而是new一个新的Integer让i重新指向</p>
<p><strong>因为Integer一直在变，导致synchronized加锁的对象一直在变，而不是自增一个特定的对象</strong></p>
<p>解决方法：加锁对象实例，等一个线程操作完实例的一次i++后，让出锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(instance)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-30T03:11:47.000Z" title="2021-3-30 11:11:47 ├F10: AM┤">2021-03-30</time>发表</span><span class="level-item"><time dateTime="2021-03-31T03:46:07.697Z" title="2021-3-31 11:46:07 ├F10: AM┤">2021-03-31</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span><span class="level-item">9 分钟读完 (大约1365个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/30/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A11/">Java高并发程序设计1</a></h1><div class="content"><h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><p>形容一次方法调用    </p>
<p>同步方法调用一旦开始，调用者必须等待方法调用返回后，才能继续后续的行为</p>
<p>异步方法更像是一个消息传递，一旦开始，方法调用就会立即返回，调用者继续后续工作，而异步方法通常会在<strong>另一个线程</strong>“真实地”执行。如果需要，异步调用真实完成时，会通知调用者</p>
<h4 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h4><p>多个任务一起执行</p>
<p>并行：多个任务同时执行</p>
<p>并发：多个任务<strong>交替</strong>执行，串行执行</p>
<h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>一种公共资源或者共享数据，可以被多个线程使用</p>
<p>但一次只能被一个线程使用，一旦临界区资源被占用，其他线程想要使用的话必须等待</p>
<h4 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h4><p>形容多线程之间的相互影响</p>
<p>阻塞：一个线程占用了临界区资源，其他需要该资源的线程就必须在临界区中等待，等待导致线程被挂起</p>
<p>非阻塞：没有线程可以妨碍其他线程执行，所有线程都会不断尝试前向执行</p>
<h4 id="死锁、饥饿和活锁"><a href="#死锁、饥饿和活锁" class="headerlink" title="死锁、饥饿和活锁"></a>死锁、饥饿和活锁</h4><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>线程需要的资源是另一个线程占用的资源，两两之间形成一个闭环，导致永远无法解除阻塞状态</p>
<h5 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h5><p>线程无法获得所需要的资源，导致一直无法执行</p>
<p>可能因为线程优先级太低导致高优先级线程一直抢占它需要的资源</p>
<h5 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h5><p>两个线程都主动将资源释放给对方，导致资源在两线程间跳动，没有一个线程同时拿到所有资源正常执行</p>
<h3 id="并发级别"><a href="#并发级别" class="headerlink" title="并发级别"></a>并发级别</h3><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>synchronized或重入锁，得到阻塞线程</p>
<p>试图执行后续代码前，得到临界区的锁，得不到的话线程就会被挂起等待</p>
<h4 id="无饥饿"><a href="#无饥饿" class="headerlink" title="无饥饿"></a>无饥饿</h4><p>非公平锁：存在优先级高低的线程，导致可能出现饥饿现象</p>
<p>公平锁：先来后到</p>
<h4 id="无障碍"><a href="#无障碍" class="headerlink" title="无障碍"></a>无障碍</h4><p>多线程一起修改临界区数据，如果数据改坏了会导致回滚</p>
<p>悲观策略：经常冲突，保护共享数据</p>
<p>乐观策略：一般不会冲突，遇到则回滚</p>
<p>但严重冲突导致线程不断回滚自己操作，会影响正常执行。希望至少有一个线程在有限时间完成操作后退出临界区</p>
<p><strong>“一致性标记”</strong>：操作前读取，操作完成后再读取，检查标记是否被更改。如果两者一致，说明无冲突，如果不一致，则资源可能在操作过程中与其它写线程冲突，需要重试。任何对资源有修改操作的线程，在修改前都需要更新一致性标记，表示数据不再安全</p>
<h4 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h4><p>无障碍，且保证有一个线程在<strong>有限步内</strong>完成操作离开临界区</p>
<p>特点：无穷循环，尝试修改共享变量，可能会有饥饿问题</p>
<h4 id="无等待"><a href="#无等待" class="headerlink" title="无等待"></a>无等待</h4><p>无锁，每个线程都必须在<strong>有限步</strong>内完成</p>
<p>特点：RCU（Read Copy Update），不控制读操作，写数据时先取得原始数据的副本，修改副本数据，在合适时机回写数据</p>
<p><strong>Amadahl定律</strong></p>
<p>加速比由以下公式求出<br>$$<br>T_n = T_1(F + \frac{1}{n}(1-F))<br>$$</p>
<p>$T_n$表示n个处理器优化后的耗时</p>
<p>$T_1$表示优化前耗时</p>
<p>$F$表示程序中只能串行执行的比例</p>
<p>所以加速比<br>$$<br>加速比=\frac{1}{F+\frac{1}{n}(1-F)}<br>$$<br>结论：提高系统速度不能仅仅增加CPU处理器数量，还要根本上修改程序的串行行为，提高系统内可并行化模块比重    </p>
<p><strong>Gustafson定律</strong><br>$$<br>加速比=n-F(n-1)<br>$$<br>结论：只要不断累加处理器，就能获得更快的速度</p>
<h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><p>Java内存模型</p>
<p>保证多个线程之间可以有效地、正确地协同工作</p>
<p>JMM特点：</p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>指一个不可中断的操作。一个操作一旦开始，就不会被其他线程干扰</p>
<p>int读写原子性，long不是</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>当一个线程修改了某个共享变量的值，其他线程是否能够立即知道这个修改</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>并发时，程序的执行可能出现乱序</p>
<p>原因：可能发生指令重排（指令重排用于减少中断，提升CPU性能）</p>
<h3 id="哪些指令不能重排：Happen-Before规则"><a href="#哪些指令不能重排：Happen-Before规则" class="headerlink" title="哪些指令不能重排：Happen-Before规则"></a>哪些指令不能重排：Happen-Before规则</h3><p>程序顺序原则：语义串行</p>
<p>volatile原则：volatile变量的写先于读发生</p>
<p>锁原则：解锁必然发生随后的加锁前</p>
<p>传递性：A先于B，B先于C，那么A必然先于C</p>
<p>线程的start()方法先于它的每一个动作</p>
<p>线程所有操作先于线程终结</p>
<p>线程的中断(interrupt())先于被中断线程的代码</p>
<p>对象构造函数的执行、结束先于finalize()方法</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-25T14:19:57.000Z" title="2021-3-25 10:19:57 ├F10: PM┤">2021-03-25</time>发表</span><span class="level-item"><time dateTime="2021-04-07T14:41:14.102Z" title="2021-4-7 10:41:14 ├F10: PM┤">2021-04-07</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span><span class="level-item">13 分钟读完 (大约1911个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA2/">深入理解Java虚拟机2</a></h1><div class="content"><h2 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h2><p>线程共享区域：<strong>Java堆</strong>和<strong>方法区</strong>内存分配和回收不确定性</p>
<p>接口多个实现类，方法执行不同的条件分支，所占用的内存都可能不一样</p>
<p>这些部分内存的分配和回收是<strong>动态</strong>的，只有处于运行期间才知道</p>
<h3 id="判定对象是否存活"><a href="#判定对象是否存活" class="headerlink" title="判定对象是否存活"></a>判定对象是否存活</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>简介：对象添加一个引用计数器，每有一个地方引用，计数器加一；引用失效，计数器减一。任何时刻计数器为零的对象就是不能被再使用的  </p>
<p>Java没有采用</p>
<p>问题：很多例外情况没有考虑，需要大量额外处理，例如引用计数很难解决对象之间循环引用的问题</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>简介：通过一系列称为:”GC Roots”的根对象作为起始节点集，从这些节点的引用关系向下搜索，走过的路径称为<strong>引用链</strong>，如果对象到GCRoots之间没有引用链相连，证明对象不可能被再使用</p>
<p>Java采用</p>
<p>GCRoots对象</p>
<ol>
<li>虚拟机栈中引用的对象，各个线程被调用的方法堆栈中用到的参数、局部变量、临时变量等</li>
<li>方法区中类静态属性引用的对象，引用类型静态变量</li>
<li>常量引用的对象，字符串常量池中的引用</li>
<li>本地方法栈中native方法引用的对象</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的class对象，常驻异常对象，还有系统类加载器</li>
<li>所有被同步锁持有的对象</li>
<li>反映虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等等</li>
</ol>
<p>除了这些，还可根据垃圾回收器以及当前回收的内存区域不同，选择其他对象临时性加入</p>
<p>例如，分代收集和<strong>局部回收</strong>，局部回收某个内存区域，该可能有其他区域引用该区域，所以将这些关联区域的对象也一并加入GC Roots集合中，保证可达分析正确性</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>reference：存储的数值代表另一块内存的起始地址</p>
<p>希望描述一类对象：内存空间足够时，还能保存在内存中，而紧张时则可以抛弃——缓存</p>
<p>JDK1.2之后，细分了引用概念</p>
<p>强引用：Object obj = new Object() 只要存在则不会被回收</p>
<p>软引用：还有用，但非必须，在溢出异常发生前，会列入回收范围进行二次回收，回收完如果还是内存不足则发生内存溢出异常</p>
<p>弱引用：强度比软引用更弱，描述非必须对象，只能生存到下次垃圾收集发生为止</p>
<p>虚引用：最弱，无法取得对象实例，唯一目的是垃圾回收时收到一个系统通知</p>
<h4 id="判定对象生存还是死亡"><a href="#判定对象生存还是死亡" class="headerlink" title="判定对象生存还是死亡"></a>判定对象生存还是死亡</h4><p>判定不可达——》被标记——》对标记对象进行一次筛选，条件是是否有必要执行finalize()方法</p>
<p>没有必要或已经被虚拟机调用：视为没有必要执行</p>
<p>有必要执行：置入F-Queue队列，用<strong>Finalizer线程</strong>（优先级低）调用它们去执行finalize方法，对F-Queue进行第二次小规模标记，只要该对象重新和引用链上任何一个对象建立关联便可存活，从而将其移出“即将回收集合”</p>
<h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p>方法区垃圾收集：废弃的常量和不再使用的类型</p>
<p>判断类型不再被使用的条件：</p>
<ol>
<li>该类所有实例都已经被回收</li>
<li>加载该类的类加载器已经被回收</li>
<li>该类的java.lang.Class对象没有在任何地方被引用，也无法在任何地方通过反射访问该类的方法</li>
</ol>
<p>大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，都需要Java虚拟机具备<strong>类型卸载</strong>能力</p>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><p>引用计数式垃圾收集</p>
<p>追踪式垃圾收集（Java用到的）</p>
<h4 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h4><p>由假说奠定垃圾收集器设计原则：将Java堆划分不同区域，然后将回收对象依据年龄分配到不同区域中存储。</p>
<p>有了以上原则，便设计出不同区域，针对不同区域安排与里面存储对象存亡特征相匹配的垃圾收集算法</p>
<p>新生代：每次垃圾收集都发现有大批对象死去，而每次回收后存活的少量对象，将会晋升到老年代中存放</p>
<p>老年代：长存区</p>
<p>问题：新生代的对象也可能被老年代所引用（跨代引用），导致垃圾收集新生代对象时可能还遍历老年代，影响性能</p>
<p>跨代引用假说：跨代引用占少数</p>
<p>跨代解决方法：在新生代上建立记忆集，将老年代划分若干小块，标识哪块内存会存在跨代引用，只有包含跨代引用的小块内存里的对象才会被加入到GC Roots中进行扫描</p>
<h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>标记和清除两个阶段</p>
<p>标记：标记所有需要回收的对象</p>
<p>清除：统一回收所有被标记的对象</p>
<p>缺点：</p>
<p>1.Java堆中大量需要被回收的对象，需要进行大量标记和清除动作</p>
<p>2.内存空间碎片化，使得后面需要分配较大对象而无法找到足够的连续内存</p>
<h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h4><p>半区复制：内存一分为二，每次只使用其中一块，这一块用完，就将还存活的对象复制到另一块上面，然后把这块一次性清理掉，复制时只需移动堆顶指针顺序分配即可</p>
<p>缺点：</p>
<p>1.内存中大量对象存活，复制开销大（多数对象都是可回收时好用，一般<strong>新生代</strong>使用）</p>
<p>2.内存缩小为原来的一半，浪费空间</p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>移动式回收算法，一般<strong>老年代</strong>使用</p>
<p>让所有存活对象向内存一端移动，然后直接清理掉边界以外的内存</p>
<p>权衡：</p>
<p>1.移动更新所有引用这些对象将会是极为负重的操作，导致停顿</p>
<p>2.如果不移动，碎片化问题只能通过内存分配器和内存访问器解决</p>
<p>从吞吐量来看，移动对象更划算</p>
<p>吞吐量：用户程序和收集器效率总和，不移动导致收集器效率高，但是因内存分配和访问相比垃圾收集频率要高很多，这部分耗时增加，总吞吐量仍然下降</p>
<p>和稀泥解决方法：标记清除，是在碎片化严重时用标记整理</p>
<h3 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h3></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-15T11:24:20.000Z" title="2021-3-15 7:24:20 ├F10: PM┤">2021-03-15</time>发表</span><span class="level-item"><time dateTime="2021-03-24T15:00:27.428Z" title="2021-3-24 11:00:27 ├F10: PM┤">2021-03-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span><span class="level-item">16 分钟读完 (大约2354个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA1/">深入理解Java虚拟机1</a></h1><div class="content"><h2 id="Java内存区域与内存溢出异常"><a href="#Java内存区域与内存溢出异常" class="headerlink" title="Java内存区域与内存溢出异常"></a>Java内存区域与内存溢出异常</h2><p>Java虚拟机自动内存管理机制，不需要为每个new操作去写配对的delete/free，不容易出现内存泄漏和内存溢出问题。</p>
<p>但是，控制内存的权利交给了Java虚拟机，一旦出现内存泄漏和内存溢出问题，排查错误并修正将会异常艰难。</p>
<h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>当前线程所执行字节码的行号指示器：字节码解释器通过改变计数器的值来选取下一条需要执行的字节码指令</p>
<p>程序控制流的指示器：分支、循环、跳转、异常处理、线程恢复等都依赖该计数器</p>
<p>多线程：线程轮流切换，分配处理器执行时间，任何一个确定时刻，一个处理器内核只会执行一条线程中的指令</p>
<p>线程私有：切换线程时，为了能够回到正确位置，每条线程都需要有个独立的程序计数器</p>
<h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>线程私有：生命周期和线程相同</p>
<p>Java方法执行的线程内存模型：方法被执行，Java虚拟机同步创建一个栈帧</p>
<p>JVM创建的栈帧：存储局部变量表、操作数栈、动态连接、方法出口等信息，</p>
<p>每一个方法被调用到执行完毕  &lt;——&gt; 一个栈帧从虚拟机栈入栈到出栈</p>
<h5 id="局部变量表：“栈”"><a href="#局部变量表：“栈”" class="headerlink" title="局部变量表：“栈”"></a>局部变量表：“栈”</h5><p>存放JVM<strong>基本数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference类型，它并不等同于对象本身，而是一个指向对象起始位置的引用指针，也可能指向一个代表对象的句柄或其他与此对象相关的位置）和<strong>returnAddress类型</strong>（指向了一条字节码指令的地址）</p>
<p>局部变量槽（Slot）：存储这些数据类型，除了long和double占用2个，其余占用1个</p>
<p>局部变量空间确定：进入一个方法时，局部变量空间大小（变量槽的数量）确定</p>
<p>内存区域异常：</p>
<p>StackOverflow异常：线程请求的深度大于虚拟机允许的深度</p>
<p>OutOfMemoryError异常：栈可以动态扩展的虚拟机（Hotspot不会）扩展时无法申请到足够内存会抛出OutOfMemoryError异常</p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>类似虚拟机栈，但本地方法栈为JVM用到的本地方法服务</p>
<p>异常和虚拟机栈类似</p>
<h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>JVM内存最大的一块</p>
<p>所有线程共享</p>
<p>存放对象实例和数组（几乎所有，但不一定，逃逸分析技术、栈上分配、标量替换优化手段导致一些微妙变化）</p>
<p><strong>垃圾回收器</strong>管理Java堆（GC堆）</p>
<p><strong>线程私有</strong>的<strong>分配缓冲区</strong>（TLAB）：提升对象分配效率,目的只是更好回收内存，更快分配内存</p>
<p>物理上不连续，逻辑上连续，但大对象可能要求连续</p>
<p>可扩展可固定大小：主流可扩展，没有完成实例分配，堆无法再扩展时，会抛出OutOfMemoryError异常</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>线程共享</p>
<p>存储JVM加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>
<p>本地空间实现元空间来代替永久代</p>
<p>不需连续内存，可选择固定大小或可扩展，甚至可以选择不实现垃圾收集</p>
<p>回收效果不好，尤其是类型的卸载，但有时又很有必要</p>
<p>OutOfMemoryError</p>
<h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>常量池表：编译期生成的各种字面量与符号引用，类加载后存放到方法区的运行时常量池中。</p>
<p>动态性：常量不一定只有编译期才能产生，String intern()</p>
<p>OutOfMemoryError</p>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>通道+缓冲区直接操作Native函数库分配堆外内存，通过DirectByteBuffer对象作为这块内存的引用，从而提高性能</p>
<h3 id="HotSpot虚拟机"><a href="#HotSpot虚拟机" class="headerlink" title="HotSpot虚拟机"></a>HotSpot虚拟机</h3><h4 id="HotSpot虚拟机Java堆中对象的创建"><a href="#HotSpot虚拟机Java堆中对象的创建" class="headerlink" title="HotSpot虚拟机Java堆中对象的创建"></a>HotSpot虚拟机Java堆中对象的创建</h4><p>检测到字节码<strong>new指令</strong></p>
<p>检查new指令的参数能否在<strong>常量池</strong>中定位到一个类的<strong>符号引用</strong></p>
<p>检查该符号引用代表的类是否已被加载，否则必须先执行<strong>类加载</strong></p>
<p>类加载检查通过后，虚拟机为新生对象分配内存。（类加载后对象所需内存大小即可完全确定）</p>
<p>给对象分配内存=把一块确定大小的内存从Java堆中划分出来</p>
<p>指针碰撞：假设所有被使用过的内存都放到一边，空闲内存放另一边，指针指向中间的分界点，内存分配就是向空闲内存一边挪动与新生对象大小相等的距离</p>
<p>空闲列表：已被使用的内存和空闲的内存相互交错在一起，虚拟机必须维护一个列表，记录哪些内存块可用，分配时在列表中找一块足够大的空间给对象实例，并更新表上的记录</p>
<p>如何选择分配内存方式？——Java堆是否规整决定</p>
<p>是否规整？——gc是否带有<strong>空间压缩整理</strong>的能力决定，例如Serail、ParNew能指针碰撞，而CMS基于清除算法，理论上只能空闲列表</p>
<p><strong>对象创建频繁，并发时线程不安全</strong></p>
<p>解决方案：</p>
<p>1.同步处理分配内存空间的动作，采用CAS配上失败重试</p>
<p>2.内存分配的动作按照线程划分在不从空间中进行，即每个线程在Java堆中预先分配一小块内存（本地线程分配缓冲 TLAB），优先使用线程自己的本地缓冲区，只有用完了，分配新缓冲区时才需要同步锁定.</p>
<p>内存分配完成后，分配到的内存空间初始化为0值（不包括对象头），也可TLAB分配之前就初始化，保证可以直接使用这些对象</p>
<p>然后，JVM对对象进行必要设置：哪个类的实例、如何找到元数据信息、对象的哈希码（实际上调用hashCode时才计算）、对象GC分代年龄等信息。这些信息存放在<strong>对象头</strong>中</p>
<p>对象头设置方式不同：由JVM当前运行状态决定</p>
<p>对象诞生了</p>
<p>但是Java程序的视角，对象创建刚开始——构造函数，new指令跟随invokespecial指令，随后按照程序员的意愿初始化，才将对象创建完毕</p>
<h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>三部分：对象头、实例数据、对齐填充</p>
<h5 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h5><p>MarkWord：存储对象自身运行时数据，头信息是与对象自身定义的数据无关的额外存储成本，一个动态定义的数据结构</p>
<table>
<thead>
<tr>
<th>存储内容</th>
<th>标志位</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>对象哈希码（25）、对象分代年龄（4）</td>
<td>01</td>
<td>未锁定</td>
</tr>
<tr>
<td>指向锁记录的指针（1）</td>
<td>00</td>
<td>轻量级锁定</td>
</tr>
<tr>
<td>指向重量级锁的指针（1）</td>
<td>10</td>
<td>膨胀（重量级锁定）</td>
</tr>
<tr>
<td>空，不需要记录信息（1）</td>
<td>11</td>
<td>GC标记</td>
</tr>
<tr>
<td>偏向线程ID、偏向时间戳、对象分代年龄</td>
<td>01</td>
<td>可偏向</td>
</tr>
</tbody></table>
<p>类型指针：指向类型元数据的指针，确定是哪个类的实例。对象数据上不一定保留类型指针。如果是Java数组，对象头还要有一块记录数组长度的数据</p>
<p><strong>实例数据信息</strong></p>
<p>程序代码里面定义的各种类型的字段内容</p>
<p>存储顺序会受<strong>分配策略参数</strong>和<strong>定义顺序</strong>影响</p>
<p>默认分配顺序：longs/doubles、ints、shorts/chars、bytes/booleans、oops 相同宽度的字段一起存放</p>
<p>父类定义的变量在子类之前</p>
<p><strong>对齐填充</strong></p>
<p>占位符，HotSpot要求对象起始地址是<strong>8字节整数倍</strong></p>
<p>即任何对象大小是8字节整数倍</p>
<h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>reference数据：在栈上，来操作堆上的具体对象</p>
<p>如何定位访问堆中对象具体位置：</p>
<p>1.句柄访问，Java堆中多出一块句柄池，reference存储对象的句柄地址，而句柄包含对象实例数据地址和类型数据的地址信息</p>
<p>2.直接指针访问，reference存储的直接就是对象地址，而需要考虑Java堆中对象的内存布局</p>
<p>句柄的好处：对象被移动时只会改变句柄中的实例数据指针，而不需要修改reference指针</p>
<p>直接指针好处：速度快，HotSpot使用这种，使用Shenandoah手机也会有一次额外转发</p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="ParadoX"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">ParadoX</p><p class="is-size-6 is-block">Paradox的IT小屋</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>青岛，中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">12</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/lrj1996123" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/lrj1996123"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/leetcode/"><span class="level-start"><span class="level-item">leetcode</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/web%E5%89%8D%E7%AB%AF/"><span class="level-start"><span class="level-item">web前端</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">读书笔记</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%9D%A2%E8%AF%95/"><span class="level-start"><span class="level-item">面试</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/JS/"><span class="tag">JS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/REACT/"><span class="tag">REACT</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Trie%E6%A0%91/"><span class="tag">Trie树</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VUE/"><span class="tag">VUE</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/"><span class="tag">《深入理解Java虚拟机》</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E3%80%8A%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"><span class="tag">《高并发程序设计》</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"><span class="tag">二分查找</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="tag">动态规划</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"><span class="tag">状态压缩</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E8%AF%95/"><span class="tag">面试</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-12T02:50:48.000Z">2021-04-12</time></p><p class="title"><a href="/2021/04/12/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/">Java高并发程序设计4</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-10T03:47:20.000Z">2021-04-10</time></p><p class="title"><a href="/2021/04/10/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13-3/">Java高并发程序设计3-3</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-08T02:25:16.000Z">2021-04-08</time></p><p class="title"><a href="/2021/04/08/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13-2/">Java高并发程序设计3-2</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-07T03:09:10.000Z">2021-04-07</time></p><p class="title"><a href="/2021/04/07/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/">Java高并发程序设计3</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-31T03:46:29.000Z">2021-03-31</time></p><p class="title"><a href="/2021/03/31/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/">Java高并发程序设计2</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a><p class="is-size-7"><span>&copy; 2021 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>