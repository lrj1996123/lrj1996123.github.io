<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>标签: 《高并发程序设计》 - Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Hexo"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Hexo"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Hexo","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/lrj1996123"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">《高并发程序设计》</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-08T02:25:16.000Z" title="2021-4-8 10:25:16 ├F10: AM┤">2021-04-08</time>发表</span><span class="level-item"><time dateTime="2021-04-10T03:44:38.174Z" title="2021-4-10 11:44:38 ├F10: AM┤">2021-04-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span><span class="level-item">15 分钟读完 (大约2322个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/08/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13-2/">Java高并发程序设计3-2</a></h1><div class="content"><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程本身占用内存，创建和关闭花费时间</p>
<p>必须在有限范围内增加线程数量，否则会拖垮系统，对系统有害</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>线程复用：需要时从池子中拿一个，完成工作时将线程退回到池子中，方便他人使用</p>
<h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>Executors类：线程池工厂，获取一个具有特定功能的线程池</p>
<p>ThreadPoolExecutor：表示一个线程池，可以调度任何对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回固定线程池，线程数量不变，提交新任务，若有空闲线程，则立即执行；若没有，则新任务暂存在一个任务队列中，待有空闲线程时执行队列中的任务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>;</span><br><span class="line"><span class="comment">//返回只有一个线程的线程池，多余任务保存在任务队列中，待线程空闲队列按先入先出执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//根据实际情况调整线程数量，提交新任务，空闲则复用，无空闲则创建</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//计划任务线程池，线程池大小为1，在ExecutorService基础上扩展了在给定时间执行某任务的功能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//指定数量的计划任务线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span>;</span><br></pre></td></tr></table></figure>

<p>1.<strong>固定大小线程池</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + <span class="string">&quot;:Thread ID:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyTask task = <span class="keyword">new</span> MyTask();</span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            es.submit(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给定线程池大小是5，5个线程同时执行，这里提交了10个任务，先执行5个，再执行5个，两者线程是复用的</p>
<p>2.<strong>计划任务</strong></p>
<p>可以根据时间需要调度线程</p>
<p>主要方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="keyword">long</span> delay, TimeUnit unit);<span class="comment">//给定时间任务调度</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit); <span class="comment">//对任务周期性调度，任务开始时initialDelay为起点，在之后的period周期时间调度下一次任务</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> delay, TimeUnit unit);<span class="comment">//对任务周期性调度，任务开始时initialDelay为起点，上一个任务结束后再经过delay时间后再进行任务调度</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService ses = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">ses.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(System.currentTimeMillis()/<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>如图，初始0延迟，每2秒执行一次线程任务</p>
<p>问题：如果任务执行时间超过2秒会发生什么？</p>
<p>答：任务会在上一个任务结束后立即被调用</p>
<p>注意：如果任务改成scheduleWithFixedDelay()执行8秒，周期2秒，任务实际间隔10秒</p>
<h3 id="核心线程池的内部实现"><a href="#核心线程池的内部实现" class="headerlink" title="核心线程池的内部实现"></a>核心线程池的内部实现</h3><p>以上方法都是ThreadPoolExecutor类的封装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,//指定了线程池中的线程数量</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> maximumPoolSize,//指定了线程池最大线程数量</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> keepAliveTime,//线程池数量超过corePoolSize，多余的线程存活时间</span></span></span><br><span class="line"><span class="function"><span class="params">                         TimeUnit unit,//keepAliveTime单位</span></span></span><br><span class="line"><span class="function"><span class="params">                         BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，被提交但尚未被执行</span></span></span><br><span class="line"><span class="function"><span class="params">                         ThreadFactory threadFactory,//线程工厂</span></span></span><br><span class="line"><span class="function"><span class="params">                         RejectedExecutionHandler handler)</span><span class="comment">//拒绝策略，如何拒绝任务</span></span></span><br></pre></td></tr></table></figure>

<p>workQueue是一个BlockingQueue接口的对象，仅用于存放Runnable，根据队列功能分类：</p>
<p>1.直接提交的队列：SynchronousQueue对象提供，没有容量，每插入一个都要等待一个删除操作，反之，每一个删除操作都要等待对应的插入操作，不会保存任务，而直接交给线程执行</p>
<p>2.有界的任务队列：ArrayBlockingQueue，线程数小于corePoolSize，否则加入队列，队列满再创建线程（小于maximumPoolSize）</p>
<p>3.无界的任务队列，LinkedBlockingQueue，线程小于corePoolSize，否则直接入队等待</p>
<p>4.优先任务队列：PriorityBlockingQueue，特殊的无界队列，根据任务优先级顺序先后执行</p>
<h4 id="线程池工作逻辑"><a href="#线程池工作逻辑" class="headerlink" title="线程池工作逻辑"></a>线程池工作逻辑</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span>(workerCountOf(c) &lt; corePoolSize)&#123;<span class="comment">//线程数小于corPoolSize，直接创建线程</span></span><br><span class="line">        <span class="keyword">if</span>(addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isRunning(c) &amp;&amp; workQueue.offer(command))&#123;<span class="comment">//进入等待队列</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span>(!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!addWorker(command, <span class="keyword">false</span>))<span class="comment">//进入等待队列失败（队列满），直接进入线程池，若再失败则拒绝</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><p>AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作</p>
<p>CallerRunsPolicy策略：只要线程池未关闭，直接在调用者线程中运行任务，可能会使性能下降</p>
<p>DiscardOldestPolicy策略：丢弃最老的一个请求（即将被执行的任务），并尝试再次提交当前任务</p>
<p>DiscardPolicy策略：默默地丢弃无法处理的任务</p>
<p>以上策略均实现了RejectedExecutionHandler接口，可以自己扩展</p>
<p>自定义线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es = </span><br><span class="line">    <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                           <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">10</span>),</span><br><span class="line">                           Executors.defaultThreadFactory(),</span><br><span class="line">                           <span class="keyword">new</span> RejectedExecutionHandler()&#123;</span><br><span class="line">                               <span class="meta">@Override</span></span><br><span class="line">                               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r,                                                            ThreadPoolExecutor executor)</span></span>&#123;</span><br><span class="line">                                   System.out.println(r.toString() + <span class="string">&quot; is                                                    discard&quot;</span>);</span><br><span class="line">                               &#125;</span><br><span class="line"></span><br><span class="line">                           &#125;);</span><br></pre></td></tr></table></figure>

<p>分析：5个常驻线程，最大线程数量是5个，这和固定大小线程池一样，但等待队列容量只有10来保证系统稳定，拒绝策略增加打印信息的小功能</p>
<h4 id="自定义线程创建：ThreadFactory"><a href="#自定义线程创建：ThreadFactory" class="headerlink" title="自定义线程创建：ThreadFactory"></a>自定义线程创建：ThreadFactory</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadFactory()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上自定义线程创建让每个线程都设置为守护线程</p>
<h4 id="扩展线程池"><a href="#扩展线程池" class="headerlink" title="扩展线程池"></a>扩展线程池</h4><p>扩展目的：监控任务执行的开始时间和结束时间，便于调试</p>
<p>ThreadPoolExecutor可以扩展，自身提供beforeExecute()、afterExecute()、terminated()三个接口用来对线程池进行控制</p>
<p>其在ThreadPoolExecutor.runWorker(Worker w)上实现，其中Worker实例正是工作线程。Worker.run方法调用上述runWorker实现每一个线程的固有工作</p>
<p>ThreadPoolEx重写三个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                            <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;())&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备执行&quot;</span> + ((MyTask) r).name);</span><br><span class="line">        <span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行完成&quot;</span> + ((MyTask) r).name);</span><br><span class="line">        <span class="keyword">super</span>.afterExecute(r, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程退出&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.terminated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="优化线程池线程数量"><a href="#优化线程池线程数量" class="headerlink" title="优化线程池线程数量"></a>优化线程池线程数量</h3><p>估算线程池大小：<br>$$<br>N_{cpu} = CPU数量<br>$$</p>
<p>$$<br>U_{cpu}=目标CPU的使用率，0\le U_{cpu} \le 1<br>$$</p>
<p>$$<br>W/C = 等待时间与计算时间的比率<br>$$</p>
<p>为保持处理器达到期望的使用率，最优线程池的大小等于<br>$$<br>N_{threads} = N_{cpu} \times U_{cpu} \times (1 + W/C)<br>$$</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().availableProcessors()<span class="comment">//取得CPU可用数量</span></span><br></pre></td></tr></table></figure>

<h3 id="线程池中寻找堆栈"><a href="#线程池中寻找堆栈" class="headerlink" title="线程池中寻找堆栈"></a>线程池中寻找堆栈</h3><p>线程池运行线程时一个线程出错可能会没有任何错误提示</p>
<p>“最鄙视那些出错不打印异常堆栈的行为！”</p>
<p>讨回堆栈</p>
<p><strong>1.放弃submit，改为execute</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pools.executes(<span class="keyword">new</span> Task());</span><br></pre></td></tr></table></figure>

<p><strong>2.改造submit方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Future re = pools.submit(<span class="keyword">new</span> Task());</span><br><span class="line">re.get();</span><br></pre></td></tr></table></figure>

<p>两种方法都可以得到部分堆栈信息（<strong>异常抛出位置</strong>）</p>
<p>如何确定任务提交的位置？</p>
<p>调度任务前，保存一下提交任务线程的堆栈信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TraceThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.execute(wrap(task, clientTrace(), Thread.currentThread().getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.submit(wrap(task, clientTrace(), Thread.currentThread().getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Exception <span class="title">clientTrace</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Client stack trace&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Runnable <span class="title">wrap</span><span class="params">(<span class="keyword">final</span> Runnable task, <span class="keyword">final</span> Exception clientStack, String clientThreadName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    clientStack.printStackTrace();</span><br><span class="line">                    <span class="keyword">throw</span> e;<span class="comment">//关键代码，抛出异常，挖出堆栈信息</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如图通过wrap包裹一下submit信息，让异常信息可以被打印出来，不仅得到了异常出现的位置，还得到了任务是哪里提交的，从而得到比较完整的异常信息</p>
<h3 id="分而治之：Fork-Join框架"><a href="#分而治之：Fork-Join框架" class="headerlink" title="分而治之：Fork/Join框架"></a>分而治之：Fork/Join框架</h3><p>fork：开启线程（子进程）,提交子任务；将任务分解成多个子任务，最终合并所有任务结果</p>
<p>join：等待线程执行完毕，返回结果</p>
<p>ForkJoinPool：分而治之线程池</p>
<p>ForkJoinTask：分而治之任务</p>
<p>RecursiveTask：ForkJoinTask子类，有返回值</p>
<p>RecursiveAction：ForkJoinTask子类，无返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span><span class="comment">//子类重写</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> canCompute = (end - start) &lt; THRESHOLD;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(canCompute)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">long</span> step = (end + start) / <span class="number">100</span>;</span><br><span class="line">        List&lt;CountTask&gt; subTasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> pos = start;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">long</span> lastOne = pos + step;</span><br><span class="line">            <span class="keyword">if</span>(lastOne &gt; end) lastOne = end;</span><br><span class="line">            CountTask subTask = <span class="keyword">new</span> CountTask(pos, lastOne);</span><br><span class="line">            pos += step + <span class="number">1</span>;</span><br><span class="line">            subTasks.add(subTask);</span><br><span class="line">            subTask.fork();<span class="comment">//所有子任务fork</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(CountTask t: subTasks)&#123;</span><br><span class="line">            sum += t.join();<span class="comment">//子任务join方法计算出结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;<span class="comment">//RecursiveTask子任务计算有一个返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子任务越多，性能会下降，可能会出现栈溢出异常</p>
<h3 id="Guava对线程池的扩展"><a href="#Guava对线程池的扩展" class="headerlink" title="Guava对线程池的扩展"></a>Guava对线程池的扩展</h3><p><strong>DirectExecutor线程池</strong></p>
<p>目的：抽象线程池，线程加入后，并没有创建线程，而使其在当前线程中执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Executor executor = MoreExecutors.directExecutor();</span><br><span class="line">    executor.execute(()-&gt;System.out.println(<span class="string">&quot;I am running in&quot;</span> + thread.currentThread.getName()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以注入不同的executor实现，无需修改代码使程序拥有不同行为</p>
<p><strong>Daemon线程池</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoreExecutors.getExitingExecutorService(executor);</span><br></pre></td></tr></table></figure>

<p>使得后台线程池的存在不会阻止进程结束执行</p>
<p><strong>扩展Future</strong></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-07T03:09:10.000Z" title="2021-4-7 11:09:10 ├F10: AM┤">2021-04-07</time>发表</span><span class="level-item"><time dateTime="2021-04-07T13:07:32.088Z" title="2021-4-7 9:07:32 ├F10: PM┤">2021-04-07</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span><span class="level-item">15 分钟读完 (大约2244个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/07/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/">Java高并发程序设计3</a></h1><div class="content"><h2 id="JDK并发包"><a href="#JDK并发包" class="headerlink" title="JDK并发包"></a>JDK并发包</h2><p>本章介绍JDK内部大量实用的框架，主要分为三个方面：</p>
<ul>
<li>同步控制工具</li>
<li>线程池相关</li>
<li>并发容器</li>
</ul>
<h3 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h3><h4 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReenterLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000000</span>; j++)&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> trows InterruptedException</span>&#123;</span><br><span class="line">        ReenterLock rl = <span class="keyword">new</span> ReenterLock();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(rl);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(rl);</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>灵活：开发人员必须手动指定何时加锁，何时释放锁（<strong>退出临界区时必须释放锁</strong>）</p>
<p>重入：一个线程可以连续多次获得锁，但也必须释放相同次数</p>
<p>释放次数多会出现IllegalMonitorStateException异常</p>
<p>释放次数少会使其他线程无法进入临界区</p>
<h5 id="重入锁高级功能"><a href="#重入锁高级功能" class="headerlink" title="重入锁高级功能"></a>重入锁高级功能</h5><p>1.<strong>中断响应</strong></p>
<p>线程等待锁——&gt;获得锁/<strong>被中断</strong></p>
<p>通过重入锁实现对等待状态的中断，甚至可以解决死锁问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.lockInterruptibly();</span><br></pre></td></tr></table></figure>

<p>通过以上代码，线程等待获得锁，如果两线程请求的锁都被对方占用而无法释放，导致死锁，则会使其中一个线程中断释放资源，防止死锁发生，但最后只有一个线程完成了任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.isHeldByCurrentThread();</span><br></pre></td></tr></table></figure>

<p>上述代码表示判断当前线程是否拥有该锁</p>
<p>2.<strong>锁申请等待限时</strong></p>
<p>trylock第一个参数是等待时长，第二个时时间单位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(lock.tryLock(<span class="number">5</span>,TimeUnit.SECONDS))&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法可以使锁请求最多等待5秒，如果超过5秒就会自动放弃</p>
<p>tryLock方法也可以无参调用，如果锁未被占用则直接获取，如果被占用则不会等待，直接放弃本次请求，从而解决死锁问题</p>
<p>3.<strong>公平锁</strong></p>
<p>非公平锁：锁可用时随机给一个线程</p>
<p>保证先到先得，后到后得，不会产生饥饿现象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span></span></span><br></pre></td></tr></table></figure>

<p>fair为true则为公平锁，公平锁必然要维护一个有序队列，成本高，所以默认非公平</p>
<p>重入锁实现三要素：</p>
<ol>
<li>原子状态，使用CAS存储锁状态，判断锁是否被别的线程持有</li>
<li>等待队列，没有请求到锁的线程会进入等待队列进行等待，释放锁后会唤醒一个线程</li>
<li>阻塞原语park()和unpark()，用来挂起和恢复线程。没有得到锁的线程将会被挂起</li>
</ol>
<p>内核或微核提供核外调用的过程或函数称为<em>原语</em>(primitive)。<em>原语</em>是一段用机器指令编写的完成特定功能的程序,在执行过程中不允许中断。 </p>
<h5 id="重入锁搭档：Condition"><a href="#重入锁搭档：Condition" class="headerlink" title="重入锁搭档：Condition"></a>重入锁搭档：Condition</h5><p>类似wait和notify，wait和notify适合与synchronized一起用，Condition与重入锁一起用</p>
<p>通过lock接口的Condition newCondition()方法生成与当前重入锁绑定的Condition实例</p>
<p>让线程在合适时间等待，特定时刻得到通知</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;<span class="comment">//当前线程等待同时释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;<span class="comment">//不会在等待过程中响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;<span class="comment">//唤醒等待线程，重新获得锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;<span class="comment">//唤醒所有等待线程</span></span><br></pre></td></tr></table></figure>

<p>Condition功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReenterLockCondition</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line">        <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">static</span> ReenterLockCondition instance = <span class="keyword">new</span> ReenterLockCondition();</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException ie)&#123;</span><br><span class="line">                ie.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">            Thread t1 = <span class="keyword">new</span> Thread(condition);</span><br><span class="line">            t1.start();</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            lock.lock();</span><br><span class="line">            condition.signal();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>await要求线程持有相关重入锁，执行后释放这把锁</p>
<p>signal要求线程先获得相关锁，调用后从Condition对象的等待队列中唤醒一个线程，使之尝试重新获得与之绑定的重入锁，所以signal之后需要通过unlock释放锁才能真正唤醒t1</p>
<h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>指定多个线程同时访问某个资源，锁的扩展</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits,<span class="meta">@Nullable</span> <span class="keyword">boolean</span> fair)</span></span></span><br></pre></td></tr></table></figure>

<p>其主要逻辑方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span></span>;<span class="comment">//尝试获得一个准入许可，若无法获得则等待，直到有线程释放许可或中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span></span>;<span class="comment">//不响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span></span>;<span class="comment">//尝试获得一个许可 成功true 失败false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span>;<span class="comment">//限定时间内尝试获得许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span><span class="comment">//许可释放 一个acquire对应一个release否则会发生泄露</span></span></span><br></pre></td></tr></table></figure>

<h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><p>JDK5提供的读写分离锁</p>
<p>重写锁和内部锁的读、写都是串行操作，但是读操作并没有破坏数据，所以不合理</p>
<p><strong>读写锁允许多个线程同时读</strong></p>
<p>但是考虑数据完整性，<strong>写写操作</strong>和<strong>读写操作</strong>依然需要相互等待和持有锁</p>
<table>
<thead>
<tr>
<th></th>
<th>读</th>
<th>写</th>
</tr>
</thead>
<tbody><tr>
<td>读</td>
<td>非阻塞</td>
<td>阻塞</td>
</tr>
<tr>
<td>写</td>
<td>阻塞</td>
<td>阻塞</td>
</tr>
</tbody></table>
<p>读操作次数远远大于写操作次数时，读写锁就可以发挥最大功效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Lock readLock = readWriteLock.readLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Lock writeLock = readWriteLock.writeLock();</span><br></pre></td></tr></table></figure>

<p>读写锁分离，使得读操作非常快</p>
<h5 id="倒计数器：CountDownLatch"><a href="#倒计数器：CountDownLatch" class="headerlink" title="倒计数器：CountDownLatch"></a>倒计数器：CountDownLatch</h5><p>控制线程，让线程等待直到倒计数结束，再开始执行</p>
<p>场景：火箭发射前需要各项准备工作完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch end = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        end.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        exec.submit(demo);</span><br><span class="line">    &#125;</span><br><span class="line">    end.await();<span class="comment">//等待检查</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Fire！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如图，countDown方法通知CountDownLatch，一个线程完成任务，倒计数减一，任务全部完成后，再点火发射火箭</p>
<h5 id="循环栅栏：CyclicBarrier"><a href="#循环栅栏：CyclicBarrier" class="headerlink" title="循环栅栏：CyclicBarrier"></a>循环栅栏：CyclicBarrier</h5><p>类似倒计数器，但是有循环特性：如设置为10，第一批10个线程结束后，计数器就会归零，接着凑下一批10个线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span></span></span><br></pre></td></tr></table></figure>

<p>barrierAction表示一次计数完成后，系统会执行的动作</p>
<p>关键代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier cyclic;<span class="comment">//在main函数传参创建</span></span><br><span class="line"><span class="comment">//等待所有士兵到齐</span></span><br><span class="line">cyclic.await();</span><br><span class="line">doWork();</span><br><span class="line"><span class="comment">//等待所有士兵完成工作</span></span><br><span class="line">cyclic.await();</span><br></pre></td></tr></table></figure>

<p>第一次await，每个士兵线程会等待，直到集合完毕，barrierAction会执行一次</p>
<p>第二次await，进行下一次计数，在doWork执行完毕后进行，主要目的是监控是否所有士兵都完成了任务</p>
<p>注意：如果手动中断一个线程，其他9个线程会抛出BrokenBarrierException异常，避免永久无所谓的等待</p>
<h5 id="线程阻塞工具类：LockSupport"><a href="#线程阻塞工具类：LockSupport" class="headerlink" title="线程阻塞工具类：LockSupport"></a>线程阻塞工具类：LockSupport</h5><p>任意位置线程阻塞，不需要获得某个对象的锁</p>
<p>静态方法park()可以阻塞当前线程</p>
<p>用LockSupport的park和unpark替换掉第二章suspend和resume方法，结果导致程序正常运行！而没有永久挂起</p>
<p>原因：LockSupport类使用了类似信号量的机制，每个线程准备一个许可，如果许可可用，park方法立刻返回，许可变为不可用；如果许可不可用，就会阻塞，而unpark方法使一个许可变得可用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">run()&#123;</span><br><span class="line">    LockSupport.park();<span class="comment">//直接调用阻塞线程</span></span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">    LockSupport.unpark(t1);<span class="comment">//直接调用解挂t1阻塞状态，如果unpark发生在park()之前，也可以使下次park()立刻返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了定时阻塞，还可以支持中断影响</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">run()&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(u)&#123;</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        <span class="keyword">if</span>(Thread.interrupted())&#123;<span class="comment">//中断后可以直接响应</span></span><br><span class="line">            System.out.println(getName() +<span class="string">&quot;被中断了&quot;</span>)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.interrupt();<span class="comment">//中断t1,t1执行结束，之后t2才可进入临界区</span></span><br><span class="line">    LockSupport.unpark(t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Guava下限流工具RateLimiter"><a href="#Guava下限流工具RateLimiter" class="headerlink" title="Guava下限流工具RateLimiter"></a>Guava下限流工具RateLimiter</h5><p>对于一个应用来说，每秒能处理的请求是有限的，一旦突破上限，甚至可能压垮系统，因此限流很有必要</p>
<p>漏桶算法：利用一个缓存区，无论请求速率如何，都先进入缓存区保存，然后以固定速率处理请求</p>
<p>令牌桶算法：桶中存放令牌，每个单位时间产生一定量令牌存入桶中，处理程序拿到令牌才可处理请求，而且桶容量有限，桶慢则丢弃令牌</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> RateLimiter limiter = RateLimiter.create(<span class="number">2</span>);<span class="comment">//每秒生产2个令牌</span></span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">        limiter.acquire();<span class="comment">//请求令牌</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开50个线程，可能只需半秒，但我们规定一秒只能开2个线程，所以acquire使得过剩的流量等待，直到合适的时候执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!limiter.tryAcquire())&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task()).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可如上图，通过tryAcquire方法，直接丢弃过载请求，尽可能避免系统崩溃 500ms内所有都可完成，所以这里只有一个输出</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-31T03:46:29.000Z" title="2021-3-31 11:46:29 ├F10: AM┤">2021-03-31</time>发表</span><span class="level-item"><time dateTime="2021-04-06T13:59:55.676Z" title="2021-4-6 9:59:55 ├F10: PM┤">2021-04-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span><span class="level-item">20 分钟读完 (大约3003个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/31/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/">Java高并发程序设计2</a></h1><div class="content"><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><p>进程：程序的一次执行过程，是系统进行资源分配和调度的基本单位，是线程的容器</p>
<p>线程：轻量级进程，是程序执行的最小单位，线程间切换和调度成本远小于进程，所以使用多线程进行并发程序设计  </p>
<h3 id="线程基本操作"><a href="#线程基本操作" class="headerlink" title="线程基本操作"></a>线程基本操作</h3><h4 id="新建线程启动"><a href="#新建线程启动" class="headerlink" title="新建线程启动"></a>新建线程启动</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> CreateThread());</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Oh, I am Runnable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中启动线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread();</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure>

<p>start()：新建一个线程并让线程执行run()方法</p>
<p>不要直接调用run()方法，它只会在当前线程中串行执行方法中的代码</p>
<h4 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h4><p>Thread.stop()方法终止线程，被废弃不推荐使用</p>
<p>原因：方法过于暴力，终止时可能并没有完成相关写操作</p>
<p>停止线程方法：在完成run所有写操作时stop,保证不会在setId和setName之间stop</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeObjectThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> stopme = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopMe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stopme = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stopme)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;exit by stop me&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span>(u)&#123;<span class="comment">//u为边缘区变量</span></span><br><span class="line">                <span class="keyword">int</span> v = (<span class="keyword">int</span>) (System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">                u.setId(v);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                u.setName(String.valueOf(v));</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h4><p>线程中断：不会立即退出，而是线程收到一个希望退出的通知，具体何时退出由线程自己决定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Interrupted!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如图，执行t1.interrupt()方法之后，通知t1被中断，具体何时中断可在while语句内控制</p>
<h5 id="Time-sleep-函数"><a href="#Time-sleep-函数" class="headerlink" title="Time.sleep()函数"></a>Time.sleep()函数</h5><p>线程休眠若干时间，期间如果中断会抛出InterruptedException中断异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Interrupted When Sleep&quot;</span>);</span><br><span class="line">    <span class="comment">//设置中断状态</span></span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<strong>捕获中断后，会清除中断标记</strong>，这时需要再次设置中断标记位</p>
<h4 id="等待和通知"><a href="#等待和通知" class="headerlink" title="等待和通知"></a>等待和通知</h4><p>obj.wait()：线程处于等待状态，线程停止运行</p>
<p>进入object对象的等待队列</p>
<p>必须包含在synchronized语句中，<strong>执行后会释放锁</strong></p>
<p>obj.notify()：线程结束等待，继续执行</p>
<p>等待队列中随机选择一个线程，将其唤醒（非公平）</p>
<p>无论是wait和notify必须首先获得目标对象的一个监视器（对象锁）</p>
<p>T1在wait方法执行前获取监视器，执行后释放，目的是使其他等待在obj对象上的线程不至于因为T1的休眠而全部无法正常执行</p>
<p>T2在notify方法执行前获取监视器，因为T1已经释放监视器，可以顺利获取，执行notify方法后尝试唤醒一个等待线程，这里唤醒T1，唤醒后T1先重新获取监视器（<strong>这里需等待T1释放监视器</strong>），再继续执行</p>
<h4 id="挂起和继续执行"><a href="#挂起和继续执行" class="headerlink" title="挂起和继续执行"></a>挂起和继续执行</h4><p>不推荐使用</p>
<p>suspend()线程暂停，不会释放任何锁资源，直到resume()方法之后，线程才会继续</p>
<p>然而如果resume方法意外地发生在suspend之前，就永远不会释放了</p>
<p>推荐使用wait+notify代替suspend和resume</p>
<h4 id="等待线程结束和谦让"><a href="#等待线程结束和谦让" class="headerlink" title="等待线程结束和谦让"></a>等待线程结束和谦让</h4><p>join()，不加超时参数，表示无限等待，会一直阻塞当前线程，直到目标线程执行完毕</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinMain</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        AddThread at = <span class="keyword">new</span> AddThread();</span><br><span class="line">        at.start();</span><br><span class="line">        at.join();<span class="comment">//主线程等待AddThread执行完毕</span></span><br><span class="line">        System.out.println(i);<span class="comment">//输出100000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>join方法实现的核心代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(isAlive())&#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使得调用线程（主线程）在被调用线程对象上进行等待，被调用线程执行完毕后，会在退出前调用notifyAll()方法通知所有等待线程继续执行</p>
<p>所以，不要在Thread对象实例上使用类似wait()方法或者notify()方法，会影响系统api工作</p>
<p>yield()：让出CPU，而非结束执行，会继续竞争cpu</p>
<h4 id="volatile与JMM"><a href="#volatile与JMM" class="headerlink" title="volatile与JMM"></a>volatile与JMM</h4><h5 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h5><p>该变量极有可能会被某些程序或线程修改，修改后系统想办法通知给其他线程，保障数据可见性，同时保障操作原子性（有限保障），防止数据被写坏,如之前的long类型，可以通过添加volatile修饰保证不会被写坏</p>
<p>参考： <a target="_blank" rel="noopener" href="https://blog.csdn.net/u012723673/article/details/80682208">https://blog.csdn.net/u012723673/article/details/80682208</a> </p>
<p>但是，volatile并不能替代锁，<strong>无法保证一些复合操作的原子性</strong></p>
<p>如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PlusTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10000</span>; k++)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> PlusTask());</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            threads[i].join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理论上应该输出100000，但是结果总是比100000小</p>
<p>原因：主线程阻塞，10个子线程互相抢占时间片，i++这种复合操作首先读取i变量，此时被其他线程抢占修改i并写入主存，在回来的时候i还是未修改的状态，导致两次修改相当于一次的</p>
<p>可以通过加synchronized同步锁，保证i++操作时阻塞其他线程，保障原子性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PlusTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10000</span>; k++)&#123;</span><br><span class="line">                increase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> PlusTask());</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            threads[i].join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但volatile可以保证数据的可见性和有序性</p>
<p>可见性在server模式下不可行</p>
<h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><p>线程很多，功能分配明确，可以将相同功能的线程放在一个线程组里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroupName</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ThreadGroup tg = <span class="keyword">new</span> ThreadGroup(<span class="string">&quot;PrintGroup&quot;</span>);<span class="comment">//创建名为PrintGroup的线程组</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(tg, <span class="keyword">new</span> ThreadGroupName(), <span class="string">&quot;T1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(tg, <span class="keyword">new</span> ThreadGroupName(), <span class="string">&quot;T2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        System.out.println(tg.activeCount());<span class="comment">//获得活动线程总数</span></span><br><span class="line">        tg.list();<span class="comment">//打印线程组所有线程信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String groupAndName = Thread.currentThread().getThreadGroup().getName()</span><br><span class="line">            + <span class="string">&quot;-&quot;</span> + Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I am &quot;</span> + groupAndName);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>stop()可以停止线程组中所有线程</p>
<h3 id="守护线程-Daemon"><a href="#守护线程-Daemon" class="headerlink" title="守护线程  Daemon"></a>守护线程  Daemon</h3><p>在后台默默地完成一些系统性任务：垃圾回收、JIT等</p>
<p>用户线程：工作线程，即完成程序应该要完成的业务操作，守护线程守护工作线程执行</p>
<p><strong>一个Java应用内只有守护线程，Java虚拟机就会自然退出</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonT</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;    </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;I am alive&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		Thread t = <span class="keyword">new</span> DaemonT();</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        </span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>必须start之前设置为守护线程</strong></p>
<p>这里只有主线程main为用户线程，2秒后主线程退出时，整个程序也随之结束</p>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>java内置三个静态变量表示线程优先级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">high.setPriority(MAX_PRIORITY);</span><br><span class="line">low.setPriority(MIN_PRIORITY);</span><br></pre></td></tr></table></figure>

<p>高优先级在大部分情况，都会首先完成任务，但也不一定</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>上文volatile模块提到的i++复合操作是线程不安全的</p>
<p>当线程A写入时，B不仅不能写，同时也不能读，A写完之前，B读取的一定是过期数据</p>
<p>synchronized实现线程间的同步，对同步的代码加锁，使得每一次只能有一个线程进入同步块</p>
<p>用法：</p>
<ul>
<li>指定加锁对象：对给定对象加锁，进入同步代码前要获得给定对象的锁</li>
<li>直接作用于实例方法：对当前实例加锁，进入同步代码前要获得当前实例的锁</li>
<li>直接作用于静态方法：对当前类加锁，进入同步代码前要获得当前类的锁</li>
</ul>
<p>上文synchronize代码也可以写成如下形式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountingSync</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AccountingSync instance = <span class="keyword">new</span> AccountingSync();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100000000</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(instance)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即直接对实例对象加锁，也可以单独封装i++为一个方法，单独给方法加锁</p>
<p>注意：<strong>两个线程操作的是一个实例，这样才能操作一个锁</strong></p>
<p>如果是以下情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AccountingSyncBad());</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AccountingSyncBad());</span><br></pre></td></tr></table></figure>

<p>两个线程指向不同实例，两个线程使用两把不同的锁</p>
<p>但如果将i++封装到静态方法里面然后run方法调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样两个实例执行的仍然是同一个类的静态方法，线程间仍然可以同步</p>
<h3 id="隐蔽的错误"><a href="#隐蔽的错误" class="headerlink" title="隐蔽的错误"></a>隐蔽的错误</h3><h4 id="无提示错误案例"><a href="#无提示错误案例" class="headerlink" title="无提示错误案例"></a>无提示错误案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v1=<span class="number">1073741827</span>;</span><br><span class="line"><span class="keyword">int</span> v2=<span class="number">1431655768</span>;</span><br><span class="line"><span class="keyword">int</span> ave=(v1+v2)/<span class="number">2</span>;<span class="comment">//输出-894784850</span></span><br></pre></td></tr></table></figure>

<p>v1加v2出现一个负数，</p>
<p>在一个复杂系统内部出现该问题，也无任何日志报错，导致问题难以解决</p>
<h4 id="并发下ArrayList"><a href="#并发下ArrayList" class="headerlink" title="并发下ArrayList"></a>并发下ArrayList</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Integer&gt; al = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2000000</span>; j++)&#123;</span><br><span class="line">            al.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread());</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">        System.out.println(al.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>t1和t2同时向一个ArrayList中添加容器，可能会得到三种结果</p>
<p>1.正常结束</p>
<p>2.抛出异常（ArrayIndexOutOfBound）</p>
<p>原因：扩容过程中，内部一致性遭到破坏，由于没有锁保护，另一个线程访问到了不一致的内部状态，导致越界</p>
<p>3.隐蔽错误，打印ArrayList大小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1793758</span></span><br></pre></td></tr></table></figure>

<p>由于多线程访问冲突，两个线程对ArrayList同一位置赋值导致</p>
<p>改进方法：<strong>用线程安全的Vector替代ArrayList</strong></p>
<h4 id="并发下HashMap"><a href="#并发下HashMap" class="headerlink" title="并发下HashMap"></a>并发下HashMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapMultiThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AddThread</span><span class="params">(<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; <span class="number">100000</span>; i += <span class="number">2</span>)&#123;</span><br><span class="line">                map.put(Integer.toString(i), Integer.toBinaryString(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> HashMapMultiThread.AddThread(<span class="number">0</span>));</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> HashMapMultiThread.AddThread(<span class="number">1</span>));</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">        System.out.println(map.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三种结果</p>
<ol>
<li>HashMap大小为100000</li>
<li>小于100000</li>
<li><strong>程序无法结束！！</strong></li>
</ol>
<p>原因：HashMap执行put方法的时候，可能会对HashMap进行扩容操作，扩容操作有一步为transfer方法，类似链表操作（Entry），transfer会改变每个元素的next指针，而且使同一hash值的链表元素逆序，两个线程扩容时调用两次transfer方法，导致第一个线程改变next，另一个线程通过该next遍历同一hash值的元素，结果是形成一个闭环结构！！两个key值互为对方的next，导致陷入死循环</p>
<p>解决方法：JDK8不会存在扩容时出现死循环但仍然线程不安全，建议使用ConcurrentHashMap代替HashMap</p>
<h3 id="错误的加锁"><a href="#错误的加锁" class="headerlink" title="错误的加锁"></a>错误的加锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BadLockOnInteger</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> BadLockOnInteger instance = <span class="keyword">new</span> BadLockOnInteger();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(i)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> THread(instance);</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使加锁，i值也比20000000要小 </p>
<p>原因：Integer不会被修改，而是new一个新的Integer让i重新指向</p>
<p><strong>因为Integer一直在变，导致synchronized加锁的对象一直在变，而不是自增一个特定的对象</strong></p>
<p>解决方法：加锁对象实例，等一个线程操作完实例的一次i++后，让出锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(instance)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-30T03:11:47.000Z" title="2021-3-30 11:11:47 ├F10: AM┤">2021-03-30</time>发表</span><span class="level-item"><time dateTime="2021-03-31T03:46:07.697Z" title="2021-3-31 11:46:07 ├F10: AM┤">2021-03-31</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span><span class="level-item">9 分钟读完 (大约1365个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/30/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A11/">Java高并发程序设计1</a></h1><div class="content"><h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><p>形容一次方法调用    </p>
<p>同步方法调用一旦开始，调用者必须等待方法调用返回后，才能继续后续的行为</p>
<p>异步方法更像是一个消息传递，一旦开始，方法调用就会立即返回，调用者继续后续工作，而异步方法通常会在<strong>另一个线程</strong>“真实地”执行。如果需要，异步调用真实完成时，会通知调用者</p>
<h4 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h4><p>多个任务一起执行</p>
<p>并行：多个任务同时执行</p>
<p>并发：多个任务<strong>交替</strong>执行，串行执行</p>
<h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>一种公共资源或者共享数据，可以被多个线程使用</p>
<p>但一次只能被一个线程使用，一旦临界区资源被占用，其他线程想要使用的话必须等待</p>
<h4 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h4><p>形容多线程之间的相互影响</p>
<p>阻塞：一个线程占用了临界区资源，其他需要该资源的线程就必须在临界区中等待，等待导致线程被挂起</p>
<p>非阻塞：没有线程可以妨碍其他线程执行，所有线程都会不断尝试前向执行</p>
<h4 id="死锁、饥饿和活锁"><a href="#死锁、饥饿和活锁" class="headerlink" title="死锁、饥饿和活锁"></a>死锁、饥饿和活锁</h4><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>线程需要的资源是另一个线程占用的资源，两两之间形成一个闭环，导致永远无法解除阻塞状态</p>
<h5 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h5><p>线程无法获得所需要的资源，导致一直无法执行</p>
<p>可能因为线程优先级太低导致高优先级线程一直抢占它需要的资源</p>
<h5 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h5><p>两个线程都主动将资源释放给对方，导致资源在两线程间跳动，没有一个线程同时拿到所有资源正常执行</p>
<h3 id="并发级别"><a href="#并发级别" class="headerlink" title="并发级别"></a>并发级别</h3><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>synchronized或重入锁，得到阻塞线程</p>
<p>试图执行后续代码前，得到临界区的锁，得不到的话线程就会被挂起等待</p>
<h4 id="无饥饿"><a href="#无饥饿" class="headerlink" title="无饥饿"></a>无饥饿</h4><p>非公平锁：存在优先级高低的线程，导致可能出现饥饿现象</p>
<p>公平锁：先来后到</p>
<h4 id="无障碍"><a href="#无障碍" class="headerlink" title="无障碍"></a>无障碍</h4><p>多线程一起修改临界区数据，如果数据改坏了会导致回滚</p>
<p>悲观策略：经常冲突，保护共享数据</p>
<p>乐观策略：一般不会冲突，遇到则回滚</p>
<p>但严重冲突导致线程不断回滚自己操作，会影响正常执行。希望至少有一个线程在有限时间完成操作后退出临界区</p>
<p><strong>“一致性标记”</strong>：操作前读取，操作完成后再读取，检查标记是否被更改。如果两者一致，说明无冲突，如果不一致，则资源可能在操作过程中与其它写线程冲突，需要重试。任何对资源有修改操作的线程，在修改前都需要更新一致性标记，表示数据不再安全</p>
<h4 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h4><p>无障碍，且保证有一个线程在<strong>有限步内</strong>完成操作离开临界区</p>
<p>特点：无穷循环，尝试修改共享变量，可能会有饥饿问题</p>
<h4 id="无等待"><a href="#无等待" class="headerlink" title="无等待"></a>无等待</h4><p>无锁，每个线程都必须在<strong>有限步</strong>内完成</p>
<p>特点：RCU（Read Copy Update），不控制读操作，写数据时先取得原始数据的副本，修改副本数据，在合适时机回写数据</p>
<p><strong>Amadahl定律</strong></p>
<p>加速比由以下公式求出<br>$$<br>T_n = T_1(F + \frac{1}{n}(1-F))<br>$$</p>
<p>$T_n$表示n个处理器优化后的耗时</p>
<p>$T_1$表示优化前耗时</p>
<p>$F$表示程序中只能串行执行的比例</p>
<p>所以加速比<br>$$<br>加速比=\frac{1}{F+\frac{1}{n}(1-F)}<br>$$<br>结论：提高系统速度不能仅仅增加CPU处理器数量，还要根本上修改程序的串行行为，提高系统内可并行化模块比重    </p>
<p><strong>Gustafson定律</strong><br>$$<br>加速比=n-F(n-1)<br>$$<br>结论：只要不断累加处理器，就能获得更快的速度</p>
<h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><p>Java内存模型</p>
<p>保证多个线程之间可以有效地、正确地协同工作</p>
<p>JMM特点：</p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>指一个不可中断的操作。一个操作一旦开始，就不会被其他线程干扰</p>
<p>int读写原子性，long不是</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>当一个线程修改了某个共享变量的值，其他线程是否能够立即知道这个修改</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>并发时，程序的执行可能出现乱序</p>
<p>原因：可能发生指令重排（指令重排用于减少中断，提升CPU性能）</p>
<h3 id="哪些指令不能重排：Happen-Before规则"><a href="#哪些指令不能重排：Happen-Before规则" class="headerlink" title="哪些指令不能重排：Happen-Before规则"></a>哪些指令不能重排：Happen-Before规则</h3><p>程序顺序原则：语义串行</p>
<p>volatile原则：volatile变量的写先于读发生</p>
<p>锁原则：解锁必然发生随后的加锁前</p>
<p>传递性：A先于B，B先于C，那么A必然先于C</p>
<p>线程的start()方法先于它的每一个动作</p>
<p>线程所有操作先于线程终结</p>
<p>线程的中断(interrupt())先于被中断线程的代码</p>
<p>对象构造函数的执行、结束先于finalize()方法</p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="ParadoX"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">ParadoX</p><p class="is-size-6 is-block">Paradox的IT小屋</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>青岛，中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">11</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">12</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/lrj1996123" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/lrj1996123"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/leetcode/"><span class="level-start"><span class="level-item">leetcode</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/web%E5%89%8D%E7%AB%AF/"><span class="level-start"><span class="level-item">web前端</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">读书笔记</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%9D%A2%E8%AF%95/"><span class="level-start"><span class="level-item">面试</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/JS/"><span class="tag">JS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/REACT/"><span class="tag">REACT</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Trie%E6%A0%91/"><span class="tag">Trie树</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VUE/"><span class="tag">VUE</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/"><span class="tag">《深入理解Java虚拟机》</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E3%80%8A%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"><span class="tag">《高并发程序设计》</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"><span class="tag">二分查找</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="tag">动态规划</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"><span class="tag">状态压缩</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E8%AF%95/"><span class="tag">面试</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-08T02:25:16.000Z">2021-04-08</time></p><p class="title"><a href="/2021/04/08/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13-2/">Java高并发程序设计3-2</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-07T03:09:10.000Z">2021-04-07</time></p><p class="title"><a href="/2021/04/07/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/">Java高并发程序设计3</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-31T03:46:29.000Z">2021-03-31</time></p><p class="title"><a href="/2021/03/31/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/">Java高并发程序设计2</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-30T03:11:47.000Z">2021-03-30</time></p><p class="title"><a href="/2021/03/30/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A11/">Java高并发程序设计1</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-25T14:19:57.000Z">2021-03-25</time></p><p class="title"><a href="/2021/03/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA2/">深入理解Java虚拟机2</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a><p class="is-size-7"><span>&copy; 2021 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>