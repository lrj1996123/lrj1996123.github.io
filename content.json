{"pages":[{"title":"文章分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/03/01/hello-world/"},{"title":"算法分析1.猜字谜","text":"原题外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。 字谜的迷面 puzzle 按字符串形式给出，如果一个单词 word 符合下面两个条件，那么它就可以算作谜底： 单词 word 中包含谜面 puzzle 的第一个字母。 单词 word 中的每一个字母都可以在谜面 puzzle 中找到。 例如，如果字谜的谜面是 “abcdefg“，那么可以作为谜底的单词有 “faced“, “cabbage“, 和 “baggage“；而 “beefed“（不含字母 “a”）以及 “based“（其中的 “s” 没有出现在谜面中）都不能作为谜底。 返回一个答案数组 answer，数组中的每个元素 answer[i] 是在给出的单词列表 words 中可以作为字谜迷面 puzzles[i] 所对应的谜底的单词数目。 示例1234567891011输入：words = [&quot;aaaa&quot;,&quot;asas&quot;,&quot;able&quot;,&quot;ability&quot;,&quot;actt&quot;,&quot;actor&quot;,&quot;access&quot;], puzzles = [&quot;aboveyz&quot;,&quot;abrodyz&quot;,&quot;abslute&quot;,&quot;absoryz&quot;,&quot;actresz&quot;,&quot;gaswxyz&quot;]输出：[1,1,3,2,4,0]解释：1 个单词可以作为 &quot;aboveyz&quot; 的谜底 : &quot;aaaa&quot; 1 个单词可以作为 &quot;abrodyz&quot; 的谜底 : &quot;aaaa&quot;3 个单词可以作为 &quot;abslute&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;, &quot;able&quot;2 个单词可以作为 &quot;absoryz&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;4 个单词可以作为 &quot;actresz&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;, &quot;actt&quot;, &quot;access&quot;没有单词可以作为 &quot;gaswxyz&quot; 的谜底，因为列表中的单词都不含字母 'g'。 提示1234561 &lt;= words.length &lt;= 10^54 &lt;= words[i].length &lt;= 501 &lt;= puzzles.length &lt;= 10^4puzzles[i].length == 7words[i][j], puzzles[i][j] 都是小写英文字母。每个 puzzles[i] 所包含的字符都不重复。 分析 word和puzzle均为小写字母，即由a~z26个字母组成 每个puzzle长度为7，所包含字符不重复 输出为每个puzzle对应的谜底word个数 要求puzzle含有word中每一个字母，且其中一个为puzzle首字母 类似题型总结：字符串子集的匹配，不重复字符的子集，字符限制为小写或大写 方法一、二进制状态压缩由于words中的word含有重复字母，根据题意不考虑字母的个数，只判断字母的存在性，以此选择合适的表示方法 由于word中只包含小写英文字母a到z，所以word通过26位二进制来表示，0表示不存在，1表示存在 由于只利用的字母的存在性，可能有多个word的二进制表示是相同的，这里通过map来表示每种word的二进制表示的出现次数 题目中要求输出每个puzzle（7位）所匹配的word个数，对puzzle的二进制表示，所以枚举每个puzzle的子集，特别地，该子集一定包含puzzle首字母，关于枚举这里有两个思路： 思路一：枚举6位二进制数来选择puzzle16位所有的字母组合，以此遍历每个puzzle16位的子集，特别地，每次遍历都要加上puzzle第0位（题目要求word中必须有puzzle第0位的字母），代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution { public List&lt;Integer&gt; findNumOfValidWords(String[] words, String[] puzzles) { Map&lt;Integer, Integer&gt; fre = new HashMap&lt;&gt;(); // word的二进制表示 for(String word: words){ int mask = 0; for(int i = 0; i &lt; word.length(); i++){ mask |= 1 &lt;&lt; (word.charAt(i) - 'a'); } if(Integer.bitCount(mask) &lt;= 7){ fre.put(mask, fre.getOrDefault(mask, 0) + 1); } } List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for(String puzzle: puzzles){ int total = 0; // 从000000到111111表示puzzle所有子集的组合形式，遍历这些子集 // (puzzle第1位到第6位的子集，忽略第0位) for(int choose = 0; choose &lt; (1 &lt;&lt; 6); choose++){ int mask = 0; for(int i = 0; i &lt; 6; i++){ // choose表示puzzle子集的一种组合形式，通过&amp;操作来选取数字1对应的单词，0则忽略 if( (choose &amp; (1 &lt;&lt; i)) != 0 ){ mask |= 1 &lt;&lt; (puzzle.charAt(i + 1) - 'a'); } } // 要求谜底word中一定包含puzzle首字母，所以这里单独处理 mask |= 1 &lt;&lt; (puzzle.charAt(0) - 'a'); // 如果puzzle的子集（包含首字母）是谜底word，则将所有该形式加入 if(fre.containsKey(mask)){ total += fre.get(mask); } } ans.add(total); } return ans; }} 思路二：通过的位运算方法来枚举puzzle所有子集，对于puzzle1~6位的二进制表示mask，对subset初始化赋值mask，然后每次迭代进行如下操作： 1subset = (subset - 1) &amp; mask 由于subset中的1之间可能存在0，即不存在的字母和puzzle首位字母，所以对subset-1进行操作时，对subset-1和mask做“与”运算，保证不存在的字母永远不存在，实现了去冗，不断地减1使得subset中的1再次消失或再次出现，且保证subset越来越小，所以巧妙地遍历出所有子集 123456789101112131415161718192021222324252627282930313233 class Solution { public List&lt;Integer&gt; findNumOfValidWords(String[] words, String[] puzzles) { Map&lt;Integer, Integer&gt; fre = new HashMap&lt;&gt;(); for(String word: words){ int mask = 0; for(int i = 0; i &lt; word.length(); i++){ mask |= 1 &lt;&lt; (word.charAt(i) - 'a'); } if(Integer.bitCount(mask) &lt;= 7){ fre.put(mask, fre.getOrDefault(mask, 0) + 1); } } List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for(String puzzle: puzzles){ int total = 0; int mask = 0; //对需要枚举的后六位进行二进制表示 for(int i = 1; i &lt; 7; i++){ mask |= 1 &lt;&lt; (puzzle.charAt(i) - 'a'); } int subset = mask; do{ int s = subset | 1 &lt;&lt; (puzzle.charAt(0) - 'a');//枚举操作和-1操作时只需要固定第0位，所以这里进行单独运算 if(fre.containsKey(s)){ total += fre.get(s); } subset = (subset - 1) &amp; mask; }while(subset != mask);//subset为0时，-1代表所有位都为1，和mask“与”运算的结果必然与mask相等 ans.add(total); } return ans; }} 二、Trie树+回溯word中重复字母不考虑，puzzle无重复字母+遍历子集，所以可以采用Trie树方法将words所有单词保存，在每个单词最后一个字母处保存含有相同字母存在的单词个数 接着，遍历puzzles，对每个puzzle，我们需要通过Trie树查找该puzzle的子集，遍历子集的方式采用回溯法，分别考虑当前位置单词和忽略当前位置的下一个单词，特别注意的是，首字母不能忽略 以上对Trie树的操作之前，首先要对word和puzzle进行排序，特别地，puzzle首字母要额外保存 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution { public List&lt;Integer&gt; findNumOfValidWords(String[] words, String[] puzzles) { TrieNode trieNode = new TrieNode(); //word去重并添加入树 for(String word: words){ char[] arr = word.toCharArray(); Arrays.sort(arr); StringBuffer sb = new StringBuffer(); for(int i = 0; i &lt; arr.length; i++){ if(i == 0 || arr[i] != arr[i - 1]){ sb.append(arr[i]); } } add(trieNode, sb.toString()); } List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for(String puzzle: puzzles){ char[] arr = puzzle.toCharArray(); //required表示puzzle的首字母，所以在排序前额外保留 char required = arr[0]; Arrays.sort(arr); ans.add(find(trieNode, required, new String(arr) ,0)); } return ans; } public void add(TrieNode root, String str){ for(int i = 0; i &lt; str.length(); i++){ if(root.child[str.charAt(i) - 'a'] == null){ root.child[str.charAt(i) - 'a'] = new TrieNode(); } root = root.child[str.charAt(i) - 'a']; } root.fre++; } public int find(TrieNode cur, char required, String puzzle, int pos){ if(cur == null){ return 0; } //cur!=null且pos==7的位置，包含puzzle所有子集的情况，cur.fre==0表示当前cur并非叶子结点 if(pos == 7){ return cur.fre; } int ret = find(cur.child[puzzle.charAt(pos) - 'a'], required, puzzle, pos + 1); //如果不是首字母，则额外考虑忽略pos位置字母的情况，不忽略与忽略两种情况相加 if(puzzle.charAt(pos) != required){ ret += find(cur, required, puzzle,pos + 1); } return ret; }}","link":"/2021/03/02/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%901-%E7%8C%9C%E5%AD%97%E8%B0%9C/"},{"title":"算法分析2.俄罗斯套娃信封问题","text":"原题给定二维数组envelopes，其中**envelopes[i] = [$w_i$,$h_i$]**，表示第i个信封的宽度和高度 要求：另一个信封的宽高都比这个信封大，这个信封就可以放进另一个信封里面，如同俄罗斯套娃，接连地一个套一个 计算最多能有多少个信封能组成一组“俄罗斯套娃信封序列” 注意：不允许旋转信封 示例123输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]输出：3解释：最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。 提示1231 &lt;= envelopes.length &lt;= 5000envelopes[i].length == 21 &lt;= wi, hi &lt;= 104 分析 不允许旋转信封，即i套j的条件：$w_i &gt; w_j$ &amp;&amp; $h_i &gt; h_j$ 因为需要分别对w和h进行排序，这里选择先对w升序排序 w已排好序，所以只需要通过判断h大小来进行套娃。但是，如果h也是升序排序，那么会导致同一大小的w中选择多个信封，然而只能从w相同的信封中选择一封 1排完序的结果为[(w,h)]=[(1,1),(1,2),(1,3),(1,4)]，由于这些信封的w值都相同，不存在一个信封可以装下另一个信封，那么我们只能在其中选择 11 个信封。然而如果我们完全忽略w维度，剩下的h维度为[1,2,3,4]，这是一个严格递增的序列，那么我们就可以选择所有的4个信封了，这就产生了错误。 对于w相同的信封只能从中选择一封，通过贪心策略得出，优先选择h小的，才能保证能有更多信封可以套它 方法一、 动态规划将信封的w按照从小到大排序，然后w相同的信封的h按照从大到小排序，这样可以保证对于相同w的信封只能选择其中一封 设f[i]为0~i的最长严格递增子序列的长度， 要求最后的选择为第i个信封，则倒数第二个选择的信封为$j$($j\\lt i$)，遍历j，此时f[j]是已知的，所以如果第j个信封能够套入第i个信封，则0~i的最长递增子序列则为所有f[j]+1当中的最大值 由此得到状态转移公式$$f[i] = \\max\\limits_{j&lt;i \\wedge d_j&lt;d_i}{f[j] + 1}$$得到代码 12345678910111213141516171819202122232425262728293031class Solution { public int maxEnvelopes(int[][] envelopes) { if (envelopes.length == 0) { return 0; } int n = envelopes.length; Arrays.sort(envelopes, new Comparator&lt;int[]&gt;() { public int compare(int[] e1, int[] e2) { if (e1[0] != e2[0]) { return e1[0] - e2[0];//w从小到大排序 } else { return e2[1] - e1[1];//h从大到小排序 } } }); int[] f = new int[n];//f[i]表示0~i可以组成的最大严格递增子序列，且必须选择第i个信封 Arrays.fill(f, 1); int ans = 1; for (int i = 1; i &lt; n; ++i) {//选择第i个元素为最后一个所选择的信封 for (int j = 0; j &lt; i; ++j) {//选择第j个元素为倒数第二个选择的信封 if (envelopes[j][1] &lt; envelopes[i][1]) { f[i] = Math.max(f[i], f[j] + 1);//这里f[i]初始化为1(第i个元素本身)，然后从所有f[j]+1中选择最大值 } } ans = Math.max(ans, f[i]);//所有f当中的最大值即为答案 } return ans; }} 二、 二分查找+贪心算法设f[j]为前i个元素可以组成的最长长度为j的严格递增子序列的末尾元素的h的最小值 贪心思路：让序列上升得尽可能慢 f的性质： f值是严格单调递增的，因为越长的子序列末尾元素显然越大 证明：假设$f[j]\\ge f[i]$且$j\\lt i$ ，从长度为$i$的最长上升子序列末尾删除$i-j$个元素，那么这个序列长度变为j，末尾元素一定比i小，所以$f[j]’\\lt f[i] \\lt f[j] $ 但是f[j]是长度为j的递增子序列的最小值，所以矛盾 末尾元素是可以放的最小值 例如序列[1,2,3,6,4,5]中，1236和1234两个相同长度序列，只有f[3] = 4的时候，序列才可以变得更长 状态转移方法： 考虑当前元素$h_{i}$ $h_i$大于f中的最大值，那么$h_i$就可以接在f最大值之后 否则，从f中比$h_{i}$ 严格小的最大元素$f[j_{0}]$，得到$f[j_{0}]\\lt h_{i} \\lt f[j_{0} + 1]$ ,那么$h_{i} $就可以替换$f[j_{0}+1]$ 可以通过二分查找，找出满足要求的$j_{0}$ 最终f的长度即为最长严格递增子序列的长度 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution { public int maxEnvelopes(int[][] envelopes) { if (envelopes.length == 0) { return 0; } int n = envelopes.length; Arrays.sort(envelopes, new Comparator&lt;int[]&gt;() { public int compare(int[] e1, int[] e2) { if (e1[0] != e2[0]) { return e1[0] - e2[0]; } else { return e2[1] - e1[1]; } } }); List&lt;Integer&gt; f = new ArrayList&lt;Integer&gt;(); f.add(envelopes[0][1]); //主要贪心策略 for (int i = 1; i &lt; n; ++i) { int num = envelopes[i][1]; if (num &gt; f.get(f.size() - 1)) { f.add(num); } else { int index = binarySearch(f, num); f.set(index, num); } } return f.size(); } //二分查找，找到第一个大于target的元素的位置 public int binarySearch(List&lt;Integer&gt; f, int target) { int low = 0, high = f.size() - 1; while (low &lt; high) { int mid = (high - low) / 2 + low; if (f.get(mid) &lt; target) { low = mid + 1; } else { high = mid; } } return low; }} 其他：二分查找变种一、二分查找寻找一个数（基本）123456789101112131415int binarySearch(int[] nums, int target) { int left = 0; int right = nums.length - 1; // 注意，搜索空间为[left,right]的闭区间 while(left &lt;= right) { // 注意，left&gt;right表示搜索空间消失 int mid = (right + left) / 2; if(nums[mid] == target) return mid; else if (nums[mid] &lt; target) left = mid + 1; // 注意，搜索空间变为[mid+1,right] else if (nums[mid] &gt; target) right = mid - 1; // 注意，同上 } return -1;} 二、二分查找寻找左侧边界（最左侧target下标）1234567891011121314151617int left_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0; int right = nums.length; // 注意,搜索空间为[left,right)的左闭右开区间 while (left &lt; right) { // 注意,终止条件为left==right,即[left,left) int mid = (left + right) / 2; if (nums[mid] == target) { right = mid;//nums[mid]虽然等于target，但我们依然要在[left,mid)中搜索来锁定左侧边界 } else if (nums[mid] &lt; target) { left = mid + 1; } else if (nums[mid] &gt; target) { right = mid; // 注意，因为搜索空间是左闭右开，下一步搜索空间应该去掉mid即[left,mid)和[mid+1,right) } } return left;} 三、 二分查找寻找右侧边界（最右侧target下标）123456789101112131415int right_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0, right = nums.length; while (left &lt; right) { int mid = (left + right) / 2; if (nums[mid] == target) { left = mid + 1; // 注意，找到相等元素不要立刻返回，而是继续向右寻找[mid+1,right) } else if (nums[mid] &lt; target) { left = mid + 1; } else if (nums[mid] &gt; target) { right = mid; } } return left - 1; // 注意因为left=mid+1，所以最终left位置不等于target，所以left-1","link":"/2021/03/08/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%902-%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98/"},{"title":"JAVA实习面试经验1.阿里CBU简历评估","text":"问题汇总1.自我介绍 2.项目介绍 做过什么项目？。。。 在团队当中充当了什么角色？后端 遇到了什么困难？数据库设计、业务逻辑设计方面 参考其他什么项目？之前公司的项目 自己在设计方面发挥亮眼的地方……..这里需要 通过E-R图介绍自己项目的数据之间的关系等 Springboot和Spring相比的优势 古德拜 总结复习到的基础知识都没有问0.0 注重项目经验，一定要理清楚项目数据库中的各种设计 分析自己在项目之中发挥的作用，解决的难题 新技术的运用，想办法扯进去一点 后续工作阅读《深入浅出JVM虚拟机》并做笔记 学习spring cloud和kafka","link":"/2021/03/15/JAVA%E9%9D%A2%E8%AF%951/"},{"title":"文献阅读1.《Attention-based LSTM for Aspect-level Sentiment Classification》","text":"","link":"/2021/03/16/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB1-%E3%80%8AAttention-based-LSTM-for-Aspect-level-Sentiment-Classification%E3%80%8B/"},{"title":"深入理解Java虚拟机1","text":"Java内存区域与内存溢出异常Java虚拟机自动内存管理机制，不需要为每个new操作去写配对的delete/free，不容易出现内存泄漏和内存溢出问题。 但是，控制内存的权利交给了Java虚拟机，一旦出现内存泄漏和内存溢出问题，排查错误并修正将会异常艰难。 运行时数据区域程序计数器当前线程所执行字节码的行号指示器：字节码解释器通过改变计数器的值来选取下一条需要执行的字节码指令 程序控制流的指示器：分支、循环、跳转、异常处理、线程恢复等都依赖该计数器 多线程：线程轮流切换，分配处理器执行时间，任何一个确定时刻，一个处理器内核只会执行一条线程中的指令 线程私有：切换线程时，为了能够回到正确位置，每条线程都需要有个独立的程序计数器 虚拟机栈线程私有：生命周期和线程相同 Java方法执行的线程内存模型：方法被执行，Java虚拟机同步创建一个栈帧 JVM创建的栈帧：存储局部变量表、操作数栈、动态连接、方法出口等信息， 每一个方法被调用到执行完毕 &lt;——&gt; 一个栈帧从虚拟机栈入栈到出栈 局部变量表：“栈”存放JVM基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它并不等同于对象本身，而是一个指向对象起始位置的引用指针，也可能指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址） 局部变量槽（Slot）：存储这些数据类型，除了long和double占用2个，其余占用1个 局部变量空间确定：进入一个方法时，局部变量空间大小（变量槽的数量）确定 内存区域异常： StackOverflow异常：线程请求的深度大于虚拟机允许的深度 OutOfMemoryError异常：栈可以动态扩展的虚拟机（Hotspot不会）扩展时无法申请到足够内存会抛出OutOfMemoryError异常 本地方法栈类似虚拟机栈，但本地方法栈为JVM用到的本地方法服务 异常和虚拟机栈类似 Java堆JVM内存最大的一块 所有线程共享 存放对象实例和数组（几乎所有，但不一定，逃逸分析技术、栈上分配、标量替换优化手段导致一些微妙变化） 垃圾回收器管理Java堆（GC堆） 线程私有的分配缓冲区（TLAB）：提升对象分配效率,目的只是更好回收内存，更快分配内存 物理上不连续，逻辑上连续，但大对象可能要求连续 可扩展可固定大小：主流可扩展，没有完成实例分配，堆无法再扩展时，会抛出OutOfMemoryError异常 方法区线程共享 存储JVM加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。 本地空间实现元空间来代替永久代 不需连续内存，可选择固定大小或可扩展，甚至可以选择不实现垃圾收集 回收效果不好，尤其是类型的卸载，但有时又很有必要 OutOfMemoryError 运行时常量池常量池表：编译期生成的各种字面量与符号引用，类加载后存放到方法区的运行时常量池中。 动态性：常量不一定只有编译期才能产生，String intern() OutOfMemoryError 直接内存通道+缓冲区直接操作Native函数库分配堆外内存，通过DirectByteBuffer对象作为这块内存的引用，从而提高性能 HotSpot虚拟机HotSpot虚拟机Java堆中对象的创建检测到字节码new指令 检查new指令的参数能否在常量池中定位到一个类的符号引用 检查该符号引用代表的类是否已被加载，否则必须先执行类加载 类加载检查通过后，虚拟机为新生对象分配内存。（类加载后对象所需内存大小即可完全确定） 给对象分配内存=把一块确定大小的内存从Java堆中划分出来 指针碰撞：假设所有被使用过的内存都放到一边，空闲内存放另一边，指针指向中间的分界点，内存分配就是向空闲内存一边挪动与新生对象大小相等的距离 空闲列表：已被使用的内存和空闲的内存相互交错在一起，虚拟机必须维护一个列表，记录哪些内存块可用，分配时在列表中找一块足够大的空间给对象实例，并更新表上的记录 如何选择分配内存方式？——Java堆是否规整决定 是否规整？——gc是否带有空间压缩整理的能力决定，例如Serail、ParNew能指针碰撞，而CMS基于清除算法，理论上只能空闲列表 对象创建频繁，并发时线程不安全 解决方案： 1.同步处理分配内存空间的动作，采用CAS配上失败重试 2.内存分配的动作按照线程划分在不从空间中进行，即每个线程在Java堆中预先分配一小块内存（本地线程分配缓冲 TLAB），优先使用线程自己的本地缓冲区，只有用完了，分配新缓冲区时才需要同步锁定. 内存分配完成后，分配到的内存空间初始化为0值（不包括对象头），也可TLAB分配之前就初始化，保证可以直接使用这些对象 然后，JVM对对象进行必要设置：哪个类的实例、如何找到元数据信息、对象的哈希码（实际上调用hashCode时才计算）、对象GC分代年龄等信息。这些信息存放在对象头中 对象头设置方式不同：由JVM当前运行状态决定 对象诞生了 但是Java程序的视角，对象创建刚开始——构造函数，new指令跟随invokespecial指令，随后按照程序员的意愿初始化，才将对象创建完毕 对象的内存布局三部分：对象头、实例数据、对齐填充 对象头MarkWord：存储对象自身运行时数据，头信息是与对象自身定义的数据无关的额外存储成本，一个动态定义的数据结构 存储内容 标志位 状态 对象哈希码（25）、对象分代年龄（4） 01 未锁定 指向锁记录的指针（1） 00 轻量级锁定 指向重量级锁的指针（1） 10 膨胀（重量级锁定） 空，不需要记录信息（1） 11 GC标记 偏向线程ID、偏向时间戳、对象分代年龄 01 可偏向 类型指针：指向类型元数据的指针，确定是哪个类的实例。对象数据上不一定保留类型指针。如果是Java数组，对象头还要有一块记录数组长度的数据 实例数据信息 程序代码里面定义的各种类型的字段内容 存储顺序会受分配策略参数和定义顺序影响 默认分配顺序：longs/doubles、ints、shorts/chars、bytes/booleans、oops 相同宽度的字段一起存放 父类定义的变量在子类之前 对齐填充 占位符，HotSpot要求对象起始地址是8字节整数倍 即任何对象大小是8字节整数倍 对象的访问定位reference数据：在栈上，来操作堆上的具体对象 如何定位访问堆中对象具体位置： 1.句柄访问，Java堆中多出一块句柄池，reference存储对象的句柄地址，而句柄包含对象实例数据地址和类型数据的地址信息 2.直接指针访问，reference存储的直接就是对象地址，而需要考虑Java堆中对象的内存布局 句柄的好处：对象被移动时只会改变句柄中的实例数据指针，而不需要修改reference指针 直接指针好处：速度快，HotSpot使用这种，使用Shenandoah手机也会有一次额外转发","link":"/2021/03/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA1/"},{"title":"深入理解Java虚拟机2","text":"垃圾收集器与内存分配策略线程共享区域：Java堆和方法区内存分配和回收不确定性 接口多个实现类，方法执行不同的条件分支，所占用的内存都可能不一样 这些部分内存的分配和回收是动态的，只有处于运行期间才知道 判定对象是否存活引用计数算法简介：对象添加一个引用计数器，每有一个地方引用，计数器加一；引用失效，计数器减一。任何时刻计数器为零的对象就是不能被再使用的 Java没有采用 问题：很多例外情况没有考虑，需要大量额外处理，例如引用计数很难解决对象之间循环引用的问题 可达性分析算法简介：通过一系列称为:”GC Roots”的根对象作为起始节点集，从这些节点的引用关系向下搜索，走过的路径称为引用链，如果对象到GCRoots之间没有引用链相连，证明对象不可能被再使用 Java采用 GCRoots对象 虚拟机栈中引用的对象，各个线程被调用的方法堆栈中用到的参数、局部变量、临时变量等 方法区中类静态属性引用的对象，引用类型静态变量 常量引用的对象，字符串常量池中的引用 本地方法栈中native方法引用的对象 Java虚拟机内部的引用，如基本数据类型对应的class对象，常驻异常对象，还有系统类加载器 所有被同步锁持有的对象 反映虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等等 除了这些，还可根据垃圾回收器以及当前回收的内存区域不同，选择其他对象临时性加入 例如，分代收集和局部回收，局部回收某个内存区域，该可能有其他区域引用该区域，所以将这些关联区域的对象也一并加入GC Roots集合中，保证可达分析正确性 引用reference：存储的数值代表另一块内存的起始地址 希望描述一类对象：内存空间足够时，还能保存在内存中，而紧张时则可以抛弃——缓存 JDK1.2之后，细分了引用概念 强引用：Object obj = new Object() 只要存在则不会被回收 软引用：还有用，但非必须，在溢出异常发生前，会列入回收范围进行二次回收，回收完如果还是内存不足则发生内存溢出异常 弱引用：强度比软引用更弱，描述非必须对象，只能生存到下次垃圾收集发生为止 虚引用：最弱，无法取得对象实例，唯一目的是垃圾回收时收到一个系统通知 判定对象生存还是死亡判定不可达——》被标记——》对标记对象进行一次筛选，条件是是否有必要执行finalize()方法 没有必要或已经被虚拟机调用：视为没有必要执行 有必要执行：置入F-Queue队列，用Finalizer线程（优先级低）调用它们去执行finalize方法，对F-Queue进行第二次小规模标记，只要该对象重新和引用链上任何一个对象建立关联便可存活，从而将其移出“即将回收集合” 回收方法区方法区垃圾收集：废弃的常量和不再使用的类型 判断类型不再被使用的条件： 该类所有实例都已经被回收 加载该类的类加载器已经被回收 该类的java.lang.Class对象没有在任何地方被引用，也无法在任何地方通过反射访问该类的方法 大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，都需要Java虚拟机具备类型卸载能力","link":"/2021/03/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA2/"}],"tags":[{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"VUE","slug":"VUE","link":"/tags/VUE/"},{"name":"REACT","slug":"REACT","link":"/tags/REACT/"},{"name":"状态压缩","slug":"状态压缩","link":"/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"},{"name":"Trie树","slug":"Trie树","link":"/tags/Trie%E6%A0%91/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"《深入理解Java虚拟机》","slug":"《深入理解Java虚拟机》","link":"/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/"}],"categories":[{"name":"web前端","slug":"web前端","link":"/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"面试","slug":"面试","link":"/categories/%E9%9D%A2%E8%AF%95/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]}