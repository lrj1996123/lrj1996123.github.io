{"pages":[{"title":"文章分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/03/01/hello-world/"},{"title":"算法分析1.猜字谜","text":"原题外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。 字谜的迷面 puzzle 按字符串形式给出，如果一个单词 word 符合下面两个条件，那么它就可以算作谜底： 单词 word 中包含谜面 puzzle 的第一个字母。 单词 word 中的每一个字母都可以在谜面 puzzle 中找到。 例如，如果字谜的谜面是 “abcdefg“，那么可以作为谜底的单词有 “faced“, “cabbage“, 和 “baggage“；而 “beefed“（不含字母 “a”）以及 “based“（其中的 “s” 没有出现在谜面中）都不能作为谜底。 返回一个答案数组 answer，数组中的每个元素 answer[i] 是在给出的单词列表 words 中可以作为字谜迷面 puzzles[i] 所对应的谜底的单词数目。 示例1234567891011输入：words = [&quot;aaaa&quot;,&quot;asas&quot;,&quot;able&quot;,&quot;ability&quot;,&quot;actt&quot;,&quot;actor&quot;,&quot;access&quot;], puzzles = [&quot;aboveyz&quot;,&quot;abrodyz&quot;,&quot;abslute&quot;,&quot;absoryz&quot;,&quot;actresz&quot;,&quot;gaswxyz&quot;]输出：[1,1,3,2,4,0]解释：1 个单词可以作为 &quot;aboveyz&quot; 的谜底 : &quot;aaaa&quot; 1 个单词可以作为 &quot;abrodyz&quot; 的谜底 : &quot;aaaa&quot;3 个单词可以作为 &quot;abslute&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;, &quot;able&quot;2 个单词可以作为 &quot;absoryz&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;4 个单词可以作为 &quot;actresz&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;, &quot;actt&quot;, &quot;access&quot;没有单词可以作为 &quot;gaswxyz&quot; 的谜底，因为列表中的单词都不含字母 'g'。 提示1234561 &lt;= words.length &lt;= 10^54 &lt;= words[i].length &lt;= 501 &lt;= puzzles.length &lt;= 10^4puzzles[i].length == 7words[i][j], puzzles[i][j] 都是小写英文字母。每个 puzzles[i] 所包含的字符都不重复。 分析 word和puzzle均为小写字母，即由a~z26个字母组成 每个puzzle长度为7，所包含字符不重复 输出为每个puzzle对应的谜底word个数 要求puzzle含有word中每一个字母，且其中一个为puzzle首字母 类似题型总结：字符串子集的匹配，不重复字符的子集，字符限制为小写或大写 方法一、二进制状态压缩由于words中的word含有重复字母，根据题意不考虑字母的个数，只判断字母的存在性，以此选择合适的表示方法 由于word中只包含小写英文字母a到z，所以word通过26位二进制来表示，0表示不存在，1表示存在 由于只利用的字母的存在性，可能有多个word的二进制表示是相同的，这里通过map来表示每种word的二进制表示的出现次数 题目中要求输出每个puzzle（7位）所匹配的word个数，对puzzle的二进制表示，所以枚举每个puzzle的子集，特别地，该子集一定包含puzzle首字母，关于枚举这里有两个思路： 思路一：枚举6位二进制数来选择puzzle16位所有的字母组合，以此遍历每个puzzle16位的子集，特别地，每次遍历都要加上puzzle第0位（题目要求word中必须有puzzle第0位的字母），代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution { public List&lt;Integer&gt; findNumOfValidWords(String[] words, String[] puzzles) { Map&lt;Integer, Integer&gt; fre = new HashMap&lt;&gt;(); // word的二进制表示 for(String word: words){ int mask = 0; for(int i = 0; i &lt; word.length(); i++){ mask |= 1 &lt;&lt; (word.charAt(i) - 'a'); } if(Integer.bitCount(mask) &lt;= 7){ fre.put(mask, fre.getOrDefault(mask, 0) + 1); } } List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for(String puzzle: puzzles){ int total = 0; // 从000000到111111表示puzzle所有子集的组合形式，遍历这些子集 // (puzzle第1位到第6位的子集，忽略第0位) for(int choose = 0; choose &lt; (1 &lt;&lt; 6); choose++){ int mask = 0; for(int i = 0; i &lt; 6; i++){ // choose表示puzzle子集的一种组合形式，通过&amp;操作来选取数字1对应的单词，0则忽略 if( (choose &amp; (1 &lt;&lt; i)) != 0 ){ mask |= 1 &lt;&lt; (puzzle.charAt(i + 1) - 'a'); } } // 要求谜底word中一定包含puzzle首字母，所以这里单独处理 mask |= 1 &lt;&lt; (puzzle.charAt(0) - 'a'); // 如果puzzle的子集（包含首字母）是谜底word，则将所有该形式加入 if(fre.containsKey(mask)){ total += fre.get(mask); } } ans.add(total); } return ans; }} 思路二：通过的位运算方法来枚举puzzle所有子集，对于puzzle1~6位的二进制表示mask，对subset初始化赋值mask，然后每次迭代进行如下操作： 1subset = (subset - 1) &amp; mask 由于subset中的1之间可能存在0，即不存在的字母和puzzle首位字母，所以对subset-1进行操作时，对subset-1和mask做“与”运算，保证不存在的字母永远不存在，实现了去冗，不断地减1使得subset中的1再次消失或再次出现，且保证subset越来越小，所以巧妙地遍历出所有子集 123456789101112131415161718192021222324252627282930313233 class Solution { public List&lt;Integer&gt; findNumOfValidWords(String[] words, String[] puzzles) { Map&lt;Integer, Integer&gt; fre = new HashMap&lt;&gt;(); for(String word: words){ int mask = 0; for(int i = 0; i &lt; word.length(); i++){ mask |= 1 &lt;&lt; (word.charAt(i) - 'a'); } if(Integer.bitCount(mask) &lt;= 7){ fre.put(mask, fre.getOrDefault(mask, 0) + 1); } } List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for(String puzzle: puzzles){ int total = 0; int mask = 0; //对需要枚举的后六位进行二进制表示 for(int i = 1; i &lt; 7; i++){ mask |= 1 &lt;&lt; (puzzle.charAt(i) - 'a'); } int subset = mask; do{ int s = subset | 1 &lt;&lt; (puzzle.charAt(0) - 'a');//枚举操作和-1操作时只需要固定第0位，所以这里进行单独运算 if(fre.containsKey(s)){ total += fre.get(s); } subset = (subset - 1) &amp; mask; }while(subset != mask);//subset为0时，-1代表所有位都为1，和mask“与”运算的结果必然与mask相等 ans.add(total); } return ans; }} 二、Trie树+回溯word中重复字母不考虑，puzzle无重复字母+遍历子集，所以可以采用Trie树方法将words所有单词保存，在每个单词最后一个字母处保存含有相同字母存在的单词个数 接着，遍历puzzles，对每个puzzle，我们需要通过Trie树查找该puzzle的子集，遍历子集的方式采用回溯法，分别考虑当前位置单词和忽略当前位置的下一个单词，特别注意的是，首字母不能忽略 以上对Trie树的操作之前，首先要对word和puzzle进行排序，特别地，puzzle首字母要额外保存 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution { public List&lt;Integer&gt; findNumOfValidWords(String[] words, String[] puzzles) { TrieNode trieNode = new TrieNode(); //word去重并添加入树 for(String word: words){ char[] arr = word.toCharArray(); Arrays.sort(arr); StringBuffer sb = new StringBuffer(); for(int i = 0; i &lt; arr.length; i++){ if(i == 0 || arr[i] != arr[i - 1]){ sb.append(arr[i]); } } add(trieNode, sb.toString()); } List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for(String puzzle: puzzles){ char[] arr = puzzle.toCharArray(); //required表示puzzle的首字母，所以在排序前额外保留 char required = arr[0]; Arrays.sort(arr); ans.add(find(trieNode, required, new String(arr) ,0)); } return ans; } public void add(TrieNode root, String str){ for(int i = 0; i &lt; str.length(); i++){ if(root.child[str.charAt(i) - 'a'] == null){ root.child[str.charAt(i) - 'a'] = new TrieNode(); } root = root.child[str.charAt(i) - 'a']; } root.fre++; } public int find(TrieNode cur, char required, String puzzle, int pos){ if(cur == null){ return 0; } //cur!=null且pos==7的位置，包含puzzle所有子集的情况，cur.fre==0表示当前cur并非叶子结点 if(pos == 7){ return cur.fre; } int ret = find(cur.child[puzzle.charAt(pos) - 'a'], required, puzzle, pos + 1); //如果不是首字母，则额外考虑忽略pos位置字母的情况，不忽略与忽略两种情况相加 if(puzzle.charAt(pos) != required){ ret += find(cur, required, puzzle,pos + 1); } return ret; }}","link":"/2021/03/02/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%901-%E7%8C%9C%E5%AD%97%E8%B0%9C/"},{"title":"算法分析2.俄罗斯套娃信封问题","text":"原题给定二维数组envelopes，其中**envelopes[i] = [$w_i$,$h_i$]**，表示第i个信封的宽度和高度 要求：另一个信封的宽高都比这个信封大，这个信封就可以放进另一个信封里面，如同俄罗斯套娃，接连地一个套一个 计算最多能有多少个信封能组成一组“俄罗斯套娃信封序列” 注意：不允许旋转信封 示例123输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]输出：3解释：最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。 提示1231 &lt;= envelopes.length &lt;= 5000envelopes[i].length == 21 &lt;= wi, hi &lt;= 104 分析 不允许旋转信封，即i套j的条件：$w_i &gt; w_j$ &amp;&amp; $h_i &gt; h_j$ 因为需要分别对w和h进行排序，这里选择先对w升序排序 w已排好序，所以只需要通过判断h大小来进行套娃。但是，如果h也是升序排序，那么会导致同一大小的w中选择多个信封，然而只能从w相同的信封中选择一封 1排完序的结果为[(w,h)]=[(1,1),(1,2),(1,3),(1,4)]，由于这些信封的w值都相同，不存在一个信封可以装下另一个信封，那么我们只能在其中选择 11 个信封。然而如果我们完全忽略w维度，剩下的h维度为[1,2,3,4]，这是一个严格递增的序列，那么我们就可以选择所有的4个信封了，这就产生了错误。 对于w相同的信封只能从中选择一封，通过贪心策略得出，优先选择h小的，才能保证能有更多信封可以套它 方法一、 动态规划将信封的w按照从小到大排序，然后w相同的信封的h按照从大到小排序，这样可以保证对于相同w的信封只能选择其中一封 设f[i]为0~i的最长严格递增子序列的长度， 要求最后的选择为第i个信封，则倒数第二个选择的信封为$j$($j\\lt i$)，遍历j，此时f[j]是已知的，所以如果第j个信封能够套入第i个信封，则0~i的最长递增子序列则为所有f[j]+1当中的最大值 由此得到状态转移公式$$f[i] = \\max\\limits_{j&lt;i \\wedge d_j&lt;d_i}{f[j] + 1}$$得到代码 12345678910111213141516171819202122232425262728293031class Solution { public int maxEnvelopes(int[][] envelopes) { if (envelopes.length == 0) { return 0; } int n = envelopes.length; Arrays.sort(envelopes, new Comparator&lt;int[]&gt;() { public int compare(int[] e1, int[] e2) { if (e1[0] != e2[0]) { return e1[0] - e2[0];//w从小到大排序 } else { return e2[1] - e1[1];//h从大到小排序 } } }); int[] f = new int[n];//f[i]表示0~i可以组成的最大严格递增子序列，且必须选择第i个信封 Arrays.fill(f, 1); int ans = 1; for (int i = 1; i &lt; n; ++i) {//选择第i个元素为最后一个所选择的信封 for (int j = 0; j &lt; i; ++j) {//选择第j个元素为倒数第二个选择的信封 if (envelopes[j][1] &lt; envelopes[i][1]) { f[i] = Math.max(f[i], f[j] + 1);//这里f[i]初始化为1(第i个元素本身)，然后从所有f[j]+1中选择最大值 } } ans = Math.max(ans, f[i]);//所有f当中的最大值即为答案 } return ans; }} 二、 二分查找+贪心算法设f[j]为前i个元素可以组成的最长长度为j的严格递增子序列的末尾元素的h的最小值 贪心思路：让序列上升得尽可能慢 f的性质： f值是严格单调递增的，因为越长的子序列末尾元素显然越大 证明：假设$f[j]\\ge f[i]$且$j\\lt i$ ，从长度为$i$的最长上升子序列末尾删除$i-j$个元素，那么这个序列长度变为j，末尾元素一定比i小，所以$f[j]’\\lt f[i] \\lt f[j] $ 但是f[j]是长度为j的递增子序列的最小值，所以矛盾 末尾元素是可以放的最小值 例如序列[1,2,3,6,4,5]中，1236和1234两个相同长度序列，只有f[3] = 4的时候，序列才可以变得更长 状态转移方法： 考虑当前元素$h_{i}$ $h_i$大于f中的最大值，那么$h_i$就可以接在f最大值之后 否则，从f中比$h_{i}$ 严格小的最大元素$f[j_{0}]$，得到$f[j_{0}]\\lt h_{i} \\lt f[j_{0} + 1]$ ,那么$h_{i} $就可以替换$f[j_{0}+1]$ 可以通过二分查找，找出满足要求的$j_{0}$ 最终f的长度即为最长严格递增子序列的长度 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution { public int maxEnvelopes(int[][] envelopes) { if (envelopes.length == 0) { return 0; } int n = envelopes.length; Arrays.sort(envelopes, new Comparator&lt;int[]&gt;() { public int compare(int[] e1, int[] e2) { if (e1[0] != e2[0]) { return e1[0] - e2[0]; } else { return e2[1] - e1[1]; } } }); List&lt;Integer&gt; f = new ArrayList&lt;Integer&gt;(); f.add(envelopes[0][1]); //主要贪心策略 for (int i = 1; i &lt; n; ++i) { int num = envelopes[i][1]; if (num &gt; f.get(f.size() - 1)) { f.add(num); } else { int index = binarySearch(f, num); f.set(index, num); } } return f.size(); } //二分查找，找到第一个大于target的元素的位置 public int binarySearch(List&lt;Integer&gt; f, int target) { int low = 0, high = f.size() - 1; while (low &lt; high) { int mid = (high - low) / 2 + low; if (f.get(mid) &lt; target) { low = mid + 1; } else { high = mid; } } return low; }} 其他：二分查找变种一、二分查找寻找一个数（基本）123456789101112131415int binarySearch(int[] nums, int target) { int left = 0; int right = nums.length - 1; // 注意，搜索空间为[left,right]的闭区间 while(left &lt;= right) { // 注意，left&gt;right表示搜索空间消失 int mid = (right + left) / 2; if(nums[mid] == target) return mid; else if (nums[mid] &lt; target) left = mid + 1; // 注意，搜索空间变为[mid+1,right] else if (nums[mid] &gt; target) right = mid - 1; // 注意，同上 } return -1;} 二、二分查找寻找左侧边界（最左侧target下标）1234567891011121314151617int left_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0; int right = nums.length; // 注意,搜索空间为[left,right)的左闭右开区间 while (left &lt; right) { // 注意,终止条件为left==right,即[left,left) int mid = (left + right) / 2; if (nums[mid] == target) { right = mid;//nums[mid]虽然等于target，但我们依然要在[left,mid)中搜索来锁定左侧边界 } else if (nums[mid] &lt; target) { left = mid + 1; } else if (nums[mid] &gt; target) { right = mid; // 注意，因为搜索空间是左闭右开，下一步搜索空间应该去掉mid即[left,mid)和[mid+1,right) } } return left;} 三、 二分查找寻找右侧边界（最右侧target下标）123456789101112131415int right_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0, right = nums.length; while (left &lt; right) { int mid = (left + right) / 2; if (nums[mid] == target) { left = mid + 1; // 注意，找到相等元素不要立刻返回，而是继续向右寻找[mid+1,right) } else if (nums[mid] &lt; target) { left = mid + 1; } else if (nums[mid] &gt; target) { right = mid; } } return left - 1; // 注意因为left=mid+1，所以最终left位置不等于target，所以left-1","link":"/2021/03/08/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%902-%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"VUE","slug":"VUE","link":"/tags/VUE/"},{"name":"REACT","slug":"REACT","link":"/tags/REACT/"},{"name":"状态压缩","slug":"状态压缩","link":"/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"},{"name":"Trie树","slug":"Trie树","link":"/tags/Trie%E6%A0%91/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"categories":[{"name":"web前端","slug":"web前端","link":"/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"}]}