{"pages":[{"title":"文章分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/03/01/hello-world/"},{"title":"算法分析1.猜字谜","text":"原题外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。 字谜的迷面 puzzle 按字符串形式给出，如果一个单词 word 符合下面两个条件，那么它就可以算作谜底： 单词 word 中包含谜面 puzzle 的第一个字母。 单词 word 中的每一个字母都可以在谜面 puzzle 中找到。 例如，如果字谜的谜面是 “abcdefg“，那么可以作为谜底的单词有 “faced“, “cabbage“, 和 “baggage“；而 “beefed“（不含字母 “a”）以及 “based“（其中的 “s” 没有出现在谜面中）都不能作为谜底。 返回一个答案数组 answer，数组中的每个元素 answer[i] 是在给出的单词列表 words 中可以作为字谜迷面 puzzles[i] 所对应的谜底的单词数目。 示例1234567891011输入：words = [&quot;aaaa&quot;,&quot;asas&quot;,&quot;able&quot;,&quot;ability&quot;,&quot;actt&quot;,&quot;actor&quot;,&quot;access&quot;], puzzles = [&quot;aboveyz&quot;,&quot;abrodyz&quot;,&quot;abslute&quot;,&quot;absoryz&quot;,&quot;actresz&quot;,&quot;gaswxyz&quot;]输出：[1,1,3,2,4,0]解释：1 个单词可以作为 &quot;aboveyz&quot; 的谜底 : &quot;aaaa&quot; 1 个单词可以作为 &quot;abrodyz&quot; 的谜底 : &quot;aaaa&quot;3 个单词可以作为 &quot;abslute&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;, &quot;able&quot;2 个单词可以作为 &quot;absoryz&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;4 个单词可以作为 &quot;actresz&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;, &quot;actt&quot;, &quot;access&quot;没有单词可以作为 &quot;gaswxyz&quot; 的谜底，因为列表中的单词都不含字母 'g'。 提示1234561 &lt;= words.length &lt;= 10^54 &lt;= words[i].length &lt;= 501 &lt;= puzzles.length &lt;= 10^4puzzles[i].length == 7words[i][j], puzzles[i][j] 都是小写英文字母。每个 puzzles[i] 所包含的字符都不重复。 分析 word和puzzle均为小写字母，即由a~z26个字母组成 每个puzzle长度为7，所包含字符不重复 输出为每个puzzle对应的谜底word个数 要求puzzle含有word中每一个字母，且其中一个为puzzle首字母 类似题型总结：字符串子集的匹配，不重复字符的子集，字符限制为小写或大写 方法一、二进制状态压缩由于words中的word含有重复字母，根据题意不考虑字母的个数，只判断字母的存在性，以此选择合适的表示方法 由于word中只包含小写英文字母a到z，所以word通过26位二进制来表示，0表示不存在，1表示存在 由于只利用的字母的存在性，可能有多个word的二进制表示是相同的，这里通过map来表示每种word的二进制表示的出现次数 题目中要求输出每个puzzle（7位）所匹配的word个数，对puzzle的二进制表示，所以枚举每个puzzle的子集，特别地，该子集一定包含puzzle首字母，关于枚举这里有两个思路： 思路一：枚举6位二进制数来选择puzzle16位所有的字母组合，以此遍历每个puzzle16位的子集，特别地，每次遍历都要加上puzzle第0位（题目要求word中必须有puzzle第0位的字母），代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution { public List&lt;Integer&gt; findNumOfValidWords(String[] words, String[] puzzles) { Map&lt;Integer, Integer&gt; fre = new HashMap&lt;&gt;(); // word的二进制表示 for(String word: words){ int mask = 0; for(int i = 0; i &lt; word.length(); i++){ mask |= 1 &lt;&lt; (word.charAt(i) - 'a'); } if(Integer.bitCount(mask) &lt;= 7){ fre.put(mask, fre.getOrDefault(mask, 0) + 1); } } List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for(String puzzle: puzzles){ int total = 0; // 从000000到111111表示puzzle所有子集的组合形式，遍历这些子集 // (puzzle第1位到第6位的子集，忽略第0位) for(int choose = 0; choose &lt; (1 &lt;&lt; 6); choose++){ int mask = 0; for(int i = 0; i &lt; 6; i++){ // choose表示puzzle子集的一种组合形式，通过&amp;操作来选取数字1对应的单词，0则忽略 if( (choose &amp; (1 &lt;&lt; i)) != 0 ){ mask |= 1 &lt;&lt; (puzzle.charAt(i + 1) - 'a'); } } // 要求谜底word中一定包含puzzle首字母，所以这里单独处理 mask |= 1 &lt;&lt; (puzzle.charAt(0) - 'a'); // 如果puzzle的子集（包含首字母）是谜底word，则将所有该形式加入 if(fre.containsKey(mask)){ total += fre.get(mask); } } ans.add(total); } return ans; }} 思路二：通过的位运算方法来枚举puzzle所有子集，对于puzzle1~6位的二进制表示mask，对subset初始化赋值mask，然后每次迭代进行如下操作： 1subset = (subset - 1) &amp; mask 由于subset中的1之间可能存在0，即不存在的字母和puzzle首位字母，所以对subset-1进行操作时，对subset-1和mask做“与”运算，保证不存在的字母永远不存在，实现了去冗，不断地减1使得subset中的1再次消失或再次出现，且保证subset越来越小，所以巧妙地遍历出所有子集 123456789101112131415161718192021222324252627282930313233 class Solution { public List&lt;Integer&gt; findNumOfValidWords(String[] words, String[] puzzles) { Map&lt;Integer, Integer&gt; fre = new HashMap&lt;&gt;(); for(String word: words){ int mask = 0; for(int i = 0; i &lt; word.length(); i++){ mask |= 1 &lt;&lt; (word.charAt(i) - 'a'); } if(Integer.bitCount(mask) &lt;= 7){ fre.put(mask, fre.getOrDefault(mask, 0) + 1); } } List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for(String puzzle: puzzles){ int total = 0; int mask = 0; //对需要枚举的后六位进行二进制表示 for(int i = 1; i &lt; 7; i++){ mask |= 1 &lt;&lt; (puzzle.charAt(i) - 'a'); } int subset = mask; do{ int s = subset | 1 &lt;&lt; (puzzle.charAt(0) - 'a');//枚举操作和-1操作时只需要固定第0位，所以这里进行单独运算 if(fre.containsKey(s)){ total += fre.get(s); } subset = (subset - 1) &amp; mask; }while(subset != mask);//subset为0时，-1代表所有位都为1，和mask“与”运算的结果必然与mask相等 ans.add(total); } return ans; }} 二、Trie树+回溯word中重复字母不考虑，puzzle无重复字母+遍历子集，所以可以采用Trie树方法将words所有单词保存，在每个单词最后一个字母处保存含有相同字母存在的单词个数 接着，遍历puzzles，对每个puzzle，我们需要通过Trie树查找该puzzle的子集，遍历子集的方式采用回溯法，分别考虑当前位置单词和忽略当前位置的下一个单词，特别注意的是，首字母不能忽略 以上对Trie树的操作之前，首先要对word和puzzle进行排序，特别地，puzzle首字母要额外保存 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution { public List&lt;Integer&gt; findNumOfValidWords(String[] words, String[] puzzles) { TrieNode trieNode = new TrieNode(); //word去重并添加入树 for(String word: words){ char[] arr = word.toCharArray(); Arrays.sort(arr); StringBuffer sb = new StringBuffer(); for(int i = 0; i &lt; arr.length; i++){ if(i == 0 || arr[i] != arr[i - 1]){ sb.append(arr[i]); } } add(trieNode, sb.toString()); } List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for(String puzzle: puzzles){ char[] arr = puzzle.toCharArray(); //required表示puzzle的首字母，所以在排序前额外保留 char required = arr[0]; Arrays.sort(arr); ans.add(find(trieNode, required, new String(arr) ,0)); } return ans; } public void add(TrieNode root, String str){ for(int i = 0; i &lt; str.length(); i++){ if(root.child[str.charAt(i) - 'a'] == null){ root.child[str.charAt(i) - 'a'] = new TrieNode(); } root = root.child[str.charAt(i) - 'a']; } root.fre++; } public int find(TrieNode cur, char required, String puzzle, int pos){ if(cur == null){ return 0; } //cur!=null且pos==7的位置，包含puzzle所有子集的情况，cur.fre==0表示当前cur并非叶子结点 if(pos == 7){ return cur.fre; } int ret = find(cur.child[puzzle.charAt(pos) - 'a'], required, puzzle, pos + 1); //如果不是首字母，则额外考虑忽略pos位置字母的情况，不忽略与忽略两种情况相加 if(puzzle.charAt(pos) != required){ ret += find(cur, required, puzzle,pos + 1); } return ret; }}","link":"/2021/03/02/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%901-%E7%8C%9C%E5%AD%97%E8%B0%9C/"},{"title":"算法分析2.俄罗斯套娃信封问题","text":"原题给定二维数组envelopes，其中**envelopes[i] = [$w_i$,$h_i$]**，表示第i个信封的宽度和高度 要求：另一个信封的宽高都比这个信封大，这个信封就可以放进另一个信封里面，如同俄罗斯套娃，接连地一个套一个 计算最多能有多少个信封能组成一组“俄罗斯套娃信封序列” 注意：不允许旋转信封 示例123输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]输出：3解释：最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。 提示1231 &lt;= envelopes.length &lt;= 5000envelopes[i].length == 21 &lt;= wi, hi &lt;= 104 分析 不允许旋转信封，即i套j的条件：$w_i &gt; w_j$ &amp;&amp; $h_i &gt; h_j$ 因为需要分别对w和h进行排序，这里选择先对w升序排序 w已排好序，所以只需要通过判断h大小来进行套娃。但是，如果h也是升序排序，那么会导致同一大小的w中选择多个信封，然而只能从w相同的信封中选择一封 1排完序的结果为[(w,h)]=[(1,1),(1,2),(1,3),(1,4)]，由于这些信封的w值都相同，不存在一个信封可以装下另一个信封，那么我们只能在其中选择 11 个信封。然而如果我们完全忽略w维度，剩下的h维度为[1,2,3,4]，这是一个严格递增的序列，那么我们就可以选择所有的4个信封了，这就产生了错误。 对于w相同的信封只能从中选择一封，通过贪心策略得出，优先选择h小的，才能保证能有更多信封可以套它 方法一、 动态规划将信封的w按照从小到大排序，然后w相同的信封的h按照从大到小排序，这样可以保证对于相同w的信封只能选择其中一封 设f[i]为0~i的最长严格递增子序列的长度， 要求最后的选择为第i个信封，则倒数第二个选择的信封为$j$($j\\lt i$)，遍历j，此时f[j]是已知的，所以如果第j个信封能够套入第i个信封，则0~i的最长递增子序列则为所有f[j]+1当中的最大值 由此得到状态转移公式$$f[i] = \\max\\limits_{j&lt;i \\wedge d_j&lt;d_i}{f[j] + 1}$$得到代码 12345678910111213141516171819202122232425262728293031class Solution { public int maxEnvelopes(int[][] envelopes) { if (envelopes.length == 0) { return 0; } int n = envelopes.length; Arrays.sort(envelopes, new Comparator&lt;int[]&gt;() { public int compare(int[] e1, int[] e2) { if (e1[0] != e2[0]) { return e1[0] - e2[0];//w从小到大排序 } else { return e2[1] - e1[1];//h从大到小排序 } } }); int[] f = new int[n];//f[i]表示0~i可以组成的最大严格递增子序列，且必须选择第i个信封 Arrays.fill(f, 1); int ans = 1; for (int i = 1; i &lt; n; ++i) {//选择第i个元素为最后一个所选择的信封 for (int j = 0; j &lt; i; ++j) {//选择第j个元素为倒数第二个选择的信封 if (envelopes[j][1] &lt; envelopes[i][1]) { f[i] = Math.max(f[i], f[j] + 1);//这里f[i]初始化为1(第i个元素本身)，然后从所有f[j]+1中选择最大值 } } ans = Math.max(ans, f[i]);//所有f当中的最大值即为答案 } return ans; }} 二、 二分查找+贪心算法设f[j]为前i个元素可以组成的最长长度为j的严格递增子序列的末尾元素的h的最小值 贪心思路：让序列上升得尽可能慢 f的性质： f值是严格单调递增的，因为越长的子序列末尾元素显然越大 证明：假设$f[j]\\ge f[i]$且$j\\lt i$ ，从长度为$i$的最长上升子序列末尾删除$i-j$个元素，那么这个序列长度变为j，末尾元素一定比i小，所以$f[j]’\\lt f[i] \\lt f[j] $ 但是f[j]是长度为j的递增子序列的最小值，所以矛盾 末尾元素是可以放的最小值 例如序列[1,2,3,6,4,5]中，1236和1234两个相同长度序列，只有f[3] = 4的时候，序列才可以变得更长 状态转移方法： 考虑当前元素$h_{i}$ $h_i$大于f中的最大值，那么$h_i$就可以接在f最大值之后 否则，从f中比$h_{i}$ 严格小的最大元素$f[j_{0}]$，得到$f[j_{0}]\\lt h_{i} \\lt f[j_{0} + 1]$ ,那么$h_{i} $就可以替换$f[j_{0}+1]$ 可以通过二分查找，找出满足要求的$j_{0}$ 最终f的长度即为最长严格递增子序列的长度 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution { public int maxEnvelopes(int[][] envelopes) { if (envelopes.length == 0) { return 0; } int n = envelopes.length; Arrays.sort(envelopes, new Comparator&lt;int[]&gt;() { public int compare(int[] e1, int[] e2) { if (e1[0] != e2[0]) { return e1[0] - e2[0]; } else { return e2[1] - e1[1]; } } }); List&lt;Integer&gt; f = new ArrayList&lt;Integer&gt;(); f.add(envelopes[0][1]); //主要贪心策略 for (int i = 1; i &lt; n; ++i) { int num = envelopes[i][1]; if (num &gt; f.get(f.size() - 1)) { f.add(num); } else { int index = binarySearch(f, num); f.set(index, num); } } return f.size(); } //二分查找，找到第一个大于target的元素的位置 public int binarySearch(List&lt;Integer&gt; f, int target) { int low = 0, high = f.size() - 1; while (low &lt; high) { int mid = (high - low) / 2 + low; if (f.get(mid) &lt; target) { low = mid + 1; } else { high = mid; } } return low; }} 其他：二分查找变种一、二分查找寻找一个数（基本）123456789101112131415int binarySearch(int[] nums, int target) { int left = 0; int right = nums.length - 1; // 注意，搜索空间为[left,right]的闭区间 while(left &lt;= right) { // 注意，left&gt;right表示搜索空间消失 int mid = (right + left) / 2; if(nums[mid] == target) return mid; else if (nums[mid] &lt; target) left = mid + 1; // 注意，搜索空间变为[mid+1,right] else if (nums[mid] &gt; target) right = mid - 1; // 注意，同上 } return -1;} 二、二分查找寻找左侧边界（最左侧target下标）1234567891011121314151617int left_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0; int right = nums.length; // 注意,搜索空间为[left,right)的左闭右开区间 while (left &lt; right) { // 注意,终止条件为left==right,即[left,left) int mid = (left + right) / 2; if (nums[mid] == target) { right = mid;//nums[mid]虽然等于target，但我们依然要在[left,mid)中搜索来锁定左侧边界 } else if (nums[mid] &lt; target) { left = mid + 1; } else if (nums[mid] &gt; target) { right = mid; // 注意，因为搜索空间是左闭右开，下一步搜索空间应该去掉mid即[left,mid)和[mid+1,right) } } return left;} 三、 二分查找寻找右侧边界（最右侧target下标）123456789101112131415int right_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0, right = nums.length; while (left &lt; right) { int mid = (left + right) / 2; if (nums[mid] == target) { left = mid + 1; // 注意，找到相等元素不要立刻返回，而是继续向右寻找[mid+1,right) } else if (nums[mid] &lt; target) { left = mid + 1; } else if (nums[mid] &gt; target) { right = mid; } } return left - 1; // 注意因为left=mid+1，所以最终left位置不等于target，所以left-1","link":"/2021/03/08/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%902-%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98/"},{"title":"JAVA实习面试经验1.阿里CBU简历评估","text":"问题汇总1.自我介绍 2.项目介绍 做过什么项目？。。。 在团队当中充当了什么角色？后端 遇到了什么困难？数据库设计、业务逻辑设计方面 参考其他什么项目？之前公司的项目 自己在设计方面发挥亮眼的地方……..这里需要 通过E-R图介绍自己项目的数据之间的关系等 Springboot和Spring相比的优势 古德拜 总结复习到的基础知识都没有问0.0 注重项目经验，一定要理清楚项目数据库中的各种设计 分析自己在项目之中发挥的作用，解决的难题 新技术的运用，想办法扯进去一点 后续工作阅读《深入浅出JVM虚拟机》并做笔记 学习spring cloud和kafka","link":"/2021/03/15/JAVA%E9%9D%A2%E8%AF%951/"},{"title":"文献阅读1.《Attention-based LSTM for Aspect-level Sentiment Classification》","text":"","link":"/2021/03/16/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB1-%E3%80%8AAttention-based-LSTM-for-Aspect-level-Sentiment-Classification%E3%80%8B/"},{"title":"深入理解Java虚拟机1","text":"Java内存区域与内存溢出异常Java虚拟机自动内存管理机制，不需要为每个new操作去写配对的delete/free，不容易出现内存泄漏和内存溢出问题。 但是，控制内存的权利交给了Java虚拟机，一旦出现内存泄漏和内存溢出问题，排查错误并修正将会异常艰难。 运行时数据区域程序计数器当前线程所执行字节码的行号指示器：字节码解释器通过改变计数器的值来选取下一条需要执行的字节码指令 程序控制流的指示器：分支、循环、跳转、异常处理、线程恢复等都依赖该计数器 多线程：线程轮流切换，分配处理器执行时间，任何一个确定时刻，一个处理器内核只会执行一条线程中的指令 线程私有：切换线程时，为了能够回到正确位置，每条线程都需要有个独立的程序计数器 虚拟机栈线程私有：生命周期和线程相同 Java方法执行的线程内存模型：方法被执行，Java虚拟机同步创建一个栈帧 JVM创建的栈帧：存储局部变量表、操作数栈、动态连接、方法出口等信息， 每一个方法被调用到执行完毕 &lt;——&gt; 一个栈帧从虚拟机栈入栈到出栈 局部变量表：“栈”存放JVM基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它并不等同于对象本身，而是一个指向对象起始位置的引用指针，也可能指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址） 局部变量槽（Slot）：存储这些数据类型，除了long和double占用2个，其余占用1个 局部变量空间确定：进入一个方法时，局部变量空间大小（变量槽的数量）确定 内存区域异常： StackOverflow异常：线程请求的深度大于虚拟机允许的深度 OutOfMemoryError异常：栈可以动态扩展的虚拟机（Hotspot不会）扩展时无法申请到足够内存会抛出OutOfMemoryError异常 本地方法栈类似虚拟机栈，但本地方法栈为JVM用到的本地方法服务 异常和虚拟机栈类似 Java堆JVM内存最大的一块 所有线程共享 存放对象实例和数组（几乎所有，但不一定，逃逸分析技术、栈上分配、标量替换优化手段导致一些微妙变化） 垃圾回收器管理Java堆（GC堆） 线程私有的分配缓冲区（TLAB）：提升对象分配效率,目的只是更好回收内存，更快分配内存 物理上不连续，逻辑上连续，但大对象可能要求连续 可扩展可固定大小：主流可扩展，没有完成实例分配，堆无法再扩展时，会抛出OutOfMemoryError异常 方法区线程共享 存储JVM加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。 本地空间实现元空间来代替永久代 不需连续内存，可选择固定大小或可扩展，甚至可以选择不实现垃圾收集 回收效果不好，尤其是类型的卸载，但有时又很有必要 OutOfMemoryError 运行时常量池常量池表：编译期生成的各种字面量与符号引用，类加载后存放到方法区的运行时常量池中。 动态性：常量不一定只有编译期才能产生，String intern() OutOfMemoryError 直接内存通道+缓冲区直接操作Native函数库分配堆外内存，通过DirectByteBuffer对象作为这块内存的引用，从而提高性能 HotSpot虚拟机HotSpot虚拟机Java堆中对象的创建检测到字节码new指令 检查new指令的参数能否在常量池中定位到一个类的符号引用 检查该符号引用代表的类是否已被加载，否则必须先执行类加载 类加载检查通过后，虚拟机为新生对象分配内存。（类加载后对象所需内存大小即可完全确定） 给对象分配内存=把一块确定大小的内存从Java堆中划分出来 指针碰撞：假设所有被使用过的内存都放到一边，空闲内存放另一边，指针指向中间的分界点，内存分配就是向空闲内存一边挪动与新生对象大小相等的距离 空闲列表：已被使用的内存和空闲的内存相互交错在一起，虚拟机必须维护一个列表，记录哪些内存块可用，分配时在列表中找一块足够大的空间给对象实例，并更新表上的记录 如何选择分配内存方式？——Java堆是否规整决定 是否规整？——gc是否带有空间压缩整理的能力决定，例如Serail、ParNew能指针碰撞，而CMS基于清除算法，理论上只能空闲列表 对象创建频繁，并发时线程不安全 解决方案： 1.同步处理分配内存空间的动作，采用CAS配上失败重试 2.内存分配的动作按照线程划分在不从空间中进行，即每个线程在Java堆中预先分配一小块内存（本地线程分配缓冲 TLAB），优先使用线程自己的本地缓冲区，只有用完了，分配新缓冲区时才需要同步锁定. 内存分配完成后，分配到的内存空间初始化为0值（不包括对象头），也可TLAB分配之前就初始化，保证可以直接使用这些对象 然后，JVM对对象进行必要设置：哪个类的实例、如何找到元数据信息、对象的哈希码（实际上调用hashCode时才计算）、对象GC分代年龄等信息。这些信息存放在对象头中 对象头设置方式不同：由JVM当前运行状态决定 对象诞生了 但是Java程序的视角，对象创建刚开始——构造函数，new指令跟随invokespecial指令，随后按照程序员的意愿初始化，才将对象创建完毕 对象的内存布局三部分：对象头、实例数据、对齐填充 对象头MarkWord：存储对象自身运行时数据，头信息是与对象自身定义的数据无关的额外存储成本，一个动态定义的数据结构 存储内容 标志位 状态 对象哈希码（25）、对象分代年龄（4） 01 未锁定 指向锁记录的指针（1） 00 轻量级锁定 指向重量级锁的指针（1） 10 膨胀（重量级锁定） 空，不需要记录信息（1） 11 GC标记 偏向线程ID、偏向时间戳、对象分代年龄 01 可偏向 类型指针：指向类型元数据的指针，确定是哪个类的实例。对象数据上不一定保留类型指针。如果是Java数组，对象头还要有一块记录数组长度的数据 实例数据信息 程序代码里面定义的各种类型的字段内容 存储顺序会受分配策略参数和定义顺序影响 默认分配顺序：longs/doubles、ints、shorts/chars、bytes/booleans、oops 相同宽度的字段一起存放 父类定义的变量在子类之前 对齐填充 占位符，HotSpot要求对象起始地址是8字节整数倍 即任何对象大小是8字节整数倍 对象的访问定位reference数据：在栈上，来操作堆上的具体对象 如何定位访问堆中对象具体位置： 1.句柄访问，Java堆中多出一块句柄池，reference存储对象的句柄地址，而句柄包含对象实例数据地址和类型数据的地址信息 2.直接指针访问，reference存储的直接就是对象地址，而需要考虑Java堆中对象的内存布局 句柄的好处：对象被移动时只会改变句柄中的实例数据指针，而不需要修改reference指针 直接指针好处：速度快，HotSpot使用这种，使用Shenandoah手机也会有一次额外转发","link":"/2021/03/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA1/"},{"title":"深入理解Java虚拟机2","text":"垃圾收集器与内存分配策略线程共享区域：Java堆和方法区内存分配和回收不确定性 接口多个实现类，方法执行不同的条件分支，所占用的内存都可能不一样 这些部分内存的分配和回收是动态的，只有处于运行期间才知道 判定对象是否存活引用计数算法简介：对象添加一个引用计数器，每有一个地方引用，计数器加一；引用失效，计数器减一。任何时刻计数器为零的对象就是不能被再使用的 Java没有采用 问题：很多例外情况没有考虑，需要大量额外处理，例如引用计数很难解决对象之间循环引用的问题 可达性分析算法简介：通过一系列称为:”GC Roots”的根对象作为起始节点集，从这些节点的引用关系向下搜索，走过的路径称为引用链，如果对象到GCRoots之间没有引用链相连，证明对象不可能被再使用 Java采用 GCRoots对象 虚拟机栈中引用的对象，各个线程被调用的方法堆栈中用到的参数、局部变量、临时变量等 方法区中类静态属性引用的对象，引用类型静态变量 常量引用的对象，字符串常量池中的引用 本地方法栈中native方法引用的对象 Java虚拟机内部的引用，如基本数据类型对应的class对象，常驻异常对象，还有系统类加载器 所有被同步锁持有的对象 反映虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等等 除了这些，还可根据垃圾回收器以及当前回收的内存区域不同，选择其他对象临时性加入 例如，分代收集和局部回收，局部回收某个内存区域，该可能有其他区域引用该区域，所以将这些关联区域的对象也一并加入GC Roots集合中，保证可达分析正确性 引用reference：存储的数值代表另一块内存的起始地址 希望描述一类对象：内存空间足够时，还能保存在内存中，而紧张时则可以抛弃——缓存 JDK1.2之后，细分了引用概念 强引用：Object obj = new Object() 只要存在则不会被回收 软引用：还有用，但非必须，在溢出异常发生前，会列入回收范围进行二次回收，回收完如果还是内存不足则发生内存溢出异常 弱引用：强度比软引用更弱，描述非必须对象，只能生存到下次垃圾收集发生为止 虚引用：最弱，无法取得对象实例，唯一目的是垃圾回收时收到一个系统通知 判定对象生存还是死亡判定不可达——》被标记——》对标记对象进行一次筛选，条件是是否有必要执行finalize()方法 没有必要或已经被虚拟机调用：视为没有必要执行 有必要执行：置入F-Queue队列，用Finalizer线程（优先级低）调用它们去执行finalize方法，对F-Queue进行第二次小规模标记，只要该对象重新和引用链上任何一个对象建立关联便可存活，从而将其移出“即将回收集合” 回收方法区方法区垃圾收集：废弃的常量和不再使用的类型 判断类型不再被使用的条件： 该类所有实例都已经被回收 加载该类的类加载器已经被回收 该类的java.lang.Class对象没有在任何地方被引用，也无法在任何地方通过反射访问该类的方法 大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，都需要Java虚拟机具备类型卸载能力 垃圾收集算法引用计数式垃圾收集 追踪式垃圾收集（Java用到的） 分代收集理论由假说奠定垃圾收集器设计原则：将Java堆划分不同区域，然后将回收对象依据年龄分配到不同区域中存储。 有了以上原则，便设计出不同区域，针对不同区域安排与里面存储对象存亡特征相匹配的垃圾收集算法 新生代：每次垃圾收集都发现有大批对象死去，而每次回收后存活的少量对象，将会晋升到老年代中存放 老年代：长存区 问题：新生代的对象也可能被老年代所引用（跨代引用），导致垃圾收集新生代对象时可能还遍历老年代，影响性能 跨代引用假说：跨代引用占少数 跨代解决方法：在新生代上建立记忆集，将老年代划分若干小块，标识哪块内存会存在跨代引用，只有包含跨代引用的小块内存里的对象才会被加入到GC Roots中进行扫描 标记-清除算法标记和清除两个阶段 标记：标记所有需要回收的对象 清除：统一回收所有被标记的对象 缺点： 1.Java堆中大量需要被回收的对象，需要进行大量标记和清除动作 2.内存空间碎片化，使得后面需要分配较大对象而无法找到足够的连续内存 标记-复制算法半区复制：内存一分为二，每次只使用其中一块，这一块用完，就将还存活的对象复制到另一块上面，然后把这块一次性清理掉，复制时只需移动堆顶指针顺序分配即可 缺点： 1.内存中大量对象存活，复制开销大（多数对象都是可回收时好用，一般新生代使用） 2.内存缩小为原来的一半，浪费空间 标记-整理算法移动式回收算法，一般老年代使用 让所有存活对象向内存一端移动，然后直接清理掉边界以外的内存 权衡： 1.移动更新所有引用这些对象将会是极为负重的操作，导致停顿 2.如果不移动，碎片化问题只能通过内存分配器和内存访问器解决 从吞吐量来看，移动对象更划算 吞吐量：用户程序和收集器效率总和，不移动导致收集器效率高，但是因内存分配和访问相比垃圾收集频率要高很多，这部分耗时增加，总吞吐量仍然下降 和稀泥解决方法：标记清除，是在碎片化严重时用标记整理 经典垃圾收集器","link":"/2021/03/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA2/"},{"title":"Java高并发程序设计1","text":"重要概念同步和异步形容一次方法调用 同步方法调用一旦开始，调用者必须等待方法调用返回后，才能继续后续的行为 异步方法更像是一个消息传递，一旦开始，方法调用就会立即返回，调用者继续后续工作，而异步方法通常会在另一个线程“真实地”执行。如果需要，异步调用真实完成时，会通知调用者 并发与并行多个任务一起执行 并行：多个任务同时执行 并发：多个任务交替执行，串行执行 临界区一种公共资源或者共享数据，可以被多个线程使用 但一次只能被一个线程使用，一旦临界区资源被占用，其他线程想要使用的话必须等待 阻塞与非阻塞形容多线程之间的相互影响 阻塞：一个线程占用了临界区资源，其他需要该资源的线程就必须在临界区中等待，等待导致线程被挂起 非阻塞：没有线程可以妨碍其他线程执行，所有线程都会不断尝试前向执行 死锁、饥饿和活锁死锁线程需要的资源是另一个线程占用的资源，两两之间形成一个闭环，导致永远无法解除阻塞状态 饥饿线程无法获得所需要的资源，导致一直无法执行 可能因为线程优先级太低导致高优先级线程一直抢占它需要的资源 活锁两个线程都主动将资源释放给对方，导致资源在两线程间跳动，没有一个线程同时拿到所有资源正常执行 并发级别阻塞synchronized或重入锁，得到阻塞线程 试图执行后续代码前，得到临界区的锁，得不到的话线程就会被挂起等待 无饥饿非公平锁：存在优先级高低的线程，导致可能出现饥饿现象 公平锁：先来后到 无障碍多线程一起修改临界区数据，如果数据改坏了会导致回滚 悲观策略：经常冲突，保护共享数据 乐观策略：一般不会冲突，遇到则回滚 但严重冲突导致线程不断回滚自己操作，会影响正常执行。希望至少有一个线程在有限时间完成操作后退出临界区 “一致性标记”：操作前读取，操作完成后再读取，检查标记是否被更改。如果两者一致，说明无冲突，如果不一致，则资源可能在操作过程中与其它写线程冲突，需要重试。任何对资源有修改操作的线程，在修改前都需要更新一致性标记，表示数据不再安全 无锁无障碍，且保证有一个线程在有限步内完成操作离开临界区 特点：无穷循环，尝试修改共享变量，可能会有饥饿问题 无等待无锁，每个线程都必须在有限步内完成 特点：RCU（Read Copy Update），不控制读操作，写数据时先取得原始数据的副本，修改副本数据，在合适时机回写数据 Amadahl定律 加速比由以下公式求出$$T_n = T_1(F + \\frac{1}{n}(1-F))$$ $T_n$表示n个处理器优化后的耗时 $T_1$表示优化前耗时 $F$表示程序中只能串行执行的比例 所以加速比$$加速比=\\frac{1}{F+\\frac{1}{n}(1-F)}$$结论：提高系统速度不能仅仅增加CPU处理器数量，还要根本上修改程序的串行行为，提高系统内可并行化模块比重 Gustafson定律$$加速比=n-F(n-1)$$结论：只要不断累加处理器，就能获得更快的速度 JMMJava内存模型 保证多个线程之间可以有效地、正确地协同工作 JMM特点： 原子性指一个不可中断的操作。一个操作一旦开始，就不会被其他线程干扰 int读写原子性，long不是 可见性当一个线程修改了某个共享变量的值，其他线程是否能够立即知道这个修改 有序性并发时，程序的执行可能出现乱序 原因：可能发生指令重排（指令重排用于减少中断，提升CPU性能） 哪些指令不能重排：Happen-Before规则程序顺序原则：语义串行 volatile原则：volatile变量的写先于读发生 锁原则：解锁必然发生随后的加锁前 传递性：A先于B，B先于C，那么A必然先于C 线程的start()方法先于它的每一个动作 线程所有操作先于线程终结 线程的中断(interrupt())先于被中断线程的代码 对象构造函数的执行、结束先于finalize()方法","link":"/2021/03/30/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A11/"},{"title":"Java高并发程序设计2","text":"线程和进程进程：程序的一次执行过程，是系统进行资源分配和调度的基本单位，是线程的容器 线程：轻量级进程，是程序执行的最小单位，线程间切换和调度成本远小于进程，所以使用多线程进行并发程序设计 线程基本操作新建线程启动12345678910public class CreateThread implements Runnable{ public static void main(String[] args){ Thread t1 = new Thread(new CreateThread()); t1.start(); } @Override public void run(){ System.out.println(&quot;Oh, I am Runnable&quot;); }} 其中启动线程 12Thread t1 = new Thread();t1.start(); start()：新建一个线程并让线程执行run()方法 不要直接调用run()方法，它只会在当前线程中串行执行方法中的代码 线程终止Thread.stop()方法终止线程，被废弃不推荐使用 原因：方法过于暴力，终止时可能并没有完成相关写操作 停止线程方法：在完成run所有写操作时stop,保证不会在setId和setName之间stop 12345678910111213141516171819202122232425262728public class ChangeObjectThread implements Runnable{ volatile boolean stopme = false; public void stopMe(){ stopme = true; } @Override public void run(){ while(true){ if(stopme){ System.out.println(&quot;exit by stop me&quot;); break; } synchronized(u){//u为边缘区变量 int v = (int) (System.currentTimeMillis() / 1000); u.setId(v); try{ Thread.sleep(100); }catch(InterruptedException e){ e.printStackTrace(); } u.setName(String.valueOf(v)); } Thread.yield(); } }} 线程中断线程中断：不会立即退出，而是线程收到一个希望退出的通知，具体何时退出由线程自己决定 123456789101112Thread t1 = new Thread(){ @Override public void run(){ while(true){ if(Thread.currentThread().isInterrupted()){ System.out.println(&quot;Interrupted!&quot;); break; } Thread.yield(); } }} 如图，执行t1.interrupt()方法之后，通知t1被中断，具体何时中断可在while语句内控制 Time.sleep()函数线程休眠若干时间，期间如果中断会抛出InterruptedException中断异常 1234567try{ Thread.sleep(2000);}catch(InterruptedException e){ System.out.println(&quot;Interrupted When Sleep&quot;); //设置中断状态 Thread.currentThread().interrupt();} 注意，捕获中断后，会清除中断标记，这时需要再次设置中断标记位 等待和通知obj.wait()：线程处于等待状态，线程停止运行 进入object对象的等待队列 必须包含在synchronized语句中，执行后会释放锁 obj.notify()：线程结束等待，继续执行 等待队列中随机选择一个线程，将其唤醒（非公平） 无论是wait和notify必须首先获得目标对象的一个监视器（对象锁） T1在wait方法执行前获取监视器，执行后释放，目的是使其他等待在obj对象上的线程不至于因为T1的休眠而全部无法正常执行 T2在notify方法执行前获取监视器，因为T1已经释放监视器，可以顺利获取，执行notify方法后尝试唤醒一个等待线程，这里唤醒T1，唤醒后T1先重新获取监视器（这里需等待T1释放监视器），再继续执行 挂起和继续执行不推荐使用 suspend()线程暂停，不会释放任何锁资源，直到resume()方法之后，线程才会继续 然而如果resume方法意外地发生在suspend之前，就永远不会释放了 推荐使用wait+notify代替suspend和resume 等待线程结束和谦让join()，不加超时参数，表示无限等待，会一直阻塞当前线程，直到目标线程执行完毕 123456789101112131415public class JoinMain{ public volatile static int i=0; public static class AddThread extends Thread{ @Override public void run(){ for(i=0;i&lt;100000;i++); } } public static void main(String[] args) throws InterruptedException{ AddThread at = new AddThread(); at.start(); at.join();//主线程等待AddThread执行完毕 System.out.println(i);//输出100000 }} join方法实现的核心代码 123while(isAlive()){ wait(0);} 使得调用线程（主线程）在被调用线程对象上进行等待，被调用线程执行完毕后，会在退出前调用notifyAll()方法通知所有等待线程继续执行 所以，不要在Thread对象实例上使用类似wait()方法或者notify()方法，会影响系统api工作 yield()：让出CPU，而非结束执行，会继续竞争cpu volatile与JMMvolatile该变量极有可能会被某些程序或线程修改，修改后系统想办法通知给其他线程，保障数据可见性，同时保障操作原子性（有限保障），防止数据被写坏,如之前的long类型，可以通过添加volatile修饰保证不会被写坏 参考： https://blog.csdn.net/u012723673/article/details/80682208 但是，volatile并不能替代锁，无法保证一些复合操作的原子性 如 12345678910111213141516171819202122232425public class Main { static volatile int i = 0; public static class PlusTask implements Runnable{ @Override public void run() { for(int k = 0; k &lt; 10000; k++){ i++; } } } public static void main(String[] args) throws InterruptedException { Thread[] threads = new Thread[10]; for(int i = 0; i &lt; 10; i++){ threads[i] = new Thread(new PlusTask()); threads[i].start(); } for(int i = 0; i &lt; 10; i++){ threads[i].join(); } System.out.println(i); }} 理论上应该输出100000，但是结果总是比100000小 原因：主线程阻塞，10个子线程互相抢占时间片，i++这种复合操作首先读取i变量，此时被其他线程抢占修改i并写入主存，在回来的时候i还是未修改的状态，导致两次修改相当于一次的 可以通过加synchronized同步锁，保证i++操作时阻塞其他线程，保障原子性 12345678910111213141516171819202122232425262728public class Main { static volatile int i = 0; public static synchronized void increase(){ i++; } public static class PlusTask implements Runnable{ @Override public void run() { for(int k = 0; k &lt; 10000; k++){ increase(); } } } public static void main(String[] args) throws InterruptedException { Thread[] threads = new Thread[10]; for(int i = 0; i &lt; 10; i++){ threads[i] = new Thread(new PlusTask()); threads[i].start(); } for(int i = 0; i &lt; 10; i++){ threads[i].join(); } System.out.println(i); }} 但volatile可以保证数据的可见性和有序性 可见性在server模式下不可行 线程组线程很多，功能分配明确，可以将相同功能的线程放在一个线程组里 123456789101112131415161718192021222324public class ThreadGroupName implements Runnable{ public static void main(String[] args){ ThreadGroup tg = new ThreadGroup(&quot;PrintGroup&quot;);//创建名为PrintGroup的线程组 Thread t1 = new Thread(tg, new ThreadGroupName(), &quot;T1&quot;); Thread t2 = new Thread(tg, new ThreadGroupName(), &quot;T2&quot;); t1.start(); t2.start(); System.out.println(tg.activeCount());//获得活动线程总数 tg.list();//打印线程组所有线程信息 } @Override public void run(){ String groupAndName = Thread.currentThread().getThreadGroup().getName() + &quot;-&quot; + Thread.currentThread().getName(); while(true){ System.out.println(&quot;I am &quot; + groupAndName); try{ Thread.sleep(3000); }catch(InterruptedException e){ e.printStackTrace(); } } }} stop()可以停止线程组中所有线程 守护线程 Daemon在后台默默地完成一些系统性任务：垃圾回收、JIT等 用户线程：工作线程，即完成程序应该要完成的业务操作，守护线程守护工作线程执行 一个Java应用内只有守护线程，Java虚拟机就会自然退出 12345678910111213141516171819202122public class Main { public static class DaemonT extends Thread{ @Override public void run() { while(true){ System.out.println(&quot;I am alive&quot;); try{ Thread.sleep(1000); }catch(InterruptedException e){ e.printStackTrace(); } } } } public static void main(String[] args) throws InterruptedException { Thread t = new DaemonT(); t.setDaemon(true); t.start(); Thread.sleep(2000); }} 必须start之前设置为守护线程 这里只有主线程main为用户线程，2秒后主线程退出时，整个程序也随之结束 线程优先级123public final static int MIN_PRIORITY = 1;public final static int NORM_PRIORITY = 5;public final static int MAX_PRIORITY = 10; java内置三个静态变量表示线程优先级 12high.setPriority(MAX_PRIORITY);low.setPriority(MIN_PRIORITY); 高优先级在大部分情况，都会首先完成任务，但也不一定 synchronized上文volatile模块提到的i++复合操作是线程不安全的 当线程A写入时，B不仅不能写，同时也不能读，A写完之前，B读取的一定是过期数据 synchronized实现线程间的同步，对同步的代码加锁，使得每一次只能有一个线程进入同步块 用法： 指定加锁对象：对给定对象加锁，进入同步代码前要获得给定对象的锁 直接作用于实例方法：对当前实例加锁，进入同步代码前要获得当前实例的锁 直接作用于静态方法：对当前类加锁，进入同步代码前要获得当前类的锁 上文synchronize代码也可以写成如下形式 12345678910111213141516171819public class AccountingSync implements Runnable{ static AccountingSync instance = new AccountingSync(); static int i = 0; @Override public void run(){ for(int j = 0; j &lt; 100000000; j++){ synchronized(instance){ i++; } } } public static void main(){ Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); t1.start();t2.start(); t1.join();t2.join(); System.out.println(i); }} 即直接对实例对象加锁，也可以单独封装i++为一个方法，单独给方法加锁 注意：两个线程操作的是一个实例，这样才能操作一个锁 如果是以下情况 12Thread t1 = new Thread(new AccountingSyncBad());Thread t2 = new Thread(new AccountingSyncBad()); 两个线程指向不同实例，两个线程使用两把不同的锁 但如果将i++封装到静态方法里面然后run方法调用 123public static synchronized void increase(){ i++;} 这样两个实例执行的仍然是同一个类的静态方法，线程间仍然可以同步 隐蔽的错误无提示错误案例123int v1=1073741827;int v2=1431655768;int ave=(v1+v2)/2;//输出-894784850 v1加v2出现一个负数， 在一个复杂系统内部出现该问题，也无任何日志报错，导致问题难以解决 并发下ArrayList12345678910111213141516public class AddThread implements Runnable{ static ArrayList&lt;Integer&gt; al = new ArrayList&lt;Integer&gt;(10); @Override public void run(){ for(int j = 0; j &lt; 2000000; j++){ al.add(i); } } public static void main(){ Thread t1 = new Thread(new AddThread()); Thread t2 = new Thread(new AddThread()); t1.start();t2.start(); t1.join();t2.join(); System.out.println(al.size()); }} t1和t2同时向一个ArrayList中添加容器，可能会得到三种结果 1.正常结束 2.抛出异常（ArrayIndexOutOfBound） 原因：扩容过程中，内部一致性遭到破坏，由于没有锁保护，另一个线程访问到了不一致的内部状态，导致越界 3.隐蔽错误，打印ArrayList大小 11793758 由于多线程访问冲突，两个线程对ArrayList同一位置赋值导致 改进方法：用线程安全的Vector替代ArrayList 并发下HashMap123456789101112131415161718192021222324public class HashMapMultiThread { static Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); public static class AddThread implements Runnable{ int start = 0; public AddThread(int start){ this.start = start; } @Override public void run(){ for(int i = start; i &lt; 100000; i += 2){ map.put(Integer.toString(i), Integer.toBinaryString(i)); } } } public static void main(){ Thread t1 = new Thread(new HashMapMultiThread.AddThread(0)); Thread t2 = new Thread(new HashMapMultiThread.AddThread(1)); t1.start();t2.start(); t1.join();t2.join(); System.out.println(map.size()); }} 三种结果 HashMap大小为100000 小于100000 程序无法结束！！ 原因：HashMap执行put方法的时候，可能会对HashMap进行扩容操作，扩容操作有一步为transfer方法，类似链表操作（Entry），transfer会改变每个元素的next指针，而且使同一hash值的链表元素逆序，两个线程扩容时调用两次transfer方法，导致第一个线程改变next，另一个线程通过该next遍历同一hash值的元素，结果是形成一个闭环结构！！两个key值互为对方的next，导致陷入死循环 解决方法：JDK8不会存在扩容时出现死循环但仍然线程不安全，建议使用ConcurrentHashMap代替HashMap 错误的加锁1234567891011121314151617181920public class BadLockOnInteger implements Runnable{ public static Integer i = 0; static BadLockOnInteger instance = new BadLockOnInteger(); @Override public void run(){ for(int i = 0; i &lt; 10000000; i++){ synchronized(i){ i++; } } } public static void main() throws InterruptedException{ Thread t1 = new Thread(instance); Thread t2 = new THread(instance); t1.start();t2.start(); t1.join();t2.join(); System.out.println(i); }} 即使加锁，i值也比20000000要小 原因：Integer不会被修改，而是new一个新的Integer让i重新指向 因为Integer一直在变，导致synchronized加锁的对象一直在变，而不是自增一个特定的对象 解决方法：加锁对象实例，等一个线程操作完实例的一次i++后，让出锁 123synchronized(instance){ }","link":"/2021/03/31/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"title":"Java高并发程序设计3-2","text":"线程池线程本身占用内存，创建和关闭花费时间 必须在有限范围内增加线程数量，否则会拖垮系统，对系统有害 定义线程复用：需要时从池子中拿一个，完成工作时将线程退回到池子中，方便他人使用 JDKExecutors类：线程池工厂，获取一个具有特定功能的线程池 ThreadPoolExecutor：表示一个线程池，可以调度任何对象 12345678910//返回固定线程池，线程数量不变，提交新任务，若有空闲线程，则立即执行；若没有，则新任务暂存在一个任务队列中，待有空闲线程时执行队列中的任务public static ExecutorService newFixedThreadPool(int nThreads);//返回只有一个线程的线程池，多余任务保存在任务队列中，待线程空闲队列按先入先出执行public static ExecutorService newSingleThreadExecutor();//根据实际情况调整线程数量，提交新任务，空闲则复用，无空闲则创建public static ExecutorService newCachedThreadPool();//计划任务线程池，线程池大小为1，在ExecutorService基础上扩展了在给定时间执行某任务的功能public static ScheduledExecutorService newSingleThreadScheduledExecutor();//指定数量的计划任务线程池public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize); 1.固定大小线程池 123456789101112131415161718192021public class ThreadPoolDemo { public static class MyTask implements Runnable{ @Override public void run() { System.out.println(System.currentTimeMillis() + &quot;:Thread ID:&quot; + Thread.currentThread().getId()); try{ Thread.sleep(1000); }catch (InterruptedException e){ e.printStackTrace(); } } } public static void main(String[] args) { MyTask task = new MyTask(); ExecutorService es = Executors.newFixedThreadPool(5); for(int i = 0; i &lt; 10; i++){ es.submit(task); } }} 给定线程池大小是5，5个线程同时执行，这里提交了10个任务，先执行5个，再执行5个，两者线程是复用的 2.计划任务 可以根据时间需要调度线程 主要方法如下 123public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit);//给定时间任务调度public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit); //对任务周期性调度，任务开始时initialDelay为起点，在之后的period周期时间调度下一次任务public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit);//对任务周期性调度，任务开始时initialDelay为起点，上一个任务结束后再经过delay时间后再进行任务调度 123456789101112ScheduledExecutorService ses = Executors.newScheduledThreadPool(10);ses.scheduleAtFixedRate(new Runnable() { @Override public void run() { try{ Thread.sleep(1000); System.out.println(System.currentTimeMillis()/1000); }catch (InterruptedException e){ e.printStackTrace(); } }}, 0, 2, TimeUnit.SECONDS); 如图，初始0延迟，每2秒执行一次线程任务 问题：如果任务执行时间超过2秒会发生什么？ 答：任务会在上一个任务结束后立即被调用 注意：如果任务改成scheduleWithFixedDelay()执行8秒，周期2秒，任务实际间隔10秒 核心线程池的内部实现以上方法都是ThreadPoolExecutor类的封装 1234567public ThreadPoolExecutor(int corePoolSize,//指定了线程池中的线程数量 int maximumPoolSize,//指定了线程池最大线程数量 long keepAliveTime,//线程池数量超过corePoolSize，多余的线程存活时间 TimeUnit unit,//keepAliveTime单位 BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，被提交但尚未被执行 ThreadFactory threadFactory,//线程工厂 RejectedExecutionHandler handler)//拒绝策略，如何拒绝任务 workQueue是一个BlockingQueue接口的对象，仅用于存放Runnable，根据队列功能分类： 1.直接提交的队列：SynchronousQueue对象提供，没有容量，每插入一个都要等待一个删除操作，反之，每一个删除操作都要等待对应的插入操作，不会保存任务，而直接交给线程执行 2.有界的任务队列：ArrayBlockingQueue，线程数小于corePoolSize，否则加入队列，队列满再创建线程（小于maximumPoolSize） 3.无界的任务队列，LinkedBlockingQueue，线程小于corePoolSize，否则直接入队等待 4.优先任务队列：PriorityBlockingQueue，特殊的无界队列，根据任务优先级顺序先后执行 线程池工作逻辑12345678910111213141516171819public void execute(Runnable command){ if(command == null) throw new NullPointerException(); int c = ctl.get(); if(workerCountOf(c) &lt; corePoolSize){//线程数小于corPoolSize，直接创建线程 if(addWorker(command, true)) return; c = ctl.get(); } if(isRunning(c) &amp;&amp; workQueue.offer(command)){//进入等待队列 int recheck = ctl.get(); if(!isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if(workerCountOf(recheck) == 0) addWorker(null, false); } else if(!addWorker(command, false))//进入等待队列失败（队列满），直接进入线程池，若再失败则拒绝 reject(command);} 拒绝策略AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作 CallerRunsPolicy策略：只要线程池未关闭，直接在调用者线程中运行任务，可能会使性能下降 DiscardOldestPolicy策略：丢弃最老的一个请求（即将被执行的任务），并尝试再次提交当前任务 DiscardPolicy策略：默默地丢弃无法处理的任务 以上策略均实现了RejectedExecutionHandler接口，可以自己扩展 自定义线程池 1234567891011ExecutorService es = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(10), Executors.defaultThreadFactory(), new RejectedExecutionHandler(){ @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor){ System.out.println(r.toString() + &quot; is discard&quot;); } }); 分析：5个常驻线程，最大线程数量是5个，这和固定大小线程池一样，但等待队列容量只有10来保证系统稳定，拒绝策略增加打印信息的小功能 自定义线程创建：ThreadFactory12345678new ThreadFactory(){ @Override public Thread newThread(Runnable r){ Thread t = new Thread(r); t.setDaemon(true); return t; }} 以上自定义线程创建让每个线程都设置为守护线程 扩展线程池扩展目的：监控任务执行的开始时间和结束时间，便于调试 ThreadPoolExecutor可以扩展，自身提供beforeExecute()、afterExecute()、terminated()三个接口用来对线程池进行控制 其在ThreadPoolExecutor.runWorker(Worker w)上实现，其中Worker实例正是工作线程。Worker.run方法调用上述runWorker实现每一个线程的固有工作 ThreadPoolEx重写三个接口 123456789101112131415161718192021ExecutorService es = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingDeque&lt;Runnable&gt;()){ @Override protected void beforeExecute(Thread t, Runnable r) { System.out.println(&quot;准备执行&quot; + ((MyTask) r).name); super.beforeExecute(t, r); } @Override protected void afterExecute(Runnable r, Throwable t) { System.out.println(&quot;执行完成&quot; + ((MyTask) r).name); super.afterExecute(r, t); } @Override protected void terminated() { System.out.println(&quot;线程退出&quot;); super.terminated(); }}; 优化线程池线程数量估算线程池大小：$$N_{cpu} = CPU数量$$ $$U_{cpu}=目标CPU的使用率，0\\le U_{cpu} \\le 1$$ $$W/C = 等待时间与计算时间的比率$$ 为保持处理器达到期望的使用率，最优线程池的大小等于$$N_{threads} = N_{cpu} \\times U_{cpu} \\times (1 + W/C)$$ 1Runtime.getRuntime().availableProcessors()//取得CPU可用数量 线程池中寻找堆栈线程池运行线程时一个线程出错可能会没有任何错误提示 “最鄙视那些出错不打印异常堆栈的行为！” 讨回堆栈 1.放弃submit，改为execute 1pools.executes(new Task()); 2.改造submit方法 12Future re = pools.submit(new Task());re.get(); 两种方法都可以得到部分堆栈信息（异常抛出位置） 如何确定任务提交的位置？ 调度任务前，保存一下提交任务线程的堆栈信息 1234567891011121314151617181920212223242526272829303132333435public class TraceThreadPoolExecutor extends ThreadPoolExecutor { public TraceThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) { super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue); } @Override public void execute(Runnable task) { super.execute(wrap(task, clientTrace(), Thread.currentThread().getName())); } @Override public Future&lt;?&gt; submit(Runnable task) { return super.submit(wrap(task, clientTrace(), Thread.currentThread().getName())); } private Exception clientTrace(){ return new Exception(&quot;Client stack trace&quot;); } private Runnable wrap(final Runnable task, final Exception clientStack, String clientThreadName){ return new Runnable() { @Override public void run() { try{ task.run(); }catch (Exception e){ clientStack.printStackTrace(); throw e;//关键代码，抛出异常，挖出堆栈信息 } } }; }} 如图通过wrap包裹一下submit信息，让异常信息可以被打印出来，不仅得到了异常出现的位置，还得到了任务是哪里提交的，从而得到比较完整的异常信息 分而治之：Fork/Join框架fork：开启线程（子进程）,提交子任务；将任务分解成多个子任务，最终合并所有任务结果 join：等待线程执行完毕，返回结果 ForkJoinPool：分而治之线程池 ForkJoinTask：分而治之任务 RecursiveTask：ForkJoinTask子类，有返回值 RecursiveAction：ForkJoinTask子类，无返回值 123456789101112131415161718192021222324252627@Override//子类重写protected Long compute() { long sum = 0; boolean canCompute = (end - start) &lt; THRESHOLD; if(canCompute){ for(long i = start; i &lt;= end; i++){ sum += i; } }else{ long step = (end + start) / 100; List&lt;CountTask&gt; subTasks = new ArrayList&lt;&gt;(); long pos = start; for(int i = 0; i &lt; 100; i++){ long lastOne = pos + step; if(lastOne &gt; end) lastOne = end; CountTask subTask = new CountTask(pos, lastOne); pos += step + 1; subTasks.add(subTask); subTask.fork();//所有子任务fork } for(CountTask t: subTasks){ sum += t.join();//子任务join方法计算出结果 } } return sum;//RecursiveTask子任务计算有一个返回值} 子任务越多，性能会下降，可能会出现栈溢出异常 Guava对线程池的扩展DirectExecutor线程池 目的：抽象线程池，线程加入后，并没有创建线程，而使其在当前线程中执行 1234public static void main(){ Executor executor = MoreExecutors.directExecutor(); executor.execute(()-&gt;System.out.println(&quot;I am running in&quot; + thread.currentThread.getName()));} 可以注入不同的executor实现，无需修改代码使程序拥有不同行为 Daemon线程池 1MoreExecutors.getExitingExecutorService(executor); 使得后台线程池的存在不会阻止进程结束执行 扩展Future","link":"/2021/04/08/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13-2/"},{"title":"Java高并发程序设计3","text":"JDK并发包本章介绍JDK内部大量实用的框架，主要分为三个方面： 同步控制工具 线程池相关 并发容器 同步控制重入锁1234567891011121314151617181920212223public class ReenterLock implements Runnable{ public static ReentrantLock lock = new ReentrantLock(); public static int i = 0; @Override public void run(){ for(int j = 0; j &lt; 10000000; j++){ lock.lock(); try{ i++; }finally{ lock.unlock(); } } } public static void main(String[] args) trows InterruptedException{ ReenterLock rl = new ReenterLock(); Thread t1 = new Thread(rl); Thread t2 = new Thread(rl); t1.start();t2.start(); t1.join();t2.join(); System.out.println(i); }} 灵活：开发人员必须手动指定何时加锁，何时释放锁（退出临界区时必须释放锁） 重入：一个线程可以连续多次获得锁，但也必须释放相同次数 释放次数多会出现IllegalMonitorStateException异常 释放次数少会使其他线程无法进入临界区 重入锁高级功能1.中断响应 线程等待锁——&gt;获得锁/被中断 通过重入锁实现对等待状态的中断，甚至可以解决死锁问题 1lock.lockInterruptibly(); 通过以上代码，线程等待获得锁，如果两线程请求的锁都被对方占用而无法释放，导致死锁，则会使其中一个线程中断释放资源，防止死锁发生，但最后只有一个线程完成了任务 1lock.isHeldByCurrentThread(); 上述代码表示判断当前线程是否拥有该锁 2.锁申请等待限时 trylock第一个参数是等待时长，第二个时时间单位 123if(lock.tryLock(5,TimeUnit.SECONDS)){ } 该方法可以使锁请求最多等待5秒，如果超过5秒就会自动放弃 tryLock方法也可以无参调用，如果锁未被占用则直接获取，如果被占用则不会等待，直接放弃本次请求，从而解决死锁问题 3.公平锁 非公平锁：锁可用时随机给一个线程 保证先到先得，后到后得，不会产生饥饿现象 1public ReentrantLock(boolean fair) fair为true则为公平锁，公平锁必然要维护一个有序队列，成本高，所以默认非公平 重入锁实现三要素： 原子状态，使用CAS存储锁状态，判断锁是否被别的线程持有 等待队列，没有请求到锁的线程会进入等待队列进行等待，释放锁后会唤醒一个线程 阻塞原语park()和unpark()，用来挂起和恢复线程。没有得到锁的线程将会被挂起 内核或微核提供核外调用的过程或函数称为原语(primitive)。原语是一段用机器指令编写的完成特定功能的程序,在执行过程中不允许中断。 重入锁搭档：Condition类似wait和notify，wait和notify适合与synchronized一起用，Condition与重入锁一起用 通过lock接口的Condition newCondition()方法生成与当前重入锁绑定的Condition实例 让线程在合适时间等待，特定时刻得到通知 1234567void await() throws InterruptedException;//当前线程等待同时释放锁void awaitUninterruptibly();//不会在等待过程中响应中断long awaitNanos(long nanosTimeout) throws InterruptedException;boolean await(long time, TimeUnit unit) throws InterruptedException;boolean awaitUntil(Date deadline) throws InterruptedException;void signal();//唤醒等待线程，重新获得锁void signalAll();//唤醒所有等待线程 Condition功能 123456789101112131415161718192021222324252627public class ThreadLocalExample{ public static class ReenterLockCondition implements Runnable{ static int i = 0; static Condition condition = lock.newCondition(); static ReentrantLock lock = new ReentrantLock(); static ReenterLockCondition instance = new ReenterLockCondition(); @Override public void run(){ try{ lock.lock(); condition.await(); }catch (InterruptedException ie){ ie.printStackTrace(); }finally { lock.unlock(); } } public static void main(String[] args) throws InterruptedException{ Thread t1 = new Thread(condition); t1.start(); Thread.sleep(2000); lock.lock(); condition.signal(); lock.unlock(); } }} await要求线程持有相关重入锁，执行后释放这把锁 signal要求线程先获得相关锁，调用后从Condition对象的等待队列中唤醒一个线程，使之尝试重新获得与之绑定的重入锁，所以signal之后需要通过unlock释放锁才能真正唤醒t1 信号量指定多个线程同时访问某个资源，锁的扩展 1public Semaphore(int permits,@Nullable boolean fair) 其主要逻辑方法 12345public void acquire();//尝试获得一个准入许可，若无法获得则等待，直到有线程释放许可或中断public void acquireUninterruptibly();//不响应中断public boolean tryAcquire();//尝试获得一个许可 成功true 失败falsepublic boolean tryAcquire(long timeout, TimeUnit unit);//限定时间内尝试获得许可public void release()//许可释放 一个acquire对应一个release否则会发生泄露 读写锁JDK5提供的读写分离锁 重写锁和内部锁的读、写都是串行操作，但是读操作并没有破坏数据，所以不合理 读写锁允许多个线程同时读 但是考虑数据完整性，写写操作和读写操作依然需要相互等待和持有锁 读 写 读 非阻塞 阻塞 写 阻塞 阻塞 读操作次数远远大于写操作次数时，读写锁就可以发挥最大功效 123private static ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();private static Lock readLock = readWriteLock.readLock();private static Lock writeLock = readWriteLock.writeLock(); 读写锁分离，使得读操作非常快 倒计数器：CountDownLatch控制线程，让线程等待直到倒计数结束，再开始执行 场景：火箭发射前需要各项准备工作完成 1234567891011121314static final CountDownLatch end = new CountDownLatch(10);@Overridepublic void run(){ try{ end.countDown(); }}main(){ for(int i = 0; i &lt; 10; i++){ exec.submit(demo); } end.await();//等待检查 System.out.println(&quot;Fire！&quot;)} 如图，countDown方法通知CountDownLatch，一个线程完成任务，倒计数减一，任务全部完成后，再点火发射火箭 循环栅栏：CyclicBarrier类似倒计数器，但是有循环特性：如设置为10，第一批10个线程结束后，计数器就会归零，接着凑下一批10个线程 1public CyclicBarrier(int parties, Runnable barrierAction) barrierAction表示一次计数完成后，系统会执行的动作 关键代码 123456private final CyclicBarrier cyclic;//在main函数传参创建//等待所有士兵到齐cyclic.await();doWork();//等待所有士兵完成工作cyclic.await(); 第一次await，每个士兵线程会等待，直到集合完毕，barrierAction会执行一次 第二次await，进行下一次计数，在doWork执行完毕后进行，主要目的是监控是否所有士兵都完成了任务 注意：如果手动中断一个线程，其他9个线程会抛出BrokenBarrierException异常，避免永久无所谓的等待 线程阻塞工具类：LockSupport任意位置线程阻塞，不需要获得某个对象的锁 静态方法park()可以阻塞当前线程 用LockSupport的park和unpark替换掉第二章suspend和resume方法，结果导致程序正常运行！而没有永久挂起 原因：LockSupport类使用了类似信号量的机制，每个线程准备一个许可，如果许可可用，park方法立刻返回，许可变为不可用；如果许可不可用，就会阻塞，而unpark方法使一个许可变得可用 123456run(){ LockSupport.park();//直接调用阻塞线程}main(){ LockSupport.unpark(t1);//直接调用解挂t1阻塞状态，如果unpark发生在park()之前，也可以使下次park()立刻返回} 除了定时阻塞，还可以支持中断影响 123456789101112131415run(){ synchronized(u){ LockSupport.park(); if(Thread.interrupted()){//中断后可以直接响应 System.out.println(getName() +&quot;被中断了&quot;)； } }}main(){ t1.start(); Thread.sleep(100); t2.start(); t1.interrupt();//中断t1,t1执行结束，之后t2才可进入临界区 LockSupport.unpark(t2);} Guava下限流工具RateLimiter对于一个应用来说，每秒能处理的请求是有限的，一旦突破上限，甚至可能压垮系统，因此限流很有必要 漏桶算法：利用一个缓存区，无论请求速率如何，都先进入缓存区保存，然后以固定速率处理请求 令牌桶算法：桶中存放令牌，每个单位时间产生一定量令牌存入桶中，处理程序拿到令牌才可处理请求，而且桶容量有限，桶慢则丢弃令牌 1234567static RateLimiter limiter = RateLimiter.create(2);//每秒生产2个令牌main(){ for(i=0;i&lt;50;i++){ limiter.acquire();//请求令牌 new Thread(new Task()).start(); }} 开50个线程，可能只需半秒，但我们规定一秒只能开2个线程，所以acquire使得过剩的流量等待，直到合适的时候执行 123456for(i=0;i&lt;50;i++){ if(!limiter.tryAcquire()){ continue; } new Thread(new Task()).start();} 也可如上图，通过tryAcquire方法，直接丢弃过载请求，尽可能避免系统崩溃 500ms内所有都可完成，所以这里只有一个输出","link":"/2021/04/07/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"}],"tags":[{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"VUE","slug":"VUE","link":"/tags/VUE/"},{"name":"REACT","slug":"REACT","link":"/tags/REACT/"},{"name":"状态压缩","slug":"状态压缩","link":"/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"},{"name":"Trie树","slug":"Trie树","link":"/tags/Trie%E6%A0%91/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"《深入理解Java虚拟机》","slug":"《深入理解Java虚拟机》","link":"/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/"},{"name":"《高并发程序设计》","slug":"《高并发程序设计》","link":"/tags/%E3%80%8A%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"}],"categories":[{"name":"web前端","slug":"web前端","link":"/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"面试","slug":"面试","link":"/categories/%E9%9D%A2%E8%AF%95/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]}