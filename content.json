{"pages":[{"title":"文章分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/03/01/hello-world/"},{"title":"算法分析1.猜字谜","text":"原题外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。 字谜的迷面 puzzle 按字符串形式给出，如果一个单词 word 符合下面两个条件，那么它就可以算作谜底： 单词 word 中包含谜面 puzzle 的第一个字母。 单词 word 中的每一个字母都可以在谜面 puzzle 中找到。 例如，如果字谜的谜面是 “abcdefg“，那么可以作为谜底的单词有 “faced“, “cabbage“, 和 “baggage“；而 “beefed“（不含字母 “a”）以及 “based“（其中的 “s” 没有出现在谜面中）都不能作为谜底。 返回一个答案数组 answer，数组中的每个元素 answer[i] 是在给出的单词列表 words 中可以作为字谜迷面 puzzles[i] 所对应的谜底的单词数目。 示例1234567891011输入：words = [&quot;aaaa&quot;,&quot;asas&quot;,&quot;able&quot;,&quot;ability&quot;,&quot;actt&quot;,&quot;actor&quot;,&quot;access&quot;], puzzles = [&quot;aboveyz&quot;,&quot;abrodyz&quot;,&quot;abslute&quot;,&quot;absoryz&quot;,&quot;actresz&quot;,&quot;gaswxyz&quot;]输出：[1,1,3,2,4,0]解释：1 个单词可以作为 &quot;aboveyz&quot; 的谜底 : &quot;aaaa&quot; 1 个单词可以作为 &quot;abrodyz&quot; 的谜底 : &quot;aaaa&quot;3 个单词可以作为 &quot;abslute&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;, &quot;able&quot;2 个单词可以作为 &quot;absoryz&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;4 个单词可以作为 &quot;actresz&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;, &quot;actt&quot;, &quot;access&quot;没有单词可以作为 &quot;gaswxyz&quot; 的谜底，因为列表中的单词都不含字母 'g'。 提示1234561 &lt;= words.length &lt;= 10^54 &lt;= words[i].length &lt;= 501 &lt;= puzzles.length &lt;= 10^4puzzles[i].length == 7words[i][j], puzzles[i][j] 都是小写英文字母。每个 puzzles[i] 所包含的字符都不重复。 分析 word和puzzle均为小写字母，即由a~z26个字母组成 每个puzzle长度为7，所包含字符不重复 输出为每个puzzle对应的谜底word个数 要求puzzle含有word中每一个字母，且其中一个为puzzle首字母 类似题型总结：字符串子集的匹配，不重复字符的子集，字符限制为小写或大写 方法一、二进制状态压缩由于words中的word含有重复字母，根据题意不考虑字母的个数，只判断字母的存在性，以此选择合适的表示方法 由于word中只包含小写英文字母a到z，所以word通过26位二进制来表示，0表示不存在，1表示存在 由于只利用的字母的存在性，可能有多个word的二进制表示是相同的，这里通过map来表示每种word的二进制表示的出现次数 题目中要求输出每个puzzle（7位）所匹配的word个数，对puzzle的二进制表示，所以枚举每个puzzle的子集，特别地，该子集一定包含puzzle首字母，关于枚举这里有两个思路： 思路一：枚举6位二进制数来选择puzzle16位所有的字母组合，以此遍历每个puzzle16位的子集，特别地，每次遍历都要加上puzzle第0位（题目要求word中必须有puzzle第0位的字母），代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution { public List&lt;Integer&gt; findNumOfValidWords(String[] words, String[] puzzles) { Map&lt;Integer, Integer&gt; fre = new HashMap&lt;&gt;(); // word的二进制表示 for(String word: words){ int mask = 0; for(int i = 0; i &lt; word.length(); i++){ mask |= 1 &lt;&lt; (word.charAt(i) - 'a'); } if(Integer.bitCount(mask) &lt;= 7){ fre.put(mask, fre.getOrDefault(mask, 0) + 1); } } List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for(String puzzle: puzzles){ int total = 0; // 从000000到111111表示puzzle所有子集的组合形式，遍历这些子集 // (puzzle第1位到第6位的子集，忽略第0位) for(int choose = 0; choose &lt; (1 &lt;&lt; 6); choose++){ int mask = 0; for(int i = 0; i &lt; 6; i++){ // choose表示puzzle子集的一种组合形式，通过&amp;操作来选取数字1对应的单词，0则忽略 if( (choose &amp; (1 &lt;&lt; i)) != 0 ){ mask |= 1 &lt;&lt; (puzzle.charAt(i + 1) - 'a'); } } // 要求谜底word中一定包含puzzle首字母，所以这里单独处理 mask |= 1 &lt;&lt; (puzzle.charAt(0) - 'a'); // 如果puzzle的子集（包含首字母）是谜底word，则将所有该形式加入 if(fre.containsKey(mask)){ total += fre.get(mask); } } ans.add(total); } return ans; }} 思路二：通过的位运算方法来枚举puzzle所有子集，对于puzzle1~6位的二进制表示mask，对subset初始化赋值mask，然后每次迭代进行如下操作： 1subset = (subset - 1) &amp; mask 由于subset中的1之间可能存在0，即不存在的字母和puzzle首位字母，所以对subset-1进行操作时，对subset-1和mask做“与”运算，保证不存在的字母永远不存在，实现了去冗，不断地减1使得subset中的1再次消失或再次出现，且保证subset越来越小，所以巧妙地遍历出所有子集 123456789101112131415161718192021222324252627282930313233 class Solution { public List&lt;Integer&gt; findNumOfValidWords(String[] words, String[] puzzles) { Map&lt;Integer, Integer&gt; fre = new HashMap&lt;&gt;(); for(String word: words){ int mask = 0; for(int i = 0; i &lt; word.length(); i++){ mask |= 1 &lt;&lt; (word.charAt(i) - 'a'); } if(Integer.bitCount(mask) &lt;= 7){ fre.put(mask, fre.getOrDefault(mask, 0) + 1); } } List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for(String puzzle: puzzles){ int total = 0; int mask = 0; //对需要枚举的后六位进行二进制表示 for(int i = 1; i &lt; 7; i++){ mask |= 1 &lt;&lt; (puzzle.charAt(i) - 'a'); } int subset = mask; do{ int s = subset | 1 &lt;&lt; (puzzle.charAt(0) - 'a');//枚举操作和-1操作时只需要固定第0位，所以这里进行单独运算 if(fre.containsKey(s)){ total += fre.get(s); } subset = (subset - 1) &amp; mask; }while(subset != mask);//subset为0时，-1代表所有位都为1，和mask“与”运算的结果必然与mask相等 ans.add(total); } return ans; }}","link":"/2021/03/02/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%901-%E7%8C%9C%E5%AD%97%E8%B0%9C/"}],"tags":[{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"VUE","slug":"VUE","link":"/tags/VUE/"},{"name":"REACT","slug":"REACT","link":"/tags/REACT/"},{"name":"状态压缩","slug":"状态压缩","link":"/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"},{"name":"Trie树","slug":"Trie树","link":"/tags/Trie%E6%A0%91/"}],"categories":[{"name":"web前端","slug":"web前端","link":"/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"后端笔试","slug":"leetcode/后端笔试","link":"/categories/leetcode/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AF%95/"}]}