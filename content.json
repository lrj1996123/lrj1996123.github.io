{"pages":[{"title":"文章分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/03/01/hello-world/"},{"title":"算法分析1.猜字谜","text":"原题外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。 字谜的迷面 puzzle 按字符串形式给出，如果一个单词 word 符合下面两个条件，那么它就可以算作谜底： 单词 word 中包含谜面 puzzle 的第一个字母。 单词 word 中的每一个字母都可以在谜面 puzzle 中找到。 例如，如果字谜的谜面是 “abcdefg“，那么可以作为谜底的单词有 “faced“, “cabbage“, 和 “baggage“；而 “beefed“（不含字母 “a”）以及 “based“（其中的 “s” 没有出现在谜面中）都不能作为谜底。 返回一个答案数组 answer，数组中的每个元素 answer[i] 是在给出的单词列表 words 中可以作为字谜迷面 puzzles[i] 所对应的谜底的单词数目。 示例1234567891011输入：words = [&quot;aaaa&quot;,&quot;asas&quot;,&quot;able&quot;,&quot;ability&quot;,&quot;actt&quot;,&quot;actor&quot;,&quot;access&quot;], puzzles = [&quot;aboveyz&quot;,&quot;abrodyz&quot;,&quot;abslute&quot;,&quot;absoryz&quot;,&quot;actresz&quot;,&quot;gaswxyz&quot;]输出：[1,1,3,2,4,0]解释：1 个单词可以作为 &quot;aboveyz&quot; 的谜底 : &quot;aaaa&quot; 1 个单词可以作为 &quot;abrodyz&quot; 的谜底 : &quot;aaaa&quot;3 个单词可以作为 &quot;abslute&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;, &quot;able&quot;2 个单词可以作为 &quot;absoryz&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;4 个单词可以作为 &quot;actresz&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;, &quot;actt&quot;, &quot;access&quot;没有单词可以作为 &quot;gaswxyz&quot; 的谜底，因为列表中的单词都不含字母 'g'。 提示1234561 &lt;= words.length &lt;= 10^54 &lt;= words[i].length &lt;= 501 &lt;= puzzles.length &lt;= 10^4puzzles[i].length == 7words[i][j], puzzles[i][j] 都是小写英文字母。每个 puzzles[i] 所包含的字符都不重复。 分析 word和puzzle均为小写字母，即由a~z26个字母组成 每个puzzle长度为7，所包含字符不重复 输出为每个puzzle对应的谜底word个数 要求puzzle含有word中每一个字母，且其中一个为puzzle首字母 类似题型总结：字符串子集的匹配，不重复字符的子集，字符限制为小写或大写 方法一、二进制状态压缩由于words中的word含有重复字母，根据题意不考虑字母的个数，只判断字母的存在性，以此选择合适的表示方法 由于word中只包含小写英文字母a到z，所以word通过26位二进制来表示，0表示不存在，1表示存在 由于只利用的字母的存在性，可能有多个word的二进制表示是相同的，这里通过map来表示每种word的二进制表示的出现次数 题目中要求输出每个puzzle（7位）所匹配的word个数，对puzzle的二进制表示，所以枚举每个puzzle的子集，特别地，该子集一定包含puzzle首字母，关于枚举这里有两个思路： 思路一：枚举6位二进制数来选择puzzle16位所有的字母组合，以此遍历每个puzzle16位的子集，特别地，每次遍历都要加上puzzle第0位（题目要求word中必须有puzzle第0位的字母），代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution { public List&lt;Integer&gt; findNumOfValidWords(String[] words, String[] puzzles) { Map&lt;Integer, Integer&gt; fre = new HashMap&lt;&gt;(); // word的二进制表示 for(String word: words){ int mask = 0; for(int i = 0; i &lt; word.length(); i++){ mask |= 1 &lt;&lt; (word.charAt(i) - 'a'); } if(Integer.bitCount(mask) &lt;= 7){ fre.put(mask, fre.getOrDefault(mask, 0) + 1); } } List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for(String puzzle: puzzles){ int total = 0; // 从000000到111111表示puzzle所有子集的组合形式，遍历这些子集 // (puzzle第1位到第6位的子集，忽略第0位) for(int choose = 0; choose &lt; (1 &lt;&lt; 6); choose++){ int mask = 0; for(int i = 0; i &lt; 6; i++){ // choose表示puzzle子集的一种组合形式，通过&amp;操作来选取数字1对应的单词，0则忽略 if( (choose &amp; (1 &lt;&lt; i)) != 0 ){ mask |= 1 &lt;&lt; (puzzle.charAt(i + 1) - 'a'); } } // 要求谜底word中一定包含puzzle首字母，所以这里单独处理 mask |= 1 &lt;&lt; (puzzle.charAt(0) - 'a'); // 如果puzzle的子集（包含首字母）是谜底word，则将所有该形式加入 if(fre.containsKey(mask)){ total += fre.get(mask); } } ans.add(total); } return ans; }} 思路二：通过的位运算方法来枚举puzzle所有子集，对于puzzle1~6位的二进制表示mask，对subset初始化赋值mask，然后每次迭代进行如下操作： 1subset = (subset - 1) &amp; mask 由于subset中的1之间可能存在0，即不存在的字母和puzzle首位字母，所以对subset-1进行操作时，对subset-1和mask做“与”运算，保证不存在的字母永远不存在，实现了去冗，不断地减1使得subset中的1再次消失或再次出现，且保证subset越来越小，所以巧妙地遍历出所有子集 123456789101112131415161718192021222324252627282930313233 class Solution { public List&lt;Integer&gt; findNumOfValidWords(String[] words, String[] puzzles) { Map&lt;Integer, Integer&gt; fre = new HashMap&lt;&gt;(); for(String word: words){ int mask = 0; for(int i = 0; i &lt; word.length(); i++){ mask |= 1 &lt;&lt; (word.charAt(i) - 'a'); } if(Integer.bitCount(mask) &lt;= 7){ fre.put(mask, fre.getOrDefault(mask, 0) + 1); } } List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for(String puzzle: puzzles){ int total = 0; int mask = 0; //对需要枚举的后六位进行二进制表示 for(int i = 1; i &lt; 7; i++){ mask |= 1 &lt;&lt; (puzzle.charAt(i) - 'a'); } int subset = mask; do{ int s = subset | 1 &lt;&lt; (puzzle.charAt(0) - 'a');//枚举操作和-1操作时只需要固定第0位，所以这里进行单独运算 if(fre.containsKey(s)){ total += fre.get(s); } subset = (subset - 1) &amp; mask; }while(subset != mask);//subset为0时，-1代表所有位都为1，和mask“与”运算的结果必然与mask相等 ans.add(total); } return ans; }} 二、Trie树+回溯word中重复字母不考虑，puzzle无重复字母+遍历子集，所以可以采用Trie树方法将words所有单词保存，在每个单词最后一个字母处保存含有相同字母存在的单词个数 接着，遍历puzzles，对每个puzzle，我们需要通过Trie树查找该puzzle的子集，遍历子集的方式采用回溯法，分别考虑当前位置单词和忽略当前位置的下一个单词，特别注意的是，首字母不能忽略 以上对Trie树的操作之前，首先要对word和puzzle进行排序，特别地，puzzle首字母要额外保存 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution { public List&lt;Integer&gt; findNumOfValidWords(String[] words, String[] puzzles) { TrieNode trieNode = new TrieNode(); //word去重并添加入树 for(String word: words){ char[] arr = word.toCharArray(); Arrays.sort(arr); StringBuffer sb = new StringBuffer(); for(int i = 0; i &lt; arr.length; i++){ if(i == 0 || arr[i] != arr[i - 1]){ sb.append(arr[i]); } } add(trieNode, sb.toString()); } List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for(String puzzle: puzzles){ char[] arr = puzzle.toCharArray(); //required表示puzzle的首字母，所以在排序前额外保留 char required = arr[0]; Arrays.sort(arr); ans.add(find(trieNode, required, new String(arr) ,0)); } return ans; } public void add(TrieNode root, String str){ for(int i = 0; i &lt; str.length(); i++){ if(root.child[str.charAt(i) - 'a'] == null){ root.child[str.charAt(i) - 'a'] = new TrieNode(); } root = root.child[str.charAt(i) - 'a']; } root.fre++; } public int find(TrieNode cur, char required, String puzzle, int pos){ if(cur == null){ return 0; } //cur!=null且pos==7的位置，包含puzzle所有子集的情况，cur.fre==0表示当前cur并非叶子结点 if(pos == 7){ return cur.fre; } int ret = find(cur.child[puzzle.charAt(pos) - 'a'], required, puzzle, pos + 1); //如果不是首字母，则额外考虑忽略pos位置字母的情况，不忽略与忽略两种情况相加 if(puzzle.charAt(pos) != required){ ret += find(cur, required, puzzle,pos + 1); } return ret; }}","link":"/2021/03/02/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%901-%E7%8C%9C%E5%AD%97%E8%B0%9C/"},{"title":"算法分析2.俄罗斯套娃信封问题","text":"原题给定二维数组envelopes，其中**envelopes[i] = [$w_i$,$h_i$]**，表示第i个信封的宽度和高度 要求：另一个信封的宽高都比这个信封大，这个信封就可以放进另一个信封里面，如同俄罗斯套娃，接连地一个套一个 计算最多能有多少个信封能组成一组“俄罗斯套娃信封序列” 注意：不允许旋转信封 示例123输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]输出：3解释：最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。 提示1231 &lt;= envelopes.length &lt;= 5000envelopes[i].length == 21 &lt;= wi, hi &lt;= 104 分析 不允许旋转信封，即i套j的条件：$w_i &gt; w_j$ &amp;&amp; $h_i &gt; h_j$ 因为需要分别对w和h进行排序，这里选择先对w升序排序 w已排好序，所以只需要通过判断h大小来进行套娃。但是，如果h也是升序排序，那么会导致同一大小的w中选择多个信封，然而只能从w相同的信封中选择一封 1排完序的结果为[(w,h)]=[(1,1),(1,2),(1,3),(1,4)]，由于这些信封的w值都相同，不存在一个信封可以装下另一个信封，那么我们只能在其中选择 11 个信封。然而如果我们完全忽略w维度，剩下的h维度为[1,2,3,4]，这是一个严格递增的序列，那么我们就可以选择所有的4个信封了，这就产生了错误。 对于w相同的信封只能从中选择一封，通过贪心策略得出，优先选择h小的，才能保证能有更多信封可以套它 方法一、 动态规划将信封的w按照从小到大排序，然后w相同的信封的h按照从大到小排序，这样可以保证对于相同w的信封只能选择其中一封 设f[i]为0~i的最长严格递增子序列的长度， 要求最后的选择为第i个信封，则倒数第二个选择的信封为$j$($j\\lt i$)，遍历j，此时f[j]是已知的，所以如果第j个信封能够套入第i个信封，则0~i的最长递增子序列则为所有f[j]+1当中的最大值 由此得到状态转移公式$$f[i] = \\max\\limits_{j&lt;i \\wedge d_j&lt;d_i}{f[j] + 1}$$得到代码 12345678910111213141516171819202122232425262728293031class Solution { public int maxEnvelopes(int[][] envelopes) { if (envelopes.length == 0) { return 0; } int n = envelopes.length; Arrays.sort(envelopes, new Comparator&lt;int[]&gt;() { public int compare(int[] e1, int[] e2) { if (e1[0] != e2[0]) { return e1[0] - e2[0];//w从小到大排序 } else { return e2[1] - e1[1];//h从大到小排序 } } }); int[] f = new int[n];//f[i]表示0~i可以组成的最大严格递增子序列，且必须选择第i个信封 Arrays.fill(f, 1); int ans = 1; for (int i = 1; i &lt; n; ++i) {//选择第i个元素为最后一个所选择的信封 for (int j = 0; j &lt; i; ++j) {//选择第j个元素为倒数第二个选择的信封 if (envelopes[j][1] &lt; envelopes[i][1]) { f[i] = Math.max(f[i], f[j] + 1);//这里f[i]初始化为1(第i个元素本身)，然后从所有f[j]+1中选择最大值 } } ans = Math.max(ans, f[i]);//所有f当中的最大值即为答案 } return ans; }} 二、 二分查找+贪心算法设f[j]为前i个元素可以组成的最长长度为j的严格递增子序列的末尾元素的h的最小值 贪心思路：让序列上升得尽可能慢 f的性质： f值是严格单调递增的，因为越长的子序列末尾元素显然越大 证明：假设$f[j]\\ge f[i]$且$j\\lt i$ ，从长度为$i$的最长上升子序列末尾删除$i-j$个元素，那么这个序列长度变为j，末尾元素一定比i小，所以$f[j]’\\lt f[i] \\lt f[j] $ 但是f[j]是长度为j的递增子序列的最小值，所以矛盾 末尾元素是可以放的最小值 例如序列[1,2,3,6,4,5]中，1236和1234两个相同长度序列，只有f[3] = 4的时候，序列才可以变得更长 状态转移方法： 考虑当前元素$h_{i}$ $h_i$大于f中的最大值，那么$h_i$就可以接在f最大值之后 否则，从f中比$h_{i}$ 严格小的最大元素$f[j_{0}]$，得到$f[j_{0}]\\lt h_{i} \\lt f[j_{0} + 1]$ ,那么$h_{i} $就可以替换$f[j_{0}+1]$ 可以通过二分查找，找出满足要求的$j_{0}$ 最终f的长度即为最长严格递增子序列的长度 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution { public int maxEnvelopes(int[][] envelopes) { if (envelopes.length == 0) { return 0; } int n = envelopes.length; Arrays.sort(envelopes, new Comparator&lt;int[]&gt;() { public int compare(int[] e1, int[] e2) { if (e1[0] != e2[0]) { return e1[0] - e2[0]; } else { return e2[1] - e1[1]; } } }); List&lt;Integer&gt; f = new ArrayList&lt;Integer&gt;(); f.add(envelopes[0][1]); //主要贪心策略 for (int i = 1; i &lt; n; ++i) { int num = envelopes[i][1]; if (num &gt; f.get(f.size() - 1)) { f.add(num); } else { int index = binarySearch(f, num); f.set(index, num); } } return f.size(); } //二分查找，找到第一个大于target的元素的位置 public int binarySearch(List&lt;Integer&gt; f, int target) { int low = 0, high = f.size() - 1; while (low &lt; high) { int mid = (high - low) / 2 + low; if (f.get(mid) &lt; target) { low = mid + 1; } else { high = mid; } } return low; }} 其他：二分查找变种一、二分查找寻找一个数（基本）123456789101112131415int binarySearch(int[] nums, int target) { int left = 0; int right = nums.length - 1; // 注意，搜索空间为[left,right]的闭区间 while(left &lt;= right) { // 注意，left&gt;right表示搜索空间消失 int mid = (right + left) / 2; if(nums[mid] == target) return mid; else if (nums[mid] &lt; target) left = mid + 1; // 注意，搜索空间变为[mid+1,right] else if (nums[mid] &gt; target) right = mid - 1; // 注意，同上 } return -1;} 二、二分查找寻找左侧边界（最左侧target下标）1234567891011121314151617int left_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0; int right = nums.length; // 注意,搜索空间为[left,right)的左闭右开区间 while (left &lt; right) { // 注意,终止条件为left==right,即[left,left) int mid = (left + right) / 2; if (nums[mid] == target) { right = mid;//nums[mid]虽然等于target，但我们依然要在[left,mid)中搜索来锁定左侧边界 } else if (nums[mid] &lt; target) { left = mid + 1; } else if (nums[mid] &gt; target) { right = mid; // 注意，因为搜索空间是左闭右开，下一步搜索空间应该去掉mid即[left,mid)和[mid+1,right) } } return left;} 三、 二分查找寻找右侧边界（最右侧target下标）123456789101112131415int right_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0, right = nums.length; while (left &lt; right) { int mid = (left + right) / 2; if (nums[mid] == target) { left = mid + 1; // 注意，找到相等元素不要立刻返回，而是继续向右寻找[mid+1,right) } else if (nums[mid] &lt; target) { left = mid + 1; } else if (nums[mid] &gt; target) { right = mid; } } return left - 1; // 注意因为left=mid+1，所以最终left位置不等于target，所以left-1","link":"/2021/03/08/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%902-%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98/"},{"title":"JAVA实习面试经验1.阿里CBU简历评估","text":"问题汇总1.自我介绍 2.项目介绍 做过什么项目？。。。 在团队当中充当了什么角色？后端 遇到了什么困难？数据库设计、业务逻辑设计方面 参考其他什么项目？之前公司的项目 自己在设计方面发挥亮眼的地方……..这里需要 通过E-R图介绍自己项目的数据之间的关系等 Springboot和Spring相比的优势 古德拜 总结复习到的基础知识都没有问0.0 注重项目经验，一定要理清楚项目数据库中的各种设计 分析自己在项目之中发挥的作用，解决的难题 新技术的运用，想办法扯进去一点 后续工作阅读《深入浅出JVM虚拟机》并做笔记 学习spring cloud和kafka","link":"/2021/03/15/JAVA%E9%9D%A2%E8%AF%951/"},{"title":"文献阅读1.《Attention-based LSTM for Aspect-level Sentiment Classification》","text":"","link":"/2021/03/16/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB1-%E3%80%8AAttention-based-LSTM-for-Aspect-level-Sentiment-Classification%E3%80%8B/"},{"title":"深入理解Java虚拟机1","text":"Java内存区域与内存溢出异常Java虚拟机自动内存管理机制，不需要为每个new操作去写配对的delete/free，不容易出现内存泄漏和内存溢出问题。 但是，控制内存的权利交给了Java虚拟机，一旦出现内存泄漏和内存溢出问题，排查错误并修正将会异常艰难。 运行时数据区域程序计数器当前线程所执行字节码的行号指示器：字节码解释器通过改变计数器的值来选取下一条需要执行的字节码指令 程序控制流的指示器：分支、循环、跳转、异常处理、线程恢复等都依赖该计数器 多线程：线程轮流切换，分配处理器执行时间，任何一个确定时刻，一个处理器内核只会执行一条线程中的指令 线程私有：切换线程时，为了能够回到正确位置，每条线程都需要有个独立的程序计数器 虚拟机栈线程私有：生命周期和线程相同 Java方法执行的线程内存模型：方法被执行，Java虚拟机同步创建一个栈帧 JVM创建的栈帧：存储局部变量表、操作数栈、动态连接、方法出口等信息， 每一个方法被调用到执行完毕 &lt;——&gt; 一个栈帧从虚拟机栈入栈到出栈 局部变量表：“栈”存放JVM基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它并不等同于对象本身，而是一个指向对象起始位置的引用指针，也可能指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址） 局部变量槽（Slot）：存储这些数据类型，除了long和double占用2个，其余占用1个 局部变量空间确定：进入一个方法时，局部变量空间大小（变量槽的数量）确定 内存区域异常： StackOverflow异常：线程请求的深度大于虚拟机允许的深度 OutOfMemoryError异常：栈可以动态扩展的虚拟机（Hotspot不会）扩展时无法申请到足够内存会抛出OutOfMemoryError异常 本地方法栈类似虚拟机栈，但本地方法栈为JVM用到的本地方法服务 异常和虚拟机栈类似 Java堆JVM内存最大的一块 所有线程共享 存放对象实例和数组（几乎所有，但不一定，逃逸分析技术、栈上分配、标量替换优化手段导致一些微妙变化） 垃圾回收器管理Java堆（GC堆） 线程私有的分配缓冲区（TLAB）：提升对象分配效率,目的只是更好回收内存，更快分配内存 物理上不连续，逻辑上连续，但大对象可能要求连续 可扩展可固定大小：主流可扩展，没有完成实例分配，堆无法再扩展时，会抛出OutOfMemoryError异常 方法区线程共享 存储JVM加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。 本地空间实现元空间来代替永久代 不需连续内存，可选择固定大小或可扩展，甚至可以选择不实现垃圾收集 回收效果不好，尤其是类型的卸载，但有时又很有必要 OutOfMemoryError 运行时常量池常量池表：编译期生成的各种字面量与符号引用，类加载后存放到方法区的运行时常量池中。 动态性：常量不一定只有编译期才能产生，String intern() OutOfMemoryError 直接内存通道+缓冲区直接操作Native函数库分配堆外内存，通过DirectByteBuffer对象作为这块内存的引用，从而提高性能 HotSpot虚拟机HotSpot虚拟机Java堆中对象的创建检测到字节码new指令 检查new指令的参数能否在常量池中定位到一个类的符号引用 检查该符号引用代表的类是否已被加载，否则必须先执行类加载 类加载检查通过后，虚拟机为新生对象分配内存。（类加载后对象所需内存大小即可完全确定） 给对象分配内存=把一块确定大小的内存从Java堆中划分出来 指针碰撞：假设所有被使用过的内存都放到一边，空闲内存放另一边，指针指向中间的分界点，内存分配就是向空闲内存一边挪动与新生对象大小相等的距离 空闲列表：已被使用的内存和空闲的内存相互交错在一起，虚拟机必须维护一个列表，记录哪些内存块可用，分配时在列表中找一块足够大的空间给对象实例，并更新表上的记录 如何选择分配内存方式？——Java堆是否规整决定 是否规整？——gc是否带有空间压缩整理的能力决定，例如Serail、ParNew能指针碰撞，而CMS基于清除算法，理论上只能空闲列表 对象创建频繁，并发时线程不安全 解决方案： 1.同步处理分配内存空间的动作，采用CAS配上失败重试 2.内存分配的动作按照线程划分在不从空间中进行，即每个线程在Java堆中预先分配一小块内存（本地线程分配缓冲 TLAB），优先使用线程自己的本地缓冲区，只有用完了，分配新缓冲区时才需要同步锁定. 内存分配完成后，分配到的内存空间初始化为0值（不包括对象头），也可TLAB分配之前就初始化，保证可以直接使用这些对象 然后，JVM对对象进行必要设置：哪个类的实例、如何找到元数据信息、对象的哈希码（实际上调用hashCode时才计算）、对象GC分代年龄等信息。这些信息存放在对象头中 对象头设置方式不同：由JVM当前运行状态决定 对象诞生了 但是Java程序的视角，对象创建刚开始——构造函数，new指令跟随invokespecial指令，随后按照程序员的意愿初始化，才将对象创建完毕 对象的内存布局三部分：对象头、实例数据、对齐填充 对象头MarkWord：存储对象自身运行时数据，头信息是与对象自身定义的数据无关的额外存储成本，一个动态定义的数据结构 存储内容 标志位 状态 对象哈希码（25）、对象分代年龄（4） 01 未锁定 指向锁记录的指针（1） 00 轻量级锁定 指向重量级锁的指针（1） 10 膨胀（重量级锁定） 空，不需要记录信息（1） 11 GC标记 偏向线程ID、偏向时间戳、对象分代年龄 01 可偏向 类型指针：指向类型元数据的指针，确定是哪个类的实例。对象数据上不一定保留类型指针。如果是Java数组，对象头还要有一块记录数组长度的数据 实例数据信息 程序代码里面定义的各种类型的字段内容 存储顺序会受分配策略参数和定义顺序影响 默认分配顺序：longs/doubles、ints、shorts/chars、bytes/booleans、oops 相同宽度的字段一起存放 父类定义的变量在子类之前 对齐填充 占位符，HotSpot要求对象起始地址是8字节整数倍 即任何对象大小是8字节整数倍 对象的访问定位reference数据：在栈上，来操作堆上的具体对象 如何定位访问堆中对象具体位置： 1.句柄访问，Java堆中多出一块句柄池，reference存储对象的句柄地址，而句柄包含对象实例数据地址和类型数据的地址信息 2.直接指针访问，reference存储的直接就是对象地址，而需要考虑Java堆中对象的内存布局 句柄的好处：对象被移动时只会改变句柄中的实例数据指针，而不需要修改reference指针 直接指针好处：速度快，HotSpot使用这种，使用Shenandoah手机也会有一次额外转发","link":"/2021/03/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA1/"},{"title":"深入理解Java虚拟机2","text":"垃圾收集器与内存分配策略线程共享区域：Java堆和方法区内存分配和回收不确定性 接口多个实现类，方法执行不同的条件分支，所占用的内存都可能不一样 这些部分内存的分配和回收是动态的，只有处于运行期间才知道 判定对象是否存活引用计数算法简介：对象添加一个引用计数器，每有一个地方引用，计数器加一；引用失效，计数器减一。任何时刻计数器为零的对象就是不能被再使用的 Java没有采用 问题：很多例外情况没有考虑，需要大量额外处理，例如引用计数很难解决对象之间循环引用的问题 可达性分析算法简介：通过一系列称为:”GC Roots”的根对象作为起始节点集，从这些节点的引用关系向下搜索，走过的路径称为引用链，如果对象到GCRoots之间没有引用链相连，证明对象不可能被再使用 Java采用 GCRoots对象 虚拟机栈中引用的对象，各个线程被调用的方法堆栈中用到的参数、局部变量、临时变量等 方法区中类静态属性引用的对象，引用类型静态变量 常量引用的对象，字符串常量池中的引用 本地方法栈中native方法引用的对象 Java虚拟机内部的引用，如基本数据类型对应的class对象，常驻异常对象，还有系统类加载器 所有被同步锁持有的对象 反映虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等等 除了这些，还可根据垃圾回收器以及当前回收的内存区域不同，选择其他对象临时性加入 例如，分代收集和局部回收，局部回收某个内存区域，该可能有其他区域引用该区域，所以将这些关联区域的对象也一并加入GC Roots集合中，保证可达分析正确性 引用reference：存储的数值代表另一块内存的起始地址 希望描述一类对象：内存空间足够时，还能保存在内存中，而紧张时则可以抛弃——缓存 JDK1.2之后，细分了引用概念 强引用：Object obj = new Object() 只要存在则不会被回收 软引用：还有用，但非必须，在溢出异常发生前，会列入回收范围进行二次回收，回收完如果还是内存不足则发生内存溢出异常 弱引用：强度比软引用更弱，描述非必须对象，只能生存到下次垃圾收集发生为止 虚引用：最弱，无法取得对象实例，唯一目的是垃圾回收时收到一个系统通知 判定对象生存还是死亡判定不可达——》被标记——》对标记对象进行一次筛选，条件是是否有必要执行finalize()方法 没有必要或已经被虚拟机调用：视为没有必要执行 有必要执行：置入F-Queue队列，用Finalizer线程（优先级低）调用它们去执行finalize方法，对F-Queue进行第二次小规模标记，只要该对象重新和引用链上任何一个对象建立关联便可存活，从而将其移出“即将回收集合” 回收方法区方法区垃圾收集：废弃的常量和不再使用的类型 判断类型不再被使用的条件： 该类所有实例都已经被回收 加载该类的类加载器已经被回收 该类的java.lang.Class对象没有在任何地方被引用，也无法在任何地方通过反射访问该类的方法 大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，都需要Java虚拟机具备类型卸载能力 垃圾收集算法引用计数式垃圾收集 追踪式垃圾收集（Java用到的） 分代收集理论由假说奠定垃圾收集器设计原则：将Java堆划分不同区域，然后将回收对象依据年龄分配到不同区域中存储。 有了以上原则，便设计出不同区域，针对不同区域安排与里面存储对象存亡特征相匹配的垃圾收集算法 新生代：每次垃圾收集都发现有大批对象死去，而每次回收后存活的少量对象，将会晋升到老年代中存放 老年代：长存区 问题：新生代的对象也可能被老年代所引用（跨代引用），导致垃圾收集新生代对象时可能还遍历老年代，影响性能 跨代引用假说：跨代引用占少数 跨代解决方法：在新生代上建立记忆集，将老年代划分若干小块，标识哪块内存会存在跨代引用，只有包含跨代引用的小块内存里的对象才会被加入到GC Roots中进行扫描 标记-清除算法标记和清除两个阶段 标记：标记所有需要回收的对象 清除：统一回收所有被标记的对象 缺点： 1.Java堆中大量需要被回收的对象，需要进行大量标记和清除动作 2.内存空间碎片化，使得后面需要分配较大对象而无法找到足够的连续内存 标记-复制算法半区复制：内存一分为二，每次只使用其中一块，这一块用完，就将还存活的对象复制到另一块上面，然后把这块一次性清理掉，复制时只需移动堆顶指针顺序分配即可 缺点： 1.内存中大量对象存活，复制开销大（多数对象都是可回收时好用，一般新生代使用） 2.内存缩小为原来的一半，浪费空间 标记-整理算法移动式回收算法，一般老年代使用 让所有存活对象向内存一端移动，然后直接清理掉边界以外的内存 权衡： 1.移动更新所有引用这些对象将会是极为负重的操作，导致停顿 2.如果不移动，碎片化问题只能通过内存分配器和内存访问器解决 从吞吐量来看，移动对象更划算 吞吐量：用户程序和收集器效率总和，不移动导致收集器效率高，但是因内存分配和访问相比垃圾收集频率要高很多，这部分耗时增加，总吞吐量仍然下降 和稀泥解决方法：标记清除，是在碎片化严重时用标记整理 经典垃圾收集器经典=成熟的垃圾收集器， 新生代： Serial（搭配CMS（JDK9）或Serial Old） ParNew（搭配CMS或Serial Old（JDK9）） Parallel Scavenge（搭配Parallel Old或Serial Old） 老年代： CMS Serial Old parallel Old 全堆： G1 Serial收集器垃圾收集时，必须暂停其他所有工作线程 标记-复制算法 Stop The World 缺点：用户不可知的情况下停掉所有线程 优点：简单高效，额外内存消耗最小，没有线程交互的开销 微服务，非频繁收集，收集几十兆或几百兆的新生代的停顿时间也是可以控制在几十毫秒之内的 ParNew收集器Serial收集器的多线程并行版本 除了Serial收集器，目前只有它能与CMS收集器配合工作 JDK9便不再推荐，推荐用G1取代它们，从此称为第一款退出历史舞台的GC 缺点：单核心不如Serial 优点：核心数量增加，有利于系统资源的高效利用 注： 并行：多条垃圾收集器线程之间的关系，表明多条垃圾收集器协同工作，默认此时用户线程等待 并发：垃圾收集器和用户线程之间的关系，表明同一时间垃圾收集器线程和用户线程都在执行，但此时用户线程的吞吐量会受一定影响 Parallel Scavenge收集器达到一个可控制的吞吐量：$$吞吐量=\\frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间}$$MaxGCPauseMillis:回收花费时间上限，越小导致新生代调小，可能导致垃圾收集频繁 GCTimeRatio:1/(1+GCTimeRatio)表示允许最大垃圾收集时间比率 自适应调节策略：虚拟机根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大吞吐量 Serial Old收集器Serial老年代版本，标记-整理算法 意义：供客户端模式下Hotspot虚拟机使用 服务端：JDK5之前与Parallel Scavenge搭配，或作为CMS失败时的后备预案。在并发收集发生Concurrent Mode Failure时使用 Parallel Old收集器标记-整理算法 JDK6之前，PS收集器尴尬状态：新生代选择，则老年代只能选Serial Old，从而拖累PS收集器 有了ParallelOld收集器，PS收集器才有了这个更好的搭配组合 场景：注重吞吐量、处理器资源稀缺 CMS收集器目标：获取最短回收停顿时间 场景：网站服务器，关注服务的响应速度 标记清除算法 收集步骤： 1.初始标记 需要停顿 标记一下GC Roots能直接关联的对象 2.并发标记 从GC Roots直接关联对象开始遍历整个对象图的过程 3.重新标记 需要停顿 为了修正并发标记期间，因用户程序继续运作导致标记产生变动的那一部分对象的标记记录 4.并发清除 清除掉标记阶段判断的已经死亡的对象 缺点： 1.对处理器资源敏感，占用线程导致应用程序变慢 2.无法处理浮动垃圾， 浮动垃圾：并发标记和清理阶段，程序运行产生了新的垃圾对象 它们出现在标记结束后，只能下一次垃圾收集时清理掉，不能清理干净，而且垃圾收集时程序还在执行，所以CMS不能等垃圾满了再收集，垃圾占用内存可能会导致程序无法执行，需要预留内存，如果预留内存不够智能启动备用方案——serial收集器停顿用户线程 3.标记-清除算法导致空间碎片产生，使没有大的连续空间分配对象 Garbage First收集器停顿时间模型：指定在长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒 Mixed GC：面向堆内存任何部分来组成回收集进行回收，衡量标准不再是它属于哪个代，而是哪块内存垃圾数量最多，回收效益最大 基于Region：G1不再坚持固定大小和数量的分代区域划分，而是把连续的Java堆划分成多个大小相等的独立区域。每个Region都可以根据需要扮演Eden Survivor甚至老年代，收集器根据不同Region执行不同策略。Region还有一类Humongous区域，用于存储大对象。 大对象：超过Region一半，1MB~32MB，如果超过Region则存放在连续的Humongous Region中 垃圾收集思路：跟踪各个Region里面垃圾堆积的价值大小，价值：回收所得空间大小以及回收所需时间的经验值。然后在后台维护一个优先级列表，优先处理回收效益大的Region 优点总结：Region划分空间，优先级的区域回收方式 缺点： 1.Region中的跨Region引用，每个Region维护自己的记忆集，记录别的Region指向自己的指针，并记录这些指针分别在哪些卡页范围内，是一种基于哈希表的双向卡表结构，相比传统GC更加占用内存 2.用户线程执行时改变引用关系，不能打破原本对象图结构，G1利用SATB算法保留原来的状态。程序继续运行时对象还要继续创建，每个Region设计两个TAMS指针，新分配对象要两个指针位置之上，该位置默认不纳入回收范围。同理，如果内存回收赶不上内存分配，会发生Full GC导致停顿 3.如何建立可靠地停顿预测模型，衰减均值：比普通平均值更容易受到新数据影响，即最近平均状态，统计状态越新越能决定其回收价值 步骤： 1.初始标记 停顿 标记GCRoots直接关联的对象，并修改TAMS指针的值 2.并发标记 扫描整个堆里的对象图标记，扫描完成，还要处理SATB记录中并发时引用变动的对象 3.最终标记 停顿 处理并发结束后仍遗留的少量SATB记录 4.筛选回收 对各个Region回收价值和成本进行排序，根据用户期望的停顿时间制定回收计划，自由选择多个Region作为回收集，决定回收的那一部分Region的存活对象复制到空的Region中，移动对象要求停顿，多条收集器来完成（整体标记整理算法，局部标记复制算法） 低延迟垃圾收集器Shenandoah收集器ZGC收集器","link":"/2021/03/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA2/"},{"title":"Java高并发程序设计1","text":"重要概念同步和异步形容一次方法调用 同步方法调用一旦开始，调用者必须等待方法调用返回后，才能继续后续的行为 异步方法更像是一个消息传递，一旦开始，方法调用就会立即返回，调用者继续后续工作，而异步方法通常会在另一个线程“真实地”执行。如果需要，异步调用真实完成时，会通知调用者 并发与并行多个任务一起执行 并行：多个任务同时执行 并发：多个任务交替执行，串行执行 临界区一种公共资源或者共享数据，可以被多个线程使用 但一次只能被一个线程使用，一旦临界区资源被占用，其他线程想要使用的话必须等待 阻塞与非阻塞形容多线程之间的相互影响 阻塞：一个线程占用了临界区资源，其他需要该资源的线程就必须在临界区中等待，等待导致线程被挂起 非阻塞：没有线程可以妨碍其他线程执行，所有线程都会不断尝试前向执行 死锁、饥饿和活锁死锁线程需要的资源是另一个线程占用的资源，两两之间形成一个闭环，导致永远无法解除阻塞状态 饥饿线程无法获得所需要的资源，导致一直无法执行 可能因为线程优先级太低导致高优先级线程一直抢占它需要的资源 活锁两个线程都主动将资源释放给对方，导致资源在两线程间跳动，没有一个线程同时拿到所有资源正常执行 并发级别阻塞synchronized或重入锁，得到阻塞线程 试图执行后续代码前，得到临界区的锁，得不到的话线程就会被挂起等待 无饥饿非公平锁：存在优先级高低的线程，导致可能出现饥饿现象 公平锁：先来后到 无障碍多线程一起修改临界区数据，如果数据改坏了会导致回滚 悲观策略：经常冲突，保护共享数据 乐观策略：一般不会冲突，遇到则回滚 但严重冲突导致线程不断回滚自己操作，会影响正常执行。希望至少有一个线程在有限时间完成操作后退出临界区 “一致性标记”：操作前读取，操作完成后再读取，检查标记是否被更改。如果两者一致，说明无冲突，如果不一致，则资源可能在操作过程中与其它写线程冲突，需要重试。任何对资源有修改操作的线程，在修改前都需要更新一致性标记，表示数据不再安全 无锁无障碍，且保证有一个线程在有限步内完成操作离开临界区 特点：无穷循环，尝试修改共享变量，可能会有饥饿问题 无等待无锁，每个线程都必须在有限步内完成 特点：RCU（Read Copy Update），不控制读操作，写数据时先取得原始数据的副本，修改副本数据，在合适时机回写数据 Amadahl定律 加速比由以下公式求出$$T_n = T_1(F + \\frac{1}{n}(1-F))$$ $T_n$表示n个处理器优化后的耗时 $T_1$表示优化前耗时 $F$表示程序中只能串行执行的比例 所以加速比$$加速比=\\frac{1}{F+\\frac{1}{n}(1-F)}$$结论：提高系统速度不能仅仅增加CPU处理器数量，还要根本上修改程序的串行行为，提高系统内可并行化模块比重 Gustafson定律$$加速比=n-F(n-1)$$结论：只要不断累加处理器，就能获得更快的速度 JMMJava内存模型 保证多个线程之间可以有效地、正确地协同工作 JMM特点： 原子性指一个不可中断的操作。一个操作一旦开始，就不会被其他线程干扰 int读写原子性，long不是 可见性当一个线程修改了某个共享变量的值，其他线程是否能够立即知道这个修改 有序性并发时，程序的执行可能出现乱序 原因：可能发生指令重排（指令重排用于减少中断，提升CPU性能） 哪些指令不能重排：Happen-Before规则程序顺序原则：语义串行 volatile原则：volatile变量的写先于读发生 锁原则：解锁必然发生随后的加锁前 传递性：A先于B，B先于C，那么A必然先于C 线程的start()方法先于它的每一个动作 线程所有操作先于线程终结 线程的中断(interrupt())先于被中断线程的代码 对象构造函数的执行、结束先于finalize()方法","link":"/2021/03/30/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A11/"},{"title":"Java高并发程序设计2","text":"线程和进程进程：程序的一次执行过程，是系统进行资源分配和调度的基本单位，是线程的容器 线程：轻量级进程，是程序执行的最小单位，线程间切换和调度成本远小于进程，所以使用多线程进行并发程序设计 线程基本操作新建线程启动12345678910public class CreateThread implements Runnable{ public static void main(String[] args){ Thread t1 = new Thread(new CreateThread()); t1.start(); } @Override public void run(){ System.out.println(&quot;Oh, I am Runnable&quot;); }} 其中启动线程 12Thread t1 = new Thread();t1.start(); start()：新建一个线程并让线程执行run()方法 不要直接调用run()方法，它只会在当前线程中串行执行方法中的代码 线程终止Thread.stop()方法终止线程，被废弃不推荐使用 原因：方法过于暴力，终止时可能并没有完成相关写操作 停止线程方法：在完成run所有写操作时stop,保证不会在setId和setName之间stop 12345678910111213141516171819202122232425262728public class ChangeObjectThread implements Runnable{ volatile boolean stopme = false; public void stopMe(){ stopme = true; } @Override public void run(){ while(true){ if(stopme){ System.out.println(&quot;exit by stop me&quot;); break; } synchronized(u){//u为边缘区变量 int v = (int) (System.currentTimeMillis() / 1000); u.setId(v); try{ Thread.sleep(100); }catch(InterruptedException e){ e.printStackTrace(); } u.setName(String.valueOf(v)); } Thread.yield(); } }} 线程中断线程中断：不会立即退出，而是线程收到一个希望退出的通知，具体何时退出由线程自己决定 123456789101112Thread t1 = new Thread(){ @Override public void run(){ while(true){ if(Thread.currentThread().isInterrupted()){ System.out.println(&quot;Interrupted!&quot;); break; } Thread.yield(); } }} 如图，执行t1.interrupt()方法之后，通知t1被中断，具体何时中断可在while语句内控制 Time.sleep()函数线程休眠若干时间，期间如果中断会抛出InterruptedException中断异常 1234567try{ Thread.sleep(2000);}catch(InterruptedException e){ System.out.println(&quot;Interrupted When Sleep&quot;); //设置中断状态 Thread.currentThread().interrupt();} 注意，捕获中断后，会清除中断标记，这时需要再次设置中断标记位 等待和通知obj.wait()：线程处于等待状态，线程停止运行 进入object对象的等待队列 必须包含在synchronized语句中，执行后会释放锁 obj.notify()：线程结束等待，继续执行 等待队列中随机选择一个线程，将其唤醒（非公平） 无论是wait和notify必须首先获得目标对象的一个监视器（对象锁） T1在wait方法执行前获取监视器，执行后释放，目的是使其他等待在obj对象上的线程不至于因为T1的休眠而全部无法正常执行 T2在notify方法执行前获取监视器，因为T1已经释放监视器，可以顺利获取，执行notify方法后尝试唤醒一个等待线程，这里唤醒T1，唤醒后T1先重新获取监视器（这里需等待T1释放监视器），再继续执行 挂起和继续执行不推荐使用 suspend()线程暂停，不会释放任何锁资源，直到resume()方法之后，线程才会继续 然而如果resume方法意外地发生在suspend之前，就永远不会释放了 推荐使用wait+notify代替suspend和resume 等待线程结束和谦让join()，不加超时参数，表示无限等待，会一直阻塞当前线程，直到目标线程执行完毕 123456789101112131415public class JoinMain{ public volatile static int i=0; public static class AddThread extends Thread{ @Override public void run(){ for(i=0;i&lt;100000;i++); } } public static void main(String[] args) throws InterruptedException{ AddThread at = new AddThread(); at.start(); at.join();//主线程等待AddThread执行完毕 System.out.println(i);//输出100000 }} join方法实现的核心代码 123while(isAlive()){ wait(0);} 使得调用线程（主线程）在被调用线程对象上进行等待，被调用线程执行完毕后，会在退出前调用notifyAll()方法通知所有等待线程继续执行 所以，不要在Thread对象实例上使用类似wait()方法或者notify()方法，会影响系统api工作 yield()：让出CPU，而非结束执行，会继续竞争cpu volatile与JMMvolatile该变量极有可能会被某些程序或线程修改，修改后系统想办法通知给其他线程，保障数据可见性，同时保障操作原子性（有限保障），防止数据被写坏,如之前的long类型，可以通过添加volatile修饰保证不会被写坏 参考： https://blog.csdn.net/u012723673/article/details/80682208 但是，volatile并不能替代锁，无法保证一些复合操作的原子性 如 12345678910111213141516171819202122232425public class Main { static volatile int i = 0; public static class PlusTask implements Runnable{ @Override public void run() { for(int k = 0; k &lt; 10000; k++){ i++; } } } public static void main(String[] args) throws InterruptedException { Thread[] threads = new Thread[10]; for(int i = 0; i &lt; 10; i++){ threads[i] = new Thread(new PlusTask()); threads[i].start(); } for(int i = 0; i &lt; 10; i++){ threads[i].join(); } System.out.println(i); }} 理论上应该输出100000，但是结果总是比100000小 原因：主线程阻塞，10个子线程互相抢占时间片，i++这种复合操作首先读取i变量，此时被其他线程抢占修改i并写入主存，在回来的时候i还是未修改的状态，导致两次修改相当于一次的 可以通过加synchronized同步锁，保证i++操作时阻塞其他线程，保障原子性 12345678910111213141516171819202122232425262728public class Main { static volatile int i = 0; public static synchronized void increase(){ i++; } public static class PlusTask implements Runnable{ @Override public void run() { for(int k = 0; k &lt; 10000; k++){ increase(); } } } public static void main(String[] args) throws InterruptedException { Thread[] threads = new Thread[10]; for(int i = 0; i &lt; 10; i++){ threads[i] = new Thread(new PlusTask()); threads[i].start(); } for(int i = 0; i &lt; 10; i++){ threads[i].join(); } System.out.println(i); }} 但volatile可以保证数据的可见性和有序性 可见性在server模式下不可行 线程组线程很多，功能分配明确，可以将相同功能的线程放在一个线程组里 123456789101112131415161718192021222324public class ThreadGroupName implements Runnable{ public static void main(String[] args){ ThreadGroup tg = new ThreadGroup(&quot;PrintGroup&quot;);//创建名为PrintGroup的线程组 Thread t1 = new Thread(tg, new ThreadGroupName(), &quot;T1&quot;); Thread t2 = new Thread(tg, new ThreadGroupName(), &quot;T2&quot;); t1.start(); t2.start(); System.out.println(tg.activeCount());//获得活动线程总数 tg.list();//打印线程组所有线程信息 } @Override public void run(){ String groupAndName = Thread.currentThread().getThreadGroup().getName() + &quot;-&quot; + Thread.currentThread().getName(); while(true){ System.out.println(&quot;I am &quot; + groupAndName); try{ Thread.sleep(3000); }catch(InterruptedException e){ e.printStackTrace(); } } }} stop()可以停止线程组中所有线程 守护线程 Daemon在后台默默地完成一些系统性任务：垃圾回收、JIT等 用户线程：工作线程，即完成程序应该要完成的业务操作，守护线程守护工作线程执行 一个Java应用内只有守护线程，Java虚拟机就会自然退出 12345678910111213141516171819202122public class Main { public static class DaemonT extends Thread{ @Override public void run() { while(true){ System.out.println(&quot;I am alive&quot;); try{ Thread.sleep(1000); }catch(InterruptedException e){ e.printStackTrace(); } } } } public static void main(String[] args) throws InterruptedException { Thread t = new DaemonT(); t.setDaemon(true); t.start(); Thread.sleep(2000); }} 必须start之前设置为守护线程 这里只有主线程main为用户线程，2秒后主线程退出时，整个程序也随之结束 线程优先级123public final static int MIN_PRIORITY = 1;public final static int NORM_PRIORITY = 5;public final static int MAX_PRIORITY = 10; java内置三个静态变量表示线程优先级 12high.setPriority(MAX_PRIORITY);low.setPriority(MIN_PRIORITY); 高优先级在大部分情况，都会首先完成任务，但也不一定 synchronized上文volatile模块提到的i++复合操作是线程不安全的 当线程A写入时，B不仅不能写，同时也不能读，A写完之前，B读取的一定是过期数据 synchronized实现线程间的同步，对同步的代码加锁，使得每一次只能有一个线程进入同步块 用法： 指定加锁对象：对给定对象加锁，进入同步代码前要获得给定对象的锁 直接作用于实例方法：对当前实例加锁，进入同步代码前要获得当前实例的锁 直接作用于静态方法：对当前类加锁，进入同步代码前要获得当前类的锁 上文synchronize代码也可以写成如下形式 12345678910111213141516171819public class AccountingSync implements Runnable{ static AccountingSync instance = new AccountingSync(); static int i = 0; @Override public void run(){ for(int j = 0; j &lt; 100000000; j++){ synchronized(instance){ i++; } } } public static void main(){ Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); t1.start();t2.start(); t1.join();t2.join(); System.out.println(i); }} 即直接对实例对象加锁，也可以单独封装i++为一个方法，单独给方法加锁 注意：两个线程操作的是一个实例，这样才能操作一个锁 如果是以下情况 12Thread t1 = new Thread(new AccountingSyncBad());Thread t2 = new Thread(new AccountingSyncBad()); 两个线程指向不同实例，两个线程使用两把不同的锁 但如果将i++封装到静态方法里面然后run方法调用 123public static synchronized void increase(){ i++;} 这样两个实例执行的仍然是同一个类的静态方法，线程间仍然可以同步 隐蔽的错误无提示错误案例123int v1=1073741827;int v2=1431655768;int ave=(v1+v2)/2;//输出-894784850 v1加v2出现一个负数， 在一个复杂系统内部出现该问题，也无任何日志报错，导致问题难以解决 并发下ArrayList12345678910111213141516public class AddThread implements Runnable{ static ArrayList&lt;Integer&gt; al = new ArrayList&lt;Integer&gt;(10); @Override public void run(){ for(int j = 0; j &lt; 2000000; j++){ al.add(i); } } public static void main(){ Thread t1 = new Thread(new AddThread()); Thread t2 = new Thread(new AddThread()); t1.start();t2.start(); t1.join();t2.join(); System.out.println(al.size()); }} t1和t2同时向一个ArrayList中添加容器，可能会得到三种结果 1.正常结束 2.抛出异常（ArrayIndexOutOfBound） 原因：扩容过程中，内部一致性遭到破坏，由于没有锁保护，另一个线程访问到了不一致的内部状态，导致越界 3.隐蔽错误，打印ArrayList大小 11793758 由于多线程访问冲突，两个线程对ArrayList同一位置赋值导致 改进方法：用线程安全的Vector替代ArrayList 并发下HashMap123456789101112131415161718192021222324public class HashMapMultiThread { static Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); public static class AddThread implements Runnable{ int start = 0; public AddThread(int start){ this.start = start; } @Override public void run(){ for(int i = start; i &lt; 100000; i += 2){ map.put(Integer.toString(i), Integer.toBinaryString(i)); } } } public static void main(){ Thread t1 = new Thread(new HashMapMultiThread.AddThread(0)); Thread t2 = new Thread(new HashMapMultiThread.AddThread(1)); t1.start();t2.start(); t1.join();t2.join(); System.out.println(map.size()); }} 三种结果 HashMap大小为100000 小于100000 程序无法结束！！ 原因：HashMap执行put方法的时候，可能会对HashMap进行扩容操作，扩容操作有一步为transfer方法，类似链表操作（Entry），transfer会改变每个元素的next指针，而且使同一hash值的链表元素逆序，两个线程扩容时调用两次transfer方法，导致第一个线程改变next，另一个线程通过该next遍历同一hash值的元素，结果是形成一个闭环结构！！两个key值互为对方的next，导致陷入死循环 解决方法：JDK8不会存在扩容时出现死循环但仍然线程不安全，建议使用ConcurrentHashMap代替HashMap 错误的加锁1234567891011121314151617181920public class BadLockOnInteger implements Runnable{ public static Integer i = 0; static BadLockOnInteger instance = new BadLockOnInteger(); @Override public void run(){ for(int i = 0; i &lt; 10000000; i++){ synchronized(i){ i++; } } } public static void main() throws InterruptedException{ Thread t1 = new Thread(instance); Thread t2 = new THread(instance); t1.start();t2.start(); t1.join();t2.join(); System.out.println(i); }} 即使加锁，i值也比20000000要小 原因：Integer不会被修改，而是new一个新的Integer让i重新指向 因为Integer一直在变，导致synchronized加锁的对象一直在变，而不是自增一个特定的对象 解决方法：加锁对象实例，等一个线程操作完实例的一次i++后，让出锁 123synchronized(instance){ }","link":"/2021/03/31/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"title":"Java高并发程序设计3-2","text":"线程池线程本身占用内存，创建和关闭花费时间 必须在有限范围内增加线程数量，否则会拖垮系统，对系统有害 定义线程复用：需要时从池子中拿一个，完成工作时将线程退回到池子中，方便他人使用 JDKExecutors类：线程池工厂，获取一个具有特定功能的线程池 ThreadPoolExecutor：表示一个线程池，可以调度任何对象 12345678910//返回固定线程池，线程数量不变，提交新任务，若有空闲线程，则立即执行；若没有，则新任务暂存在一个任务队列中，待有空闲线程时执行队列中的任务public static ExecutorService newFixedThreadPool(int nThreads);//返回只有一个线程的线程池，多余任务保存在任务队列中，待线程空闲队列按先入先出执行public static ExecutorService newSingleThreadExecutor();//根据实际情况调整线程数量，提交新任务，空闲则复用，无空闲则创建public static ExecutorService newCachedThreadPool();//计划任务线程池，线程池大小为1，在ExecutorService基础上扩展了在给定时间执行某任务的功能public static ScheduledExecutorService newSingleThreadScheduledExecutor();//指定数量的计划任务线程池public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize); 1.固定大小线程池 123456789101112131415161718192021public class ThreadPoolDemo { public static class MyTask implements Runnable{ @Override public void run() { System.out.println(System.currentTimeMillis() + &quot;:Thread ID:&quot; + Thread.currentThread().getId()); try{ Thread.sleep(1000); }catch (InterruptedException e){ e.printStackTrace(); } } } public static void main(String[] args) { MyTask task = new MyTask(); ExecutorService es = Executors.newFixedThreadPool(5); for(int i = 0; i &lt; 10; i++){ es.submit(task); } }} 给定线程池大小是5，5个线程同时执行，这里提交了10个任务，先执行5个，再执行5个，两者线程是复用的 2.计划任务 可以根据时间需要调度线程 主要方法如下 123public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit);//给定时间任务调度public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit); //对任务周期性调度，任务开始时initialDelay为起点，在之后的period周期时间调度下一次任务public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit);//对任务周期性调度，任务开始时initialDelay为起点，上一个任务结束后再经过delay时间后再进行任务调度 123456789101112ScheduledExecutorService ses = Executors.newScheduledThreadPool(10);ses.scheduleAtFixedRate(new Runnable() { @Override public void run() { try{ Thread.sleep(1000); System.out.println(System.currentTimeMillis()/1000); }catch (InterruptedException e){ e.printStackTrace(); } }}, 0, 2, TimeUnit.SECONDS); 如图，初始0延迟，每2秒执行一次线程任务 问题：如果任务执行时间超过2秒会发生什么？ 答：任务会在上一个任务结束后立即被调用 注意：如果任务改成scheduleWithFixedDelay()执行8秒，周期2秒，任务实际间隔10秒 核心线程池的内部实现以上方法都是ThreadPoolExecutor类的封装 1234567public ThreadPoolExecutor(int corePoolSize,//指定了线程池中的线程数量 int maximumPoolSize,//指定了线程池最大线程数量 long keepAliveTime,//线程池数量超过corePoolSize，多余的线程存活时间 TimeUnit unit,//keepAliveTime单位 BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，被提交但尚未被执行 ThreadFactory threadFactory,//线程工厂 RejectedExecutionHandler handler)//拒绝策略，如何拒绝任务 workQueue是一个BlockingQueue接口的对象，仅用于存放Runnable，根据队列功能分类： 1.直接提交的队列：SynchronousQueue对象提供，没有容量，每插入一个都要等待一个删除操作，反之，每一个删除操作都要等待对应的插入操作，不会保存任务，而直接交给线程执行 2.有界的任务队列：ArrayBlockingQueue，线程数小于corePoolSize，否则加入队列，队列满再创建线程（小于maximumPoolSize） 3.无界的任务队列，LinkedBlockingQueue，线程小于corePoolSize，否则直接入队等待 4.优先任务队列：PriorityBlockingQueue，特殊的无界队列，根据任务优先级顺序先后执行 线程池工作逻辑12345678910111213141516171819public void execute(Runnable command){ if(command == null) throw new NullPointerException(); int c = ctl.get(); if(workerCountOf(c) &lt; corePoolSize){//线程数小于corPoolSize，直接创建线程 if(addWorker(command, true)) return; c = ctl.get(); } if(isRunning(c) &amp;&amp; workQueue.offer(command)){//进入等待队列 int recheck = ctl.get(); if(!isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if(workerCountOf(recheck) == 0) addWorker(null, false); } else if(!addWorker(command, false))//进入等待队列失败（队列满），直接进入线程池，若再失败则拒绝 reject(command);} 拒绝策略AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作 CallerRunsPolicy策略：只要线程池未关闭，直接在调用者线程中运行任务，可能会使性能下降 DiscardOldestPolicy策略：丢弃最老的一个请求（即将被执行的任务），并尝试再次提交当前任务 DiscardPolicy策略：默默地丢弃无法处理的任务 以上策略均实现了RejectedExecutionHandler接口，可以自己扩展 自定义线程池 1234567891011ExecutorService es = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(10), Executors.defaultThreadFactory(), new RejectedExecutionHandler(){ @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor){ System.out.println(r.toString() + &quot; is discard&quot;); } }); 分析：5个常驻线程，最大线程数量是5个，这和固定大小线程池一样，但等待队列容量只有10来保证系统稳定，拒绝策略增加打印信息的小功能 自定义线程创建：ThreadFactory12345678new ThreadFactory(){ @Override public Thread newThread(Runnable r){ Thread t = new Thread(r); t.setDaemon(true); return t; }} 以上自定义线程创建让每个线程都设置为守护线程 扩展线程池扩展目的：监控任务执行的开始时间和结束时间，便于调试 ThreadPoolExecutor可以扩展，自身提供beforeExecute()、afterExecute()、terminated()三个接口用来对线程池进行控制 其在ThreadPoolExecutor.runWorker(Worker w)上实现，其中Worker实例正是工作线程。Worker.run方法调用上述runWorker实现每一个线程的固有工作 ThreadPoolEx重写三个接口 123456789101112131415161718192021ExecutorService es = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingDeque&lt;Runnable&gt;()){ @Override protected void beforeExecute(Thread t, Runnable r) { System.out.println(&quot;准备执行&quot; + ((MyTask) r).name); super.beforeExecute(t, r); } @Override protected void afterExecute(Runnable r, Throwable t) { System.out.println(&quot;执行完成&quot; + ((MyTask) r).name); super.afterExecute(r, t); } @Override protected void terminated() { System.out.println(&quot;线程退出&quot;); super.terminated(); }}; 优化线程池线程数量估算线程池大小：$$N_{cpu} = CPU数量$$ $$U_{cpu}=目标CPU的使用率，0\\le U_{cpu} \\le 1$$ $$W/C = 等待时间与计算时间的比率$$ 为保持处理器达到期望的使用率，最优线程池的大小等于$$N_{threads} = N_{cpu} \\times U_{cpu} \\times (1 + W/C)$$ 1Runtime.getRuntime().availableProcessors()//取得CPU可用数量 线程池中寻找堆栈线程池运行线程时一个线程出错可能会没有任何错误提示 “最鄙视那些出错不打印异常堆栈的行为！” 讨回堆栈 1.放弃submit，改为execute 1pools.executes(new Task()); 2.改造submit方法 12Future re = pools.submit(new Task());re.get(); 两种方法都可以得到部分堆栈信息（异常抛出位置） 如何确定任务提交的位置？ 调度任务前，保存一下提交任务线程的堆栈信息 1234567891011121314151617181920212223242526272829303132333435public class TraceThreadPoolExecutor extends ThreadPoolExecutor { public TraceThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) { super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue); } @Override public void execute(Runnable task) { super.execute(wrap(task, clientTrace(), Thread.currentThread().getName())); } @Override public Future&lt;?&gt; submit(Runnable task) { return super.submit(wrap(task, clientTrace(), Thread.currentThread().getName())); } private Exception clientTrace(){ return new Exception(&quot;Client stack trace&quot;); } private Runnable wrap(final Runnable task, final Exception clientStack, String clientThreadName){ return new Runnable() { @Override public void run() { try{ task.run(); }catch (Exception e){ clientStack.printStackTrace(); throw e;//关键代码，抛出异常，挖出堆栈信息 } } }; }} 如图通过wrap包裹一下submit信息，让异常信息可以被打印出来，不仅得到了异常出现的位置，还得到了任务是哪里提交的，从而得到比较完整的异常信息 分而治之：Fork/Join框架fork：开启线程（子进程）,提交子任务；将任务分解成多个子任务，最终合并所有任务结果 join：等待线程执行完毕，返回结果 ForkJoinPool：分而治之线程池 ForkJoinTask：分而治之任务 RecursiveTask：ForkJoinTask子类，有返回值 RecursiveAction：ForkJoinTask子类，无返回值 123456789101112131415161718192021222324252627@Override//子类重写protected Long compute() { long sum = 0; boolean canCompute = (end - start) &lt; THRESHOLD; if(canCompute){ for(long i = start; i &lt;= end; i++){ sum += i; } }else{ long step = (end + start) / 100; List&lt;CountTask&gt; subTasks = new ArrayList&lt;&gt;(); long pos = start; for(int i = 0; i &lt; 100; i++){ long lastOne = pos + step; if(lastOne &gt; end) lastOne = end; CountTask subTask = new CountTask(pos, lastOne); pos += step + 1; subTasks.add(subTask); subTask.fork();//所有子任务fork } for(CountTask t: subTasks){ sum += t.join();//子任务join方法计算出结果 } } return sum;//RecursiveTask子任务计算有一个返回值} 子任务越多，性能会下降，可能会出现栈溢出异常 Guava对线程池的扩展DirectExecutor线程池 目的：抽象线程池，线程加入后，并没有创建线程，而使其在当前线程中执行 1234public static void main(){ Executor executor = MoreExecutors.directExecutor(); executor.execute(()-&gt;System.out.println(&quot;I am running in&quot; + thread.currentThread.getName()));} 可以注入不同的executor实现，无需修改代码使程序拥有不同行为 Daemon线程池 1MoreExecutors.getExitingExecutorService(executor); 使得后台线程池的存在不会阻止进程结束执行 扩展Future","link":"/2021/04/08/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13-2/"},{"title":"Java高并发程序设计3","text":"JDK并发包本章介绍JDK内部大量实用的框架，主要分为三个方面： 同步控制工具 线程池相关 并发容器 同步控制重入锁1234567891011121314151617181920212223public class ReenterLock implements Runnable{ public static ReentrantLock lock = new ReentrantLock(); public static int i = 0; @Override public void run(){ for(int j = 0; j &lt; 10000000; j++){ lock.lock(); try{ i++; }finally{ lock.unlock(); } } } public static void main(String[] args) trows InterruptedException{ ReenterLock rl = new ReenterLock(); Thread t1 = new Thread(rl); Thread t2 = new Thread(rl); t1.start();t2.start(); t1.join();t2.join(); System.out.println(i); }} 灵活：开发人员必须手动指定何时加锁，何时释放锁（退出临界区时必须释放锁） 重入：一个线程可以连续多次获得锁，但也必须释放相同次数 释放次数多会出现IllegalMonitorStateException异常 释放次数少会使其他线程无法进入临界区 重入锁高级功能1.中断响应 线程等待锁——&gt;获得锁/被中断 通过重入锁实现对等待状态的中断，甚至可以解决死锁问题 1lock.lockInterruptibly(); 通过以上代码，线程等待获得锁，如果两线程请求的锁都被对方占用而无法释放，导致死锁，则会使其中一个线程中断释放资源，防止死锁发生，但最后只有一个线程完成了任务 1lock.isHeldByCurrentThread(); 上述代码表示判断当前线程是否拥有该锁 2.锁申请等待限时 trylock第一个参数是等待时长，第二个时时间单位 123if(lock.tryLock(5,TimeUnit.SECONDS)){ } 该方法可以使锁请求最多等待5秒，如果超过5秒就会自动放弃 tryLock方法也可以无参调用，如果锁未被占用则直接获取，如果被占用则不会等待，直接放弃本次请求，从而解决死锁问题 3.公平锁 非公平锁：锁可用时随机给一个线程 保证先到先得，后到后得，不会产生饥饿现象 1public ReentrantLock(boolean fair) fair为true则为公平锁，公平锁必然要维护一个有序队列，成本高，所以默认非公平 重入锁实现三要素： 原子状态，使用CAS存储锁状态，判断锁是否被别的线程持有 等待队列，没有请求到锁的线程会进入等待队列进行等待，释放锁后会唤醒一个线程 阻塞原语park()和unpark()，用来挂起和恢复线程。没有得到锁的线程将会被挂起 内核或微核提供核外调用的过程或函数称为原语(primitive)。原语是一段用机器指令编写的完成特定功能的程序,在执行过程中不允许中断。 重入锁搭档：Condition类似wait和notify，wait和notify适合与synchronized一起用，Condition与重入锁一起用 通过lock接口的Condition newCondition()方法生成与当前重入锁绑定的Condition实例 让线程在合适时间等待，特定时刻得到通知 1234567void await() throws InterruptedException;//当前线程等待同时释放锁void awaitUninterruptibly();//不会在等待过程中响应中断long awaitNanos(long nanosTimeout) throws InterruptedException;boolean await(long time, TimeUnit unit) throws InterruptedException;boolean awaitUntil(Date deadline) throws InterruptedException;void signal();//唤醒等待线程，重新获得锁void signalAll();//唤醒所有等待线程 Condition功能 123456789101112131415161718192021222324252627public class ThreadLocalExample{ public static class ReenterLockCondition implements Runnable{ static int i = 0; static Condition condition = lock.newCondition(); static ReentrantLock lock = new ReentrantLock(); static ReenterLockCondition instance = new ReenterLockCondition(); @Override public void run(){ try{ lock.lock(); condition.await(); }catch (InterruptedException ie){ ie.printStackTrace(); }finally { lock.unlock(); } } public static void main(String[] args) throws InterruptedException{ Thread t1 = new Thread(condition); t1.start(); Thread.sleep(2000); lock.lock(); condition.signal(); lock.unlock(); } }} await要求线程持有相关重入锁，执行后释放这把锁 signal要求线程先获得相关锁，调用后从Condition对象的等待队列中唤醒一个线程，使之尝试重新获得与之绑定的重入锁，所以signal之后需要通过unlock释放锁才能真正唤醒t1 信号量指定多个线程同时访问某个资源，锁的扩展 1public Semaphore(int permits,@Nullable boolean fair) 其主要逻辑方法 12345public void acquire();//尝试获得一个准入许可，若无法获得则等待，直到有线程释放许可或中断public void acquireUninterruptibly();//不响应中断public boolean tryAcquire();//尝试获得一个许可 成功true 失败falsepublic boolean tryAcquire(long timeout, TimeUnit unit);//限定时间内尝试获得许可public void release()//许可释放 一个acquire对应一个release否则会发生泄露 读写锁JDK5提供的读写分离锁 重写锁和内部锁的读、写都是串行操作，但是读操作并没有破坏数据，所以不合理 读写锁允许多个线程同时读 但是考虑数据完整性，写写操作和读写操作依然需要相互等待和持有锁 读 写 读 非阻塞 阻塞 写 阻塞 阻塞 读操作次数远远大于写操作次数时，读写锁就可以发挥最大功效 123private static ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();private static Lock readLock = readWriteLock.readLock();private static Lock writeLock = readWriteLock.writeLock(); 读写锁分离，使得读操作非常快 倒计数器：CountDownLatch控制线程，让线程等待直到倒计数结束，再开始执行 场景：火箭发射前需要各项准备工作完成 1234567891011121314static final CountDownLatch end = new CountDownLatch(10);@Overridepublic void run(){ try{ end.countDown(); }}main(){ for(int i = 0; i &lt; 10; i++){ exec.submit(demo); } end.await();//等待检查 System.out.println(&quot;Fire！&quot;)} 如图，countDown方法通知CountDownLatch，一个线程完成任务，倒计数减一，任务全部完成后，再点火发射火箭 循环栅栏：CyclicBarrier类似倒计数器，但是有循环特性：如设置为10，第一批10个线程结束后，计数器就会归零，接着凑下一批10个线程 1public CyclicBarrier(int parties, Runnable barrierAction) barrierAction表示一次计数完成后，系统会执行的动作 关键代码 123456private final CyclicBarrier cyclic;//在main函数传参创建//等待所有士兵到齐cyclic.await();doWork();//等待所有士兵完成工作cyclic.await(); 第一次await，每个士兵线程会等待，直到集合完毕，barrierAction会执行一次 第二次await，进行下一次计数，在doWork执行完毕后进行，主要目的是监控是否所有士兵都完成了任务 注意：如果手动中断一个线程，其他9个线程会抛出BrokenBarrierException异常，避免永久无所谓的等待 线程阻塞工具类：LockSupport任意位置线程阻塞，不需要获得某个对象的锁 静态方法park()可以阻塞当前线程 用LockSupport的park和unpark替换掉第二章suspend和resume方法，结果导致程序正常运行！而没有永久挂起 原因：LockSupport类使用了类似信号量的机制，每个线程准备一个许可，如果许可可用，park方法立刻返回，许可变为不可用；如果许可不可用，就会阻塞，而unpark方法使一个许可变得可用 123456run(){ LockSupport.park();//直接调用阻塞线程}main(){ LockSupport.unpark(t1);//直接调用解挂t1阻塞状态，如果unpark发生在park()之前，也可以使下次park()立刻返回} 除了定时阻塞，还可以支持中断影响 123456789101112131415run(){ synchronized(u){ LockSupport.park(); if(Thread.interrupted()){//中断后可以直接响应 System.out.println(getName() +&quot;被中断了&quot;)； } }}main(){ t1.start(); Thread.sleep(100); t2.start(); t1.interrupt();//中断t1,t1执行结束，之后t2才可进入临界区 LockSupport.unpark(t2);} Guava下限流工具RateLimiter对于一个应用来说，每秒能处理的请求是有限的，一旦突破上限，甚至可能压垮系统，因此限流很有必要 漏桶算法：利用一个缓存区，无论请求速率如何，都先进入缓存区保存，然后以固定速率处理请求 令牌桶算法：桶中存放令牌，每个单位时间产生一定量令牌存入桶中，处理程序拿到令牌才可处理请求，而且桶容量有限，桶慢则丢弃令牌 1234567static RateLimiter limiter = RateLimiter.create(2);//每秒生产2个令牌main(){ for(i=0;i&lt;50;i++){ limiter.acquire();//请求令牌 new Thread(new Task()).start(); }} 开50个线程，可能只需半秒，但我们规定一秒只能开2个线程，所以acquire使得过剩的流量等待，直到合适的时候执行 123456for(i=0;i&lt;50;i++){ if(!limiter.tryAcquire()){ continue; } new Thread(new Task()).start();} 也可如上图，通过tryAcquire方法，直接丢弃过载请求，尽可能避免系统崩溃 500ms内所有都可完成，所以这里只有一个输出","link":"/2021/04/07/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"title":"Java高并发程序设计3-3","text":"JDK并发容器并发集合ConcurrentHashMap:线程安全的HashMap CopyOnWriteArrayList:线程安全，适合读多写少的场合 ConcurrentLinkedQueue:线程安全的LinkedList BlockingQueue:阻塞队列，适合作为数据共享的通道 ConcurrentSkipListMap:跳表实现，是一个map，可以实现快速查找 此外Vector线程安全，Collection工具类可以帮助我们将任意集合包装成线程安全的集合 线程安全HashMap简单的方法是使用Collections.synchronizedMap(new HashMap())来生成SynchronizedMap，其包装的hashmap是线程安全的 1234SynchronizedMap&lt;k,v&gt;{ private final Map&lt;k,v&gt; m; final Object mutex;} 这里的mutex用来实现对map的互斥操作，例如 123public v get(Object key){ synchronized(mutex){return m.get(key);}} 问题：线程安全但并发级别不高，可以用，但是并发数目多会导致很多线程等待，性能很低 这里使用更专业的ConcurrentHashMap List线程安全ArrayList和Vector都使用数组，区别是ArrayList线程不安全，Vector线程安全 对于LinkedList，这里可以 1public static List&lt;String&gt; l = Collections.synchronizedList(new LinkedList&lt;String&gt;()); ConcurrentLinkedQueue等看第四章再看 CopyOnWriteArrayList读操作数远远大于写，读操作要快，写操作慢一点没关系 目标：写入不会阻塞读取操作（可能会数据不一致），只有写入和写入之间需要的等待 方法：写入操作时自我复制，修改的内容写入副本，写完再用修改的副本替换原数据 读操作 123private E get(Object[] a, int index){ return (E)a[index];} 写操作 1234567891011121314public boolean add(E e){ final ReentrantLock lock = this.lock; lock.lock(); try{ Object[] elements = getArray();//volatile类型变量可以被读线程立刻察觉 int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1);//获取副本 newElements[len] = e; setArray(newElements);//副本覆盖 return true; }finally{ lock.unlock(); }} 数据共享通道：BlockingQueue问题：高并发环境下，多线程间如何数据共享 理解：业主给物业公司意见箱写信提意见，而不是直接找工作人员 意见箱：BlockingQueue线程 ArrayBlockingQueue 队列压入元素：offer()，队列满则返回false；put()，队列满则返等待，直到有空闲位置 队列弹出元素：poll()，队列为空直接返回null；take()，等待，直到队列内有可用元素 等待利用Condition的等待通知机制实现 队列物理上是一个数组，逻辑层面是一个环形结构 跳表（SkipList）作用：快速查找 与平衡树类似，但是平衡树在插入和删除后需要重新一次全局调整，跳表只需局部调整 复杂度：O(logn) 并发条件下：跳表只需一个局部的锁，而平衡树需要全局锁 查询从上层查，如果查到末尾或者下一个元素比目标大，则向下查询 1234567Map&lt;Integer, Integer&gt; map = new ConcurrentSkipListMap&lt;Integer, Integer&gt;();for(int i = 0; i &lt; 30; i++){ map.put(i, i);}for(Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet()){ System.out.println(entry.getKey());} 对跳表的遍历是有序的 所有对node的操作，使用CAS方法 Index类包装Node来组织表结构 每一层表头还需要一个名为HeadIndex数据结构，继承自Index，额外具有level属性表示当前链表第几层","link":"/2021/04/10/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13-3/"},{"title":"Java高并发程序设计4","text":"提高锁性能的建议减少锁持有时间只在必要时进行同步，将不需要做同步的代码块挪出同步控制块 有条件地进行锁申请 减小锁粒度ConcurrentHashMap对于HashMap，get()和put()来说，对整个HashMap加锁，但是加锁粒度太大 ConcurrentHashMap内部细分了若干个小的HashMap，称为**段(SEGMENT)**，默认16个 put操作：根据hashcode得到该表项应该存放在哪个段中，然后对该段加锁并完成操作。只要多个put操作在不同段，就可以并行 减小锁粒度问题：获取全局锁时消耗资源会很多，例如size(),需要访问16个段的锁再求和（实际情况是先使用无锁方式求和，如果失败再加锁），所以ConcurrentHashMap适合获取全局信息方法调用不频繁的并发情况 读写锁替换独占锁分割系统功能点来减小锁粒度 读操作本身不会影响数据完整性和一致性 情况：读多写少的场合 锁分离对于不相干的操作，用不同的锁处理 例如：LinkedBlockingQueue 锁粗化锁细化问题：对同一锁不停请求、同步和释放，本身也会消耗资源 解决方法：锁粗化，对同一个锁不断请求，改为所有锁操作整合成一个锁请求，例如把循环内的锁放到循环外 Java虚拟机锁优化锁偏向线程获得锁-&gt;锁进入偏向模式（对象头MarkWord中CAS更新记录owner）-&gt;该线程再次请求锁，无需同步操作 节省锁申请的操作，提高程序性能 适合场景：几乎没有锁竞争的场合 -XX:+UseBiasedLocking开启偏向锁 轻量级锁与重量级锁相比，不需要申请互斥量 锁偏向请求失败-&gt;将对象头部（Mark Word）CAS更新指向当前线程堆栈内部(锁记录)-&gt;如果指向成功则顺利进入临界区，失败则锁膨胀 锁膨胀：轻的量级锁转为重的量级锁 自旋锁轻量级锁请求失败，则进行最后一次 自旋：当前线程做几次空循环来等待锁释放，若干次循环后，若可以获得锁则进入临界区，若获得不了则挂起 锁消除将无用的锁舍弃 逃逸分析：观察某个变量是否会逃出某个作用域 如果没有，则删除锁，如果有（例如通过返回值逃出），变量有可能被其他线程访问，这样就不能所消除 ThreadLocal简单使用特点：局部变量，只有当前线程可以访问，自然线程安全 12345678910111213141516static ThreadLocal&lt;SimpleDateFormat&gt; tl = new ThreadLocal&lt;SimpleDateFormat&gt;();public static class ParseDate implements Runnable{ int i = 0; public ParseDate(int i){this.i = i;} public void run(){ try{ if(tl.get() == null){ tl.set(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;));//每个线程分配不同的对象，ThreadLocal只是起到线程简单的容器作用，如果分配相同的对象实例，也不能保证线程安全 } Date t = tl.get().parse(&quot;2015-03-29 19:29:&quot; + i%60); System.out.println(i + &quot;:&quot; + t); }catch(ParseExeception e){ e.printStackTrace(); } }} 实现原理ThreadLocal的get和set方法 12345678910111213141516171819public void set(T value){ Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t);//线程私有，保存当前所在线程的所有局部变量，代表一个ThreadLocal变量集合 if(map != null) map.set(this, value);//设置当前线程ThreadLocal的局部变量 else createMap(t, value);}public T get(){ Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t);//线程私有，保存当前所在线程的所有局部变量，代表一个ThreadLocal变量集合 if(map != null){ ThreadLocalMap.Entry e = map.getEntry(this);//根据ThreadLocal自身获取map存储的键值对（ThreadLocal，线程的局部变量） if(e != null){ return (T)e.value; } } return setInitialValue();} 问题：变量保存在每个线程ThreadLocalMap内部，只要线程不退出，对象的引用就一直存在 问题导致：变量（可能是很大的对象）保存到ThreadLocalMap内，线程一直保持启动则变量无法被回收，可能会引发内存泄漏 解决方法： 1ThreadLocal.remove()或obj=null 如果对ThreadLocal设置为null，其对应的所有线程的局部变量都可能被回收（第二次gc） 原因：ThreadLocalMap内部每个Entry都是弱引用类型，如果失去key对应的ThreadLocal强引用，则可能会被回收 ThreadLocal可以提升处理多线程处理相同变量的不同变量值的效率 无锁鉴别线程冲突的乐观策略：比较交换（CAS） 比较变换优点：线程相互影响比锁小，完全没有锁竞争带来的系统开销，也没有线程之间频繁调度的开销 过程： 1234CAS(V,E,N)，V表示要更新的变量，E表示预期值，N表示新值仅当V值等于E值时，才会将V的值设为N，如果V和E不同，说明其他线程已经更新了V，则当前线程什么都不做。最后，CAS返回当前V的真实值多线程CAS操作一个变量，只有一个会胜出，其他失败，失败的线程不会挂起而是被告知失败，允许再次尝试或放弃 无锁的线程安全整数：AtomicIntegerJDK实现了一些CAS操作的线程安全的类型 对其修改的任何操作都是用CAS指令进行 incrementAndGet()内部实现 12345678public final int incrementAndGet(){ for(;;){ int current = get(); int next = current + 1; if(compareAndSet(current, next)) return next; }} 死循环：对于不成功的操作，需要不断尝试 Unsafe封装不安全的操作：指针操作 1public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x); o：给定对象 offset：偏移量，快速定位对象中的字段 expected：期望值 x：要设置的值 它是一个JDK内部使用的专属类，自己的应用程序无法使用 AtomicReference类似AtomicInteger，是一个对象引用的原子类，对其修改可以保证线程安全 CAS问题：线程获取数据，修改前数据被另一个线程修改了两次且第二次改回了旧值，这时线程仍然可以修改该数据。 是否能修改对象数据，不仅取决于当前值，还跟对象的过程变化有关 出问题的场景：老客户回馈活动，贵宾卡余额小于20元，赠送20元，该过程只能一次。CAS操作取出余额19元，增加20元之前被其他线程占用，先增加20元，后又消费了20元，导致CAS检查当前值和期望值相同，都是19元，然后就重复赠送了20元 AtomicStampedReference上述问题原因：对象在修改过程中丢失了状态信息 解决方法：数值被修改时，更新时间戳 CAS操作要求对象值和时间戳都必须满足期望值 AtomicIntegerArray对数组的原子性操作 AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray AtomicIntegerFieldUpdater开闭原则：功能增加是开放的，功能修改时保守的 AtomicIntegerFieldUpdater在极少改动原有代码情况下，让普通变量也享受CAS带来的线程安全性 1234567891011public static class Candidate{ int id; volatile int score;}public final static AtomicIntegerFieldUpdater&lt;Candidate&gt; scoreUpdater = AtomicIntegerFieldUpdater.newUpdater(Candidate.class, &quot;score&quot;);//绑定score变量...new Thread(){ public void run(){ scoreUpdater.incrementAndGet(stu);//使用updater修改Candidate对象实例 }} 注意事项 1.反射获得变量，该变量必须可见 2.变量必须是volatile类型，来保证变量被正确读取 3.CAS操作通过对象实例中的偏移量进行赋值，因此不支持static字段 无锁实现VectorSynchronousQueue实现原理死锁死锁问题：哲学家就餐12345678910synchronized(fork1){ synchronized(fork2){ System.out.println(&quot;哲学家A吃饭&quot;) }}synchronized(fork2){ synchronized(fork1){ System.out.println(&quot;哲学家B吃饭&quot;) }} 两哲学家互相占有对方请求的资源，导致死锁 结果：两线程阻塞 解决方法：使用无锁；通过重入锁的中断或限时等待","link":"/2021/04/12/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/"},{"title":"算法分析3-数组中第k个最大元素","text":"原题在未排序的数组中找到第k个最大的元素。请注意，你需要找的是数组排序后的第k个最大的元素，而不是第k个不同的元素 示例12输入：[3,2,1,5,6,4] 和 k=2输出:5 12输入：[3,2,3,1,2,4,5,5,6] 和 k=4输出:4 分析类似数组第K个最大或最小的题目，直接使用堆排序进行计算 方法堆排序这里使用Java优先级队列实现堆排序 12345678910111213class Solution { public int findKthLargest(int[] nums, int k) { PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(Comparator.reverseOrder()); for(int i = 0; i &lt; nums.length; i++){ pq.offer(nums[i]); } Integer ans = 0; while(k--&gt;0){ ans = pq.poll(); } return ans; }} 基础知识堆排序基本思想：构造大顶堆，将堆顶元素和末尾元素进行交换，然后将剩余n-1个元素重新构造堆，得到n个元素的次大值。如此反复执行即可得到有序序列 步骤一 构造初始堆1.给定一个数组arr 2.从最后一个非叶子节点开始（下标为arr.length-1），从右至左，从下至上进行调整 3.找到第二个非叶节点，重复以上操作 步骤二 堆顶元素与末尾元素交换交换使末尾元素最大。然后继续调整堆 重复步骤二，直至排序完成 12345678910111213141516171819202122232425262728293031323334353637public class HeapSort{ /* * 以i为根节点调整，使该子树节点满足大顶堆要求 */ public static void adjustHeap(int[] arr, int i, int length){ int temp = arr[i]; //取左子节点 for(int k = i*2 + 1; k &lt; length; k = k * 2 + 1){ if(k+1 &lt; length &amp;&amp; arr[k] &lt; arr[k+1]){ k++; } if(arr[k] &gt; temp){ arr[i] = arr[k]; i = k; }else{ break; } } arr[i] = temp; } public static void sort(int[]arr){ //1.构建大顶堆 for(int i = arr.length/2 - 1; i &gt;= 0; i--){ adjustHeap(arr, i , arr.length); } //2.堆顶元素和最后一个元素交换，重新调整n-1个元素，反复此步骤直至有序 for(int j = arr.length - 1; j &gt; 0; j--){ swap(arr, 0, j); adjustHeap(arr, 0, j); } } public static void swap(int[] arr, int i, int j){ int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; }}","link":"/2021/04/20/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%903-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"},{"title":"微服务各种定义","text":"微服务架构特征应用程序逻辑分解为具有明确定义了职责范围的细粒度组件，组件相互协调提供解决方案 每个组件都有一个小的职责领域，并完全独立部署。微服务应该对业务领域的单个部分负责。此外，一个微服务可以跨多个应用程序复用 微服务通信基于一些基本原则（不是标准），并采用HTTP和JSON这样的轻量级通信协议，在服务消费者和服务提供者之间进行数据交换 服务底层采用什么技术实现没有什么影响，因为应用程序始终使用技术中立的协议进行通信。这意味着微服务之上的应用程序可以用多种语言构建 小、独立、分布式的性质，可以组织拥有明确责任领域的小型开发团队。每个团队只负责他们在做的服务 Spring快速引入特点：依赖注入框架，允许用户通过约定将应用程序对象之间的关系外部化，而不是在对象内部彼此硬编码实例化代码，以便轻松管理大型Java项目 Spring Boot：包含Spring核心特性，剥离了Spring中的许多企业特性，而提供了一个基于Java、面向REST的微服务框架，只需要一些简单注解即可快速打包和部署 Spring Cloud：封装了多个流行的云管理微服务框架，实施和部署微服务到私有云或公有云变得简单 Spring Boot微服务处理用户请求首先客户端发送一个HTTP GET或POST等请求到Hello微服务 路由映射：Spring Boot 解析HTTP请求，根据HTTP谓词、URL和URL定义的潜在参数映射路由。路由映射到Spring RestController类中的方法 参数解构：识别出路由后，将路由中定义的所有参数映射到执行该工作的Java方法中 JSON到Java对象映射：对于HTTP PUT和Post请求，在HTTP主体中传递JSON被映射到Java类 业务逻辑执行：映射完主体，Spring Boot就会执行逻辑 Java到JSON对象映射：执行完逻辑，Spring Boot将Java对象转换为JSON 客户端以JSON接收来自服务的响应，成功或失败以HTTP状态码返回 改变构建应用方式的原因 复杂性上升：应用程序不仅需要与多个位于公司数据中心内的【服务和数据库】进行通信，还需要通过互联网，与外部服务提供商的【服务和数据库】进行通信 客户期待更快速的交付：用户期望软件产品的功能被拆分，以便几周或几天内发布新功能 性能和可伸缩性：应用程序可以快速跨多个服务器进行扩大，然后在事务量高峰过去时进行收缩 应用程序可用：某个部分故障不应该导致整个应用程序崩溃 小型的、简单的和解耦的服务=可伸缩的、有弹性的和灵活的应用程序 云基础设施即服务 IaaS 部署虚拟机实例 平台即服务 PaaS 除了基础架构还提供了开发组件，利用组件完成需求 软件即服务 SaaS 服务器在云端，用户访问浏览器即可享受服务 基于云的微服务物理服务器：部署微服务到物理机器，很少有人这么做 虚拟机镜像：快速启动关闭，来响应可伸缩和服务故障事件 虚拟容器：在虚拟机内包装微服务，可以将单个虚拟机隔离成共享相同虚拟机镜像的一系列过程 核心优势——弹性 微服务模式核心微服务开发模式 微服务路由模式 微服务客户端弹性模式 微服务安全模式 微服务日志记录和跟踪模式 微服务构建与部署模式 核心微服务开发模式服务粒度 通信协议 接口设计 服务的配置管理 服务之间的事件处理 微服务路由模式服务发现 服务路由 微服务客户端弹性模式客户端负载均衡 断路器模式 后备模式 舱壁模式 微服务安全模式验证 授权 凭据管理和传播 微服务日志记录和跟踪模式日志关联 日志聚合 微服务跟踪 微服务构建与部署模式不可变基础设施：一旦部署服务，与其运行的基础设施就再也不会被人触碰 保证每个微服务实例与其他微服务实例相同 构建和部署管道 基础设施即代码 不可变服务器 凤凰服务器","link":"/2021/04/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%90%84%E7%A7%8D%E5%AE%9A%E4%B9%89/"},{"title":"深入理解Java虚拟机3","text":"","link":"/2021/04/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA3/"},{"title":"算法分析4-LRU缓存机制","text":"原题运用你所掌握的数据结构，设计实现一个LRU(最近最少使用)缓存机制。 实现LRUCache类： LRUCache(int capacity)以正整数作为容量capacity初始化LRU缓存 int get(int key)如果关键字key存在于缓存中，则返回关键字的值，否则返回-1 void put(int key, int value)如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值流出空间 进阶：在O(1)时间复杂度完成操作 示例1234567891011121314151617输入[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;][[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]输出[null, null, null, 1, null, -1, null, -1, 3, 4]解释LRUCache lRUCache = new LRUCache(2);lRUCache.put(1, 1); // 缓存是 {1=1}lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}lRUCache.get(1); // 返回 1lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}lRUCache.get(2); // 返回 -1 (未找到)lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}lRUCache.get(1); // 返回 -1 (未找到)lRUCache.get(3); // 返回 3lRUCache.get(4); // 返回 4 提示 1 &lt;= capacity &lt;= 3000 0 &lt;= key &lt;= 3000 0 &lt;= value &lt;= 10^4 最多调用3 * 10^4 次 get 和 put 方法哈希表+双向链表 双向链表维护LRU键值对的顺序，靠近头部的键值对是最近使用，靠近尾部是最久未使用 哈希表用于快速定位双向链表中的某个结点，使得查询时间复杂度接近O(1) 这样可以在O(1)时间完成get或set操作 对于get操作，首先判断key是否存在： 如果key不存在，则返回-1 如果key存在，则key对应的节点最近被使用的节点。通过哈希表定位该节点在双向链表中的位置，并将其移动到双向链表头部，最后返回该节点的值 对于put操作，首先判断key是否存在： 如果key不存在，使用key和value创建新节点，双向链表头部添加该节点，并将key和该节点加入到哈希表中。然后判断双向链表节点数是否超出容量，如果超出，则删除双向链表尾部节点，并删除哈希表中对应项 如果key存在，类似get,通过哈希表定位，将对应节点值更新为value，并将该节点移到双向链表头部 小技巧：使用一个伪头部和一个伪尾部，这样就不需要判断相邻节点是否存在了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class LRUCache { class ListNode{ private ListNode left; private ListNode right; private int key; private int value; public ListNode(){ } public ListNode(int key, int value){ this.key = key; this.value = value; } } private ListNode head; private ListNode tail; private int capacity; private Map&lt;Integer, ListNode&gt; map; public LRUCache(int capacity) { head = new ListNode();//伪头部 tail = new ListNode();//伪尾部 this.capacity = capacity; head.right = tail; tail.left = head; map = new HashMap&lt;&gt;(); } public int get(int key) { //存在key，将key移动到头部 if(map.containsKey(key)){ ListNode node = map.get(key); moveToHead(node); return node.value; } return -1; } public void put(int key, int value) { //存在key，移动到头部并修改 if(map.containsKey(key)){ ListNode node = map.get(key); node.value = value; moveToHead(node); }else{ //不存在key，则新建节点插入到头部 ListNode node = new ListNode(key, value); map.put(key,node); addToHead(node); //对capacity的改变，只需要在put新节点时执行即可，get和key存在时put 虽然也有节点删除操作，但是不影响个数 capacity--; if(capacity &lt; 0){ //超出容量，则删除最少使用节点 ListNode lruNode = removeTail(); map.remove(lruNode.key); capacity++; } } } //将最近使用节点添加到头部 private void addToHead(ListNode node){ node.left = head; node.right = head.right; head.right.left = node; head.right = node; } //删除节点 private void removeNode(ListNode node){ node.left.right = node.right; node.right.left = node.left; } //将最近使用节点移动到头部 private void moveToHead(ListNode node){ removeNode(node); addToHead(node); } //删除最久未使用节点 private ListNode removeTail(){ ListNode node = tail.left; removeNode(node); return node; }}","link":"/2021/04/23/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%903-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"},{"title":"Spingboot构建微服务","text":"传统瀑布方法特征紧耦合的 有漏洞的 单体的 微服务架构特征有约束的 松耦合的 抽象的 独立的 基于云的应用程序特征拥有庞大而多样化的用户群 极高的运行时间要求 不均匀的容量需求 微服务开发的三个角色架构师——设计微服务架构 软件开发人员—— DevOps工程师—— 设计微服务架构（1）分解业务问题 （2）建立服务粒度 （3）定义服务接口 分解业务问题一个事务可能包含跨业务领域的一组微服务 分离业务领域的指导方针（1）描述业务问题，并聆听描述问题的名词 （2）注意动词 （3）寻找数据内聚 建立服务粒度将功能部件提取完全独立的单元中 不只重新打包代码，还要单独梳理实际数据库表，只允许每个单独的服务访问其特定域的表 建立服务粒度的思想： （1）开始时让微服务涉及范围广一些，然后将其重构到更小的服务 （2）重点关注服务如何交互 （3）随着对问题域理解的不断增长，服务的职责将随着时间的推移而改变 粒度过粗过细都会有问题 定义服务接口指导方针 （1）拥抱REST的理念 （2）使用URI穿搭意图 （3）请求和响应使用JSON （4）使用HTTP状态码传达结果 不应该使用微服务的场景构建分布式系统的复杂性服务器散乱应用程序类型数据事务和一致性用SpringBoot和Java构建微服务两个类： 1.Spring引导类，启动和初始化应用 2.Spring控制器类，公开可以被微服务调用的HTTP端点 编写引导类123456@SpringBootApplicationpublic class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args);//启动Spring容器 }} 1234JavaBean的定义1、用@Component、@Service或@Repository注解标签来标注一个Java类2、用@Configuration标注然后可以在每一个调用@Bean实现自动装配 SpringBoot控制器12345遵循REST■ 使用HTTP作为服务的调用协议■ 服务的行为映射到标准HTTP动词■ 使用JSON作为进出服务的所有数据序列化格式■ 使用HTTP状态码传达服务调用状态 12345@RestController//基于REST的服务，自动序列化/反序列化服务请求响应到JSON，包含了ResponseBody注解@RequestMapping(value=&quot;v1/organizations/{organizationId}/licenses&quot;)public class LicenseServiceController { ...} JSON：轻量级序列化协议，是JS默认的，天然适用REST的应用程序 12345678910@RequestMapping(value=&quot;/{licenseId}&quot;,method = RequestMethod.GET)public License getLicenses( @PathVariable(&quot;organizationId&quot;) String organizationId, @PathVariable(&quot;licenseId&quot;) String licenseId) { return new License() .withId(licenseId) .withOrganizationId(organizationId) .withProductName(&quot;Teleco&quot;) .withLicenseType(&quot;Seat&quot;) .withOrganizationId(&quot;TestOrg&quot;);} 1234@RequestMapping用于绑定Controller中的方法，传入value和method两个参数其中该类的value与该方法上的value拼接得到该请求的端点method定义REST请求的类型，此处为GET@PathVariable将value中带{}的参数，即url中的参数映射过来 POSTMAN测试得到JSON返回值 构建运行时的严谨性1234■ 服务装配■ 服务引导■ 服务注册/发现■ 服务监控","link":"/2021/05/06/Spingboot%E6%9E%84%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"title":"Spring Cloud配置服务器控制配置","text":"云的微服务 1.应用程序的配置与正在部署的实际代码完全分离 2.构建服务器、应用程序以及一个不可变的镜像，在其各自环境中启动后不可变 3.启动时通过环境变量注入应用程序配置，或通过集中式存储库读取应用程序配置 管理配置遵循四条基本原则 （1）分离，服务配置信息与服务的实际物理部署完全分离 （2）抽象，访问配置数据的功能抽象到一个接口中 （3）集中，配置信息集中在尽可能少的存储库中 （4）稳定，保证高可用和冗余 关键的，配置数据也需要跟踪和版本控制 配置管理概念架构（1）一个实例启动，调用一个服务端点读取其特定配置信息，配置管理的连接信息将在微服务启动时传递给微服务 （2）实际的配置信息驻留在存储库中 （3）配置数据管理与应用程序的部署方式无关 （4）配置管理更改时，必须通知已经使用该配置的应用程序服务，并刷新应用程序数据的副本 实施选择 项目 描述 特点 Etcd Go开发，服务发现和键值管理，Raft协议 非常快、可伸缩 可分布式 命令行驱动 易于搭建和使用 Eureka Netflix开发，用于服务发现和键值管理 分布式键值存储 灵活 设置费劲 开箱即用的动态客户端刷新 Consul 与上两个类似，SWIM协议 快速 本地服务发现，直接与DNS集成，没有开箱即用的动态客户端刷新 ZooKeeper 提供分布式锁定功能的Apache项目 使用最复杂，最古老的，用于配置管理，只有在其他架构中使用了ZooKeeper的时候才考虑使用它 Spring Cloud Config 开源项目，提供不同后端的通用配置管理解决方案，可将Git、Eureka和Consul作为后端进行整合 非分布式，提供对Spring和非Spring集成，多个后端来存储配置数据，包括共享文件系统、Eureka、Consul和Git 最终选择Spring Cloud配置服务器，原因： 1234易于搭建与Spring Boot紧密集成提供多个后端存储配置，可以将Eureka和Consul等工具直接插入可直接与Git源控制平台集成，使程序版本化 后续工作 创建Spring Cloud配置服务器，演示两种机制提供应用程序配置数据，一种是文件系统，另一种使用Git存储库 继续构建许可证服务，以从数据库检索数据 Spring Cloud配置服务挂钩（hook）到许可证服务，以提供应用程序的配置数据 构建Spring Cloud配置服务器建立在SpringBoot之上而不是独立的服务器 如图，新建confsvr项目目录，其中pom.xml的maven文件用于拉取启动配置服务器所需的JAR 1&lt;dependencyManagement&gt;用于声明依赖版本，而非引入依赖，其子模块通过&lt;dependencies&gt;引入依赖时按照该声明选择依赖的版本，即声明的依赖为父物料清单(BOM),而不必为子依赖项声明版本号 上图确定了Springboot和SpringCloud的版本 上图实现了子依赖引入，但为声明版本，版本继承自BOM 然后通过创建application.yml端口信息以及从哪里找到用于提供配置信息的后端 然后需要将服务器指向保存配置数据的后端存储库 为3个环境创建配置数据：默认环境、开发环境、生产环境 需要为每个环境提供一个属性文件，文件包含： 许可证服务直接使用的数学 存储许可证服务数据的Postgres数据库配置 该配置服务器使得环境名称直接转换为URL 1234应用程序名称-环境名称.yml，将其公开为基于HTTP的端点licensingservice.yml 为/licensingservice/defaultlicensingservice-dev.yml 为/licensingservice/devlicensingservice-prod.yml 为/licensingservice/prod 大型云应用不推荐文件系统，而推荐Git方式配置存储库，因为共享文件系统服务器需要人员维护 创建Spring Cloud Config引导类@EnableConfigServer使服务成为Spring Cloud Config服务 使用带有文件系统的Spring Cloud配置服务器在application.yml中配置存储库 路径为配置文件路径 浏览器访问localhost:8888/licensingservice/default看到licensingservice.yml中的所有属性 如果想看licensingservice-dev.yml，访问localhost:8888/licensingservice/dev即可 将Spring Cloud Config与Spring Boot客户端集成许可证服务（客户端）启动，通过命令行传递两条信息： 1.Spring的profile 2.服务与Spring Cloud配置服务通信的端点 （http://localhost:888） 根据给定URI，使用已配置的后端配置存储库检索相应配置，然后将相应配置属性传回许可证服务 对Spring Cloud Config服务器的依赖12345678910111213 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;postgresql&lt;/groupId&gt; &lt;artifactId&gt;postgresql&lt;/artifactId&gt; &lt;version&gt;9.1-901.jdbc4&lt;/version&gt; &lt;/dependency&gt; 客户端添加这些依赖用于作为JPA包、SpringCloud的客户端以及数据库驱动 配置许可证服务以使用Spring Cloud Config然后需要告知许可证服务在哪里与Spring Cloud配置服务器进行联系 根据bootstrap.yml和application.yml两者之一进行配置 这里选择bootstrap用于配置Spring Cloud Config 而application.yml用于本地配置 123456789spring: application: name: licensingservice//应用程序名称，也是配置服务器中目录的名称 profiles: active: default//配置数据机制 cloud: config: uri: http://localhost:8888//URI，配置服务器端点位置 可以通过修改启动参数来覆盖这些配置 123java -Dspring.cloud.config.uri = http://localhost:8888 \\ -Dspring.profiles.active=dev \\ -jar target/licensing-service-0.0.1-SNAPSHOT.jar 通过-D系统属性来覆盖 如果想要覆盖配置服务器中的配置，则需要启动VM实例或Docker容器并传入环境变量 docker-compose.yml中 123456789licensingservice: image: ch3-thoughtmechanix/licensing-service ports: - &quot;8080:8080&quot; environment: PROFILE: &quot;dev&quot; CONFIGSERVER_URI: &quot;http://configserver:8888&quot;//配置服务器地址，服务从这里读取配置 CONFIGSERVER_PORT: &quot;8888&quot; DATABASESERVER_PORT: &quot;5432&quot; 然后便可在docker的run.sh中调用这些环境变量以启动 12345678910111213141516171819#!/bin/shecho &quot;********************************************************&quot;echo &quot;Waiting for the configuration server to start on port $CONFIGSERVER_PORT&quot;echo &quot;********************************************************&quot;while ! `nc -z configserver $CONFIGSERVER_PORT `; do sleep 3; doneecho &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Configuration Server has started&quot;echo &quot;********************************************************&quot;echo &quot;Waiting for the database server to start on port $DATABASESERVER_PORT&quot;echo &quot;********************************************************&quot;while ! `nc -z database $DATABASESERVER_PORT`; do sleep 3; doneecho &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Database Server has started&quot;echo &quot;********************************************************&quot;echo &quot;Starting License Server with Configuration Service : $CONFIGSERVER_URI&quot;;echo &quot;********************************************************&quot;java -Dspring.cloud.config.uri=$CONFIGSERVER_URI -Dspring.profiles.active=$PROFILE -jar /usr/local/licensingservice/@project.build.finalName@.jar 通过http://localhost:8080/env来获取有关服务的所有配置信息 但有组织认为，这个端点太危险，因为暴露了太多信息，如何实现安全策略可参考《Spring Boot 实战》 使用Spring Cloud配置服务器连接数据源在许可证微服务中构建数据库连接相关的model、Service和Repository odel用于构造JPA模型,以便Repository执行sql语句前后的映射和注入 Service用于业务逻辑实现 Repository根据JPA实现基于名称的SQL语句 使用@Value注解直接读取属性通过@Value可将数据库配置数据直接注入到对象当中 1234567891011@Componentpublic class ServiceConfig{ @Value(&quot;${example.property}&quot;) private String exampleProperty; public String getExampleProperty(){ return exampleProperty; }} 通过getExampleProperty方法可直接获取该数据 使用Spring Cloud配置服务器和Git将文件系统改为Git 123456789101112server: port: 8888spring: cloud: config: server: encrypt.enabled: false git: uri: https://github.com/carnellj/config-repo/ //存储库URL searchPaths: licensingservice,organizationservice //服务的相对路径，用逗号分割 username: native-cloud-apps password: 0ffended 使用Spring Cloud配置服务器刷新属性Spring Boot Actuator提供了@RefreshScope注解，允许开发团队访问/refresh端点，强制应用重新读取配置 12345678@SpringBootApplication@RefreshScope//访问/refresh即可实现刷新public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); }} 1234同一服务的多个实例，需要刷新所有这些服务，以下有三种方案：Spring Cloud Bus的“推送机制”，向所有客户端发送修改的配置信息，需要额外的RabbitMQ中间件允许Spring Service Discovery和Eureka通过编写一个简单的脚本来查询服务发现引擎来查找服务的所有实例重新启动所有服务器，通过Docker可以实现 保护敏感配置信息（1）下载并安装加密所需的Oracle JCE jar （2）创建加密秘钥 （3）加密和解密属性 （4）配置微服务以在客户端使用加密 下载安装Oracle JCE jar 将$JAVA_HOME/jre/lib/security目录中的local_policy.jar和US_export_policy.jar备份到其他位置 下载JCE Zip 解压并将local_policy.jar和US_export_policy.jar复制到$JAVA_HOME/jre/lib/security目录中 配置加密 1这里dockerfile已经通过curl拉取了JCE的zip，并将jar包复制到Docker容器中/usr/lib/jvm/java-1.8-openjdk/jre/lib/security目录下 创建加密秘钥1export ENCRYPT_KEY=IMSYMMETRIC 12实际环境，应为每个环境使用单独加密密钥该项目使用Dockefile硬编码该命令 加密和解密端点/encrypt和/decrypt分别可以加密或解密属性 直接在Github或文件系统的配置文件中使用 1spring.datasource.password:&quot;{cipher}加密字符串&quot; {cipher}使得Spring Cloud服务器处理该加密的值，从而直接在/licensingservice/default得到了明文信息 配置微服务以在客户端使用加密1.不要在服务器端解密属性 2.在许可证服务器（微服务）上设置对称密钥 3.将spring-security-rsa JAR添加到许可证服务的pom.xml文件中 首先禁用服务器端的解密 12345spring: cloud: config: server: encrypt.enabled: false 然后在许可证服务的配置文件上设置对称密钥，使得ENTRYPT_KEY环境变量与Spring Cloud Config服务器上使用的对称密钥相同 接着增加spring-security-rsa依赖 然后便可以观察到敏感属性不再以未加密形式返回，相反该属性将由调用服务解密","link":"/2021/05/08/Spring-Cloud%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A7%E5%88%B6%E9%85%8D%E7%BD%AE/"},{"title":"服务发现","text":"服务发现 1.水平伸缩，抽象服务部署，使它们远离消费者 2.移除不健康或不可用的实例，提高应用程序弹性 服务的位置非云架构：DNS和网络负载均衡器访问多个服务器的应用程序资源 不适用于云的微服务的原因： 单点故障，负载均衡器本身可能出现故障，从而导致每个依赖它的应用程序出现故障 有限水平可伸缩性，服务集中到单个负载均衡器上，容量固定，水平伸缩能力有限 静态管理，传统负载均衡器不能做到快速注册和注销，添加新路由需要通过供应商专有的API进行添加 复杂，请求映射到物理服务，为服务基础设施增加一层复杂度，而映射规则需要开发人员手动定义和部署，而不是在新服务实例启动时自动完成 云中的服务发现 高可用，一个结点不可用，其他结点接管工作 点对点，每个结点共享服务实例的状态 负载均衡，所有服务实例之间动态地对请求进行负载均衡 有弹性，本地缓存服务信息，如果服务发现功能不可用，可根据本地缓存维护的信息来运行和定位服务 容错，检测不健康服务，从可用服务列表中移除该实例 服务发现架构 服务注册 服务地址的客户端查找 信息共享 健康检测 服务发现模式客户端应用程序——&gt;[服务发现节点1,发现节点2,…,发现节点N（节点之间共享实例状态）]&lt;——(心跳包)服务实例 这种方法很脆弱，因为客户端完全依赖服务发现引擎查找或调用服务 基于客户端负载均衡的服务发现模式服务发现获取所有服务实例，然后在客户端缓存数据 每当客户端调用服务，从缓存中查找服务位置，这里使用负载均衡选择 客户端定期与服务发现服务进行联系，刷新实例缓存 如果服务调用失败，那么本地服务发现缓存失效，然后重新从服务发现获取服务信息 使用Spring和Netflix Eureka进行服务发现实战任务：代理注册两个服务，通过服务发现检索到的信息，让一个服务调用另一个服务（许可证服务调用时，调用组织服务检索与指定组织ID相关联的组织信息） 工具：Spring Cloud、Eureka、Ribbon 场景：许可证服务、组织服务 本例使用服务发现注册表注册两个组织服务实例，然后使用客户端负载均衡查找服务，每个服务实例中缓存注册表 （1）通过Eureka服务进行注册，告诉Eureka每个服务实例的[物理位置，端口号，正在启动的服务的服务ID] （2）许可证服务调用组织服务，许可证服务使用Netflix Ribbon来提供客户端负载均衡。联系Eureka检索服务位置信息，然后本地缓存 （3）Ribbon定期对Eureka进行ping操作，刷新服务位置的本地缓存 构建Spring Eureka服务新建项目用于启动Eureka服务器 Maven的pom.xml导入Eureka依赖 然后再新建application.yml文件 123456789101112server: port: 8761 # Eureka服务监听的端口eureka: client: registerWithEureka: false # 不被Eureka注册 fetchRegistry: false # 不尝试在本地缓存注册表信息 server: waitTimeInMsWhenSyncEmpty: 5 # 该条等待5min后才通告之前过来的注册的服务，完成服务注册 # 每次注册需要30s才能将服务显示在Eureka中，因为Eureka需要3次接收连续心跳包ping，每次ping间隔10s，然后才使用这个服务 serviceUrl: defaultZone: http://localhost:8761 引导器如下，添加注释@enableEurekaServer 1234567@SpringBootApplication@EnableEurekaServerpublic class EurekaServerApplication { public static void main(String[] args) { SpringApplication.run(EurekaServerApplication.class, args); }} 然后该服务变成了Eureka服务 通过Spring Eureka 注册服务配置组织服务和许可证服务，Eureka注册它们 注册组织服务首先往组织服务的pom.xml中添加eureka依赖项 然后配置bootstrap.yml 123456789spring: application: name: organizationservice # Eureka注册的服务的逻辑名称 profiles: active: default # 默认profiles cloud: config: enabled: true # 可用 然后配置application.yml 12345678eureka: instance: preferIpAddress: true # 注册服务的IP，用于定位。不用主机名原因：有些容器没有DNS，可能无法定位服务 client: registerWithEureka: true # 向Eureka注册服务 fetchRegistry: true # 拉取注册表的本地副本，以便客户端获取 serviceUrl: defaultZone: http://localhost:8761/eureka/ # eureka服务的位置，是一个列表，即可以有多个Eureka服务 1多个Eureka之间通信，必须对每个Eureka服务进行配置，以了解集群中其他节点，建立Eureka集群的内容超出了本书范围 然后组织服务就可以通过Eureka注册了 服务发现查找服务让许可证服务作为客户端，通过服务发现来调用该组织服务 这里介绍3个不同的Spring/Netflix客户端库，服务消费者可以使用它们来和Ribbon进行交互 Spring DiscoveryClient 启用了RestTemplate的SpringDiscoveryClient Netflix Feign客户端 首先写一些便利的类和方法，使得可以通过相同服务端点处理不同的客户端类型 修改REST端点，以包含新路由1234567@RequestMapping(value=&quot;/{licenseId}/{clientType}&quot;,method = RequestMethod.GET)public License getLicensesWithClient( @PathVariable(&quot;organizationId&quot;) String organizationId, @PathVariable(&quot;licenseId&quot;) String licenseId, @PathVariable(&quot;clientType&quot;) String clientType) { return licenseService.getLicense(organizationId,licenseId, clientType);} clientType决定使用的客户端类型 Discovery——使用Discovery和标准的Spring RestTemplate类来调用组织服务 Rest——增强的Spring RestTemplate来调用基于Ribbon的服务 Feign——使用Netflix的Feign客户端来通过Ribbon调用服务 然后在LicenseService.java中的LicenseService类添加名为retrieveOrgInfo()的简单方法 ，该方法通过clientType选择三种不同的客户端方法实现 以上代码的getLicense()方法将调用retrieveOrgInfo()方法从Postgres数据库中检索组织数据 123456789101112 public License getLicense(String organizationId,String licenseId, String clientType) { License license = licenseRepository.findByOrganizationIdAndLicenseId(organizationId, licenseId); Organization org = retrieveOrgInfo(organizationId, clientType);// 检索组织数据 return license .withOrganizationName( org.getName()) .withContactName( org.getContactName()) .withContactEmail( org.getContactEmail() ) .withContactPhone( org.getContactPhone() ) .withComment(config.getExampleProperty()); } Spring DiscoveryClient查找服务实例引导类修改 123456789101112131415@SpringBootApplication@EnableDiscoveryClient//激活Spring DiscoveryClient@EnableFeignClients//后面用得到public class Application { @LoadBalanced @Bean public RestTemplate getRestTemplate(){ return new RestTemplate(); } public static void main(String[] args) { SpringApplication.run(Application.class, args); }} 使应用程序能够使用DiscoveryClient和Ribbon库，然后通过retrieveOrgInfo定位到该服务，具体client实现如下 123456789101112131415161718192021222324@Componentpublic class OrganizationDiscoveryClient { @Autowired private DiscoveryClient discoveryClient; public Organization getOrganization(String organizationId) { RestTemplate restTemplate = new RestTemplate();//新建实例 List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;organizationservice&quot;);// 获取组织服务的所有实例列表 if (instances.size()==0) return null; String serviceUri = String.format(&quot;%s/v1/organizations/%s&quot;,instances.get(0).getUri().toString(), organizationId); //检索服务端点，从而获取到标准URL以便REST调用 System.out.println(&quot;!!!! SERVICE URI: &quot; + serviceUri); ResponseEntity&lt; Organization &gt; restExchange = restTemplate.exchange( serviceUri, HttpMethod.GET, null, Organization.class, organizationId);//标准Spring REST模板类调用服务 return restExchange.getBody(); }} 以上代码的问题： 没有利用Ribbon的负载均衡，获取了服务列表但不清楚要调用哪个实例 开发人员通过编写代码来构建URL，太复杂了 以上构造resTemplate是直接实例化的，我们可以用@Autowired注入一个启用Ribbon的拦截器 使用带有Ribbon的Spring RestTemplate调用服务使用@LoadBlanced，在引导类中创建一个支持Ribbon的类 12345678910111213141516@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class Application { @LoadBalanced @Bean public RestTemplate getRestTemplate(){ return new RestTemplate();//新建实例，以便自动装配 } public static void main(String[] args) { SpringApplication.run(Application.class, args); }} 定义好之后，需要时自动装配即可 和标准RestTemplate定义目标URL一样，使用将要调用的服务的EurekaID来构建URL，而非物理位置 123456789101112@AutowiredRestTemplate restTemplate;public Organization getOrganization(String organizationId){ ResponseEntity&lt;Organization&gt; restExchange = restTemplate.exchange( &quot;http://organizationservice/v1/organizations/{organizationId}&quot;,//这里和标准RestTemplate有一点不同 HttpMethod.GET, null, Organization.class, organizationId); return restExchange.getBody();} 与之前的不同： DiscoveryClient不见了 URL的组织服务器名称与通过Eureka注册的服务的应用程序ID（organizationservice）相匹配，该服务器名称作为Ribbon查询服务实力的键，实际服务位置和端口与开发人员完全分离 1http://{applicationid}/v1/organizations/{organizationId} Ribbon将在所有服务实例之间轮训负载均衡所有请求 使用Netflix Feign 客户端调用服务该方案是启用Ribbon的RestTemplate的替代方案 方法： 定义一个接口并用Spring Cloud注解标注，以映射Ribbon将要调用的基于Eureka的服务（组织服务） Spring Cloud动态生成代理类，用于调用目标REST服务 首先引导类添加新注解@EnableFeignClients 12345678910111213141516@SpringBootApplication//@EnableDiscoveryClient 这里可以移除老方法@EnableFeignClientspublic class Application { @LoadBalanced @Bean public RestTemplate getRestTemplate(){ return new RestTemplate(); } public static void main(String[] args) { SpringApplication.run(Application.class, args); }} 然后启用调用组织服务的Feign接口 12345678910@FeignClient(&quot;organizationservice&quot;)public interface OrganizationFeignClient { @RequestMapping(//该注解定义端点路径和动作 method= RequestMethod.GET, value=&quot;/v1/organizations/{organizationId}&quot;, consumes=&quot;application/json&quot;) Organization getOrganization(@PathVariable(&quot;organizationId&quot;)//该注解定义传入端点的参数 String organizationId);} 开发人员只需自动装配并使用它 12RestTemplate的服务调用的HTTP状态码都将通过ResponseEntity返回Feign的4xx~5xx将抛出FeignException异常，其可以编写错误编码器","link":"/2021/05/10/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"},{"title":"保护微服务","text":"安全的应用程序涉及多层保护： 正确的用户控制，本章主要讨论的内容 保持服务是最新的，让漏洞风险最低 实现网络访问控制 实现验证和授权，将使用Spring Cloud Security和OAuth2框架来保护基于Spring的服务 OAuth2基于令牌的安全框架，允许用户使用第三方验证服务进行验证 用户成功验证之后，得到一个令牌，该令牌与每个请求一起发送，然后验证服务对令牌进行确认 目标和优势：用户调用多个服务，轻松与第三方云服务提供商集成，不需要为每个服务都提供自己的凭据就能完成验证 OAuth2特性安全性分解为以下四个部分： 受保护的资源 资源所有者 应用程序 OAuth2验证服务器：用户和应用程序的中间人，允许用户对自己进行验证，不必将凭据传递给每个服务 四种类型授权方式 密码 客户端凭据 授权码 隐式 本章任务： 讨论微服务如何通过简单的密码授权类型来使用OAuth2 使用JWT提供更健壮的OAuth2解决方案 介绍构建微服务时需要考虑的其他安全注意事项 使用Spring和OAuth2来保护单个端点 建立基于SpringCloud的OAuth2验证服务 注册一个伪EagleEyeUI应用程序作为已授权的应用程序，可通过OAuth2服务验证和授权用户身份 使用OAuth2密码授权保护EagleEye服务，可通过POSTMAN模拟登陆 保护许可证服务和组织服务，它们只能被已通过验证的用户调用 建立EagleEye OAuth2验证服务建立验证服务authentication-service，实现验证用户凭据并颁发令牌，用户尝试访问受保护的服务时，验证服务将确认令牌是否已经颁发并且尚未过期 首先添加依赖项 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt;&lt;/dependency&gt; 第一个引入Spring和Spring Cloud安全库 第二个拉取Spring OAuth2库 然后再程序入口方法处添加注解 123456789101112131415@SpringBootApplication@RestController@EnableResourceServer@EnableAuthorizationServer//告诉SpringCloud，该服务将作为OAuth2服务public class Application { //添加REST端点，当试图访问受保护的服务时，会用到这些端点 @RequestMapping(value = { &quot;/user&quot; }, produces = &quot;application/json&quot;) public Map&lt;String, Object&gt; user(OAuth2Authentication user) { Map&lt;String, Object&gt; userInfo = new HashMap&lt;&gt;(); userInfo.put(&quot;user&quot;, user.getUserAuthentication().getPrincipal()); userInfo.put(&quot;authorities&quot;, AuthorityUtils.authorityListToSet(user.getUserAuthentication().getAuthorities())); return userInfo; }} 使用OAuth2注册客户端应用程序构建一个名为OAuth2Config的类，用于注册EagleEye应用程序 注意：注册过的服务不一定能访问任何受保护的资源 12验证：根据凭据证明用户的身份授权：允许用户做它们想做的事 123456789101112131415161718192021222324252627@Configurationpublic class JWTOAuth2Config extends AuthorizationServerConfigurerAdapter {//继承AuthorizationServerConfigurerAdapter类，并使用@Confguration注解 @Autowired private AuthenticationManager authenticationManager; @Autowired private UserDetailsService userDetailsService; @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory()//定义了那些客户端将注册到服务 .withClient(&quot;eagleeye&quot;) .secret(&quot;thisissecret&quot;) .authorizedGrantTypes(&quot;refresh_token&quot;, &quot;password&quot;, &quot;client_credentials&quot;) .scopes(&quot;webclient&quot;, &quot;mobileclient&quot;); } @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {//定义了AuthenticationServerConfigurer中使用不同的组件。告诉Spring使用Spring提供的默认的验证管理器和用户详细信息服务 endpoints.authenticationManager(authenticationManager) .userDetailsService(userDetailsService); }} AuthorizationServerConfigurerAdapter类是SpringSecurity核心部分，提供执行关键验证和授权功能的基本机制 这里覆盖两个方法： 第一个configure,传入一个ClientDetailsServiceConfigurer类的参数，作用是注册客户端，使其允许访问受OAuth2保护的服务 其支持两种存储：内存和secret，这里使用clients.inMemory()存储 withClient和secret两个方法提供被注册的应用程序的名称以及密钥 authorizedGrantTypes()，提供一个逗号分割的授权类型列表 scopes用于应用程序请求验证服务器获取访问令牌时可操作的范围。这里应用程序分为手机和web，两种都可以请求验证。然而，应用程序请求密钥时需要定义作用域，定义作用域可以编写客户端特定作用域的授权规则 例如，我们可能限制用户在浏览器上和手机上分别能看到不同的敏感信息等等 配置EagleEye用户Spring可从内存、JDBC或LDAP服务器存储和检索用户信息 这里使用内存数据存储 john.carnell USER william.woodward Admin 两个用户属于不同角色 这里在WebSecurityConfigurer中配置 123456789101112131415161718192021222324@Configurationpublic class WebSecurityConfigurer extends WebSecurityConfigurerAdapter { @Override @Bean public AuthenticationManager authenticationManagerBean() throws Exception { return super.authenticationManagerBean(); } @Override @Bean public UserDetailsService userDetailsServiceBean() throws Exception { return super.userDetailsServiceBean(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception {//configure方法定义用户、密码和角色的地方 auth.inMemoryAuthentication() .withUser(&quot;john.carnell&quot;).password(&quot;password1&quot;).roles(&quot;USER&quot;) .and() .withUser(&quot;william.woodward&quot;).password(&quot;password2&quot;).roles(&quot;USER&quot;, &quot;ADMIN&quot;); }} 扩展WebSecurityConfgureAdapter类并使用@Configuration注解标记它开始 authenticationManagerBean和userDetailsServiceBean两个方法提供验证用户的机制，这里使用默认的方法，这两个bean被注入OAuth2Config中的configure方法中 验证用户 如图，POSTMAN发送post请求，并提供应用程序名称、密钥 但是还要传一些其他HTTP参数获取令牌 grant_type——正在执行的OAuth2授权类型 scope——应用程序作用域 username——用户登录的名称 password——用户登录的密码 传入http body后得到五个表单参数 access_token——OAuth2令牌 token_type——令牌类型 refresh_token——包含可以提交回OAuth2服务器的令牌，以便令牌过期时重新颁发 expires_in——令牌过期前的秒数 scope——令牌有效作用域 通过令牌就可以如图访问获取相关联的user信息了，如果令牌有效，就会返回用户信息以及分配的角色 使用OAuth2保护组织服务定义哪些用户有权执行哪些操作是在单个服务器级别上发生的 创建受保护的资源，要进行如下操作： 将相应Spring Security 和 OAuth2 jar添加到要保护的服务中 配置服务，以指向OAuth2验证服务 定义谁可以访问服务 下面将组织服务创建为受保护的资源，并确保它只能由已通过验证的用户来调用 将Spring Security和OAuth2添加到各个服务往组织服务添加依赖项 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt;&lt;/dependency&gt; 配置服务以指向OAuth2验证服务1234security: oauth2: resource: userInfoUri: http://localhost:8901/auth/user 每次调用组织服务，调用者HTTP头部必须有OAuth2访问令牌 受保护的资源（组织服务）必须调用OAuth2服务查看令牌是否生效 此外引导类也要加注解告诉微服务它是一个受保护的资源 123456789101112131415@SpringBootApplication@EnableEurekaClient@EnableCircuitBreaker@EnableResourceServer//告诉微服务它是一个受保护的资源public class Application { @Bean public Filter userContextFilter() { UserContextFilter userContextFilter = new UserContextFilter(); return userContextFilter; } public static void main(String[] args) { SpringApplication.run(Application.class, args); }} 强制执行一个过滤器，该过滤器会拦截所有对该服务的调用，并查看请求头是否有令牌，然后调用security.oauth2.resource.userInfoUri定义的回调URL查看令牌是否有效 定义谁可以访问服务现在要围绕服务定义访问控制规则 访问规则的范围可以从极其粗粒度（通过验证的任何用户都可以访问）到非常细粒度（只有具有此角色的应用程序才允许通过DELETE方法访问此URL） 只有已通过验证的角色才能访问服务URL 只有具有特定角色的用户才能访问服务URL 通过验证用户保护服务组织服务中的ResourceServerConfiguration类中 限制只有已通过验证的用户才可访问 1234567891011@Configurationpublic class ResourceServerConfiguration extends ResourceServerConfigurerAdapter {//扩展ResourceServerConfigurerAdapter @Override public void configure(HttpSecurity http) throws Exception{//所有访问规则都是configure方法定义的 http//所有访问规则都是通过传入方法的HttpSecurity对象配置的 .authorizeRequests() .anyRequest() .authenticated();//这里定义所有请求都要通过验证才能访问 }} 如图，401访问失败，因为需要验证获取访问令牌，凭借令牌才能访问 要想访问成功，需要对OAuth2服务的/auth/oauth/token调用返回的值进行拼接 添加Authorization的HTTP首部，拼接bearer和access_token，再次访问组织服务即可 通过特定角色保护服务目标调用：DELETE 限制：已通过验证且具有ADMIN访问权限才可调用 123456789101112@Configurationpublic class ResourceServerConfiguration extends ResourceServerConfigurerAdapter { @Override public void configure(HttpSecurity http) throws Exception{ http .authorizeRequests() .antMatchers(HttpMethod.DELETE, &quot;/v1/organizations/**&quot;)//限制受保护的URL和HTTP动词，端点可以用通配符风格的符号定义 .hasRole(&quot;ADMIN&quot;)//允许访问的角色列表，用逗号分隔 .anyRequest() .authenticated(); }} 现在，使用john.carnell（USER角色）登录获取一个OAuth2令牌，并试图访问DELETE端点，将会收到401 如果使用william.woodward用户及其OAuth2令牌尝试上述相同操作，会返回成功的调用(204) 传播OAuth2访问令牌问题：如何将一个令牌从一个服务传播到另一个服务？ 调用链： 用户——》EagleEye Web客户端——》Eagle Eye Web应用程序——》Zuul网关——》许可证服务（需验证）——》组织服务（需验证） （1）用户持有令牌，web应用程序需要通过许可证服务检索数据，从而对其REST端点进行调用 （2）Zuul查找许可证服务，对一个许可证服务发起调用，Zuul网关需要对HTTP头部的Authorization进行复制 （3）许可证服务接受到调用，需要通过OAuth2检查令牌权限 （4）组织服务接收到该调用时，再次使用Authorization的令牌，并使用OAuth2检查令牌 任务： 修改Zuul网关服务，让令牌可以传播到许可证服务在Zuul中设置以下配置（黑名单） 1zuul.sensitiveHeaders: Cookie,Set-Cookie 该配置是黑名单列表，阻止了Cookie和Set-Cookie的传播，反而没有阻止Authorization，如果不设置，默认全部阻止 1Zuul可以通过使用@EnableOAuth2Sso参与单点登录，在Spring Cloud Security文档中有相关内容 将许可证服务配置为OAuth2资源服务该部分内容同上述组织服务配置 修改许可证服务，确保HTTP首部注入对组织服务的调用OAuth2RestTemplate：自动装配到【调用其他注册OAuth2的服务】的服务的Bean 12345@Beanpublic OAuth2RestTemplate oauth2RestTemplate(OAuth2ClientContext oauth2ClientContext, OAuth2ProtectedResourceDetails details) { return new OAuth2RestTemplate(details, oauth2ClientContext);} OrganizationRestTemplateClient.java中的OrganizationRestTemplateClient类展示如何自动装配的 12345678910111213141516171819@Componentpublic class OrganizationRestTemplateClient { @Autowired OAuth2RestTemplate restTemplate;//处理OAuth2访问令牌传播，是RestTemplate的替代品 private static final Logger logger = LoggerFactory.getLogger(OrganizationRestTemplateClient.class); public Organization getOrganization(String organizationId){ logger.debug(&quot;In Licensing Service.getOrganization: {}&quot;, UserContext.getCorrelationId()); ResponseEntity&lt;Organization&gt; restExchange = restTemplate.exchange( &quot;http://zuulserver:5555/api/organization/v1/organizations/{organizationId}&quot;, HttpMethod.GET, null, Organization.class, organizationId); return restExchange.getBody(); }} JSON Web Token 与 OAuth2JWT：矫正OAuth2令牌标准的缺陷 小巧 密码签名 自包含 可扩展 修改验证服务以颁发JWT令牌1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-jwt&lt;/artifactId&gt;&lt;/dependency&gt; 验证服务中创建新配置类JWTTokenStoreConfig.java用于创建JWT令牌存储 12345678910111213141516171819202122232425262728293031323334@Configurationpublic class JWTTokenStoreConfig { @Autowired private ServiceConfig serviceConfig; @Bean public TokenStore tokenStore() { return new JwtTokenStore(jwtAccessTokenConverter()); } @Bean @Primary public DefaultTokenServices tokenServices() {//默认方法，创建令牌 DefaultTokenServices defaultTokenServices = new DefaultTokenServices(); defaultTokenServices.setTokenStore(tokenStore()); defaultTokenServices.setSupportRefreshToken(true); return defaultTokenServices; } @Bean public JwtAccessTokenConverter jwtAccessTokenConverter() {//JWT和OAuth2之间充当翻译 JwtAccessTokenConverter converter = new JwtAccessTokenConverter(); converter.setSigningKey(serviceConfig.getJwtSigningKey());//用于签署令牌的签名密钥 return converter; } @Bean public TokenEnhancer jwtTokenEnhancer() { return new JWTTokenEnhancer(); }} 这里使用一个对称密钥来解密签名 1signing.key: &quot;345345fsdfsf5345&quot; 定义好之后，需要将JWT挂钩到验证服务中 前面我们通过OAuth2Config来配置验证服务，这里使用一个JWTOAuth2Config新类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Configurationpublic class JWTOAuth2Config extends AuthorizationServerConfigurerAdapter { @Autowired private AuthenticationManager authenticationManager; @Autowired private UserDetailsService userDetailsService; @Autowired private TokenStore tokenStore; @Autowired private DefaultTokenServices tokenServices; @Autowired private JwtAccessTokenConverter jwtAccessTokenConverter; @Autowired private TokenEnhancer jwtTokenEnhancer; @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception { TokenEnhancerChain tokenEnhancerChain = new TokenEnhancerChain(); tokenEnhancerChain.setTokenEnhancers(Arrays.asList(jwtTokenEnhancer, jwtAccessTokenConverter)); endpoints.tokenStore(tokenStore) //JWT .accessTokenConverter(jwtAccessTokenConverter) //这是钩子，告诉OAuth2使用JWT .tokenEnhancer(tokenEnhancerChain) //JWT .authenticationManager(authenticationManager) .userDetailsService(userDetailsService); } @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory() .withClient(&quot;eagleeye&quot;) .secret(&quot;thisissecret&quot;) .authorizedGrantTypes(&quot;refresh_token&quot;, &quot;password&quot;, &quot;client_credentials&quot;) .scopes(&quot;webclient&quot;, &quot;mobileclient&quot;); }} 重新构建服务并启动 令牌对JSON进行Base64编码，而未加密，使得开发人员可以扩展令牌 微服务中使用JWT配置许可证和组织服务使用JWT只需两件事 （1）添加依赖 （2）两个服务分别创建JWTTokenStoreConfig 最后一步，因为需要用许可证服务调用组织服务，通过OAuth2RestTemplate来完成，但是它不传播基于JWT的令牌，所以需要添加一个自定义的RestTemplate bean来完成这个注入，在Application中添加 123456789101112131415161718192021222324public class Application { @Autowired private ServiceConfig serviceConfig; private static final Logger logger = LoggerFactory.getLogger(Application.class); @Primary @Bean public RestTemplate getCustomRestTemplate() { RestTemplate template = new RestTemplate(); List interceptors = template.getInterceptors(); if (interceptors == null) { template.setInterceptors(Collections.singletonList(new UserContextInterceptor()));//将UserContextInterceptor注入每个REST调用 } else { interceptors.add(new UserContextInterceptor()); template.setInterceptors(interceptors); } return template; } public static void main(String[] args) { SpringApplication.run(Application.class, args); }} UserContextInterceptor类是第六章UserContextInterceptor的变种 1234567891011121314public class UserContextInterceptor implements ClientHttpRequestInterceptor { private static final Logger logger = LoggerFactory.getLogger(UserContextInterceptor.class); @Override public ClientHttpResponse intercept( HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException { HttpHeaders headers = request.getHeaders(); headers.add(UserContext.CORRELATION_ID, UserContextHolder.getContext().getCorrelationId()); headers.add(UserContext.AUTH_TOKEN, UserContextHolder.getContext().getAuthToken());//将授权令牌添加到HTTP首部 return execution.execute(request, body); }} 扩展JWT令牌向验证服务增加Spring OAuth2令牌增强器类 JWTTokenEnhancer 1234567891011121314151617181920public class JWTTokenEnhancer implements TokenEnhancer { @Autowired private OrgUserRepository orgUserRepo; private String getOrgId(String userName){ UserOrganization orgUser = orgUserRepo.findByUserName( userName ); return orgUser.getOrganizationId(); } @Override public OAuth2AccessToken enhance(OAuth2AccessToken accessToken, OAuth2Authentication authentication) { Map&lt;String, Object&gt; additionalInfo = new HashMap&lt;&gt;(); String orgId = getOrgId(authentication.getName()); additionalInfo.put(&quot;organizationId&quot;, orgId);//附加属性都在HashMap上 ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(additionalInfo);hashmap传入accessToken变量上 return accessToken; }} 然后告诉OAuth2服务使用JWTTokenEnhancer类，首先为JWTTokenEnhancer类公开一个Spring bean 然后在代码中添加一个bean定义来实现 1234567@Configurationpublic class JWTTokenStoreConfig { @Bean public TokenEnhancer jwtTokenEnhancer() { return new JWTTokenEnhancer(); }} 一旦将JWTTokenStoreConfig作为bean公开，就可以将它挂钩到JWTOAuth2Config中 12345678910111213@Autowiredprivate TokenEnhancer jwtTokenEnhancer; @Overridepublic void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception { TokenEnhancerChain tokenEnhancerChain = new TokenEnhancerChain(); tokenEnhancerChain.setTokenEnhancers(Arrays.asList(jwtTokenEnhancer, jwtAccessTokenConverter));//tokenEnhancerChain允许挂钩多个容器，这里将jwtTokenEnhancer加进去 endpoints.tokenStore(tokenStore) //JWT .accessTokenConverter(jwtAccessTokenConverter) //JWT .tokenEnhancer(tokenEnhancerChain) //JWT .authenticationManager(authenticationManager) .userDetailsService(userDetailsService);} 从JWT令牌中解析自定义字段Zuul中引入JWT解析器库，解析流经Zuul的JWT令牌的organizationId字段 12345&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.7.0&lt;/version&gt;&lt;/dependency&gt; 然后向TrackingFilter类添加名为getOrganizationId()新方法 123456789101112131415161718private String getOrganizationId(){ String result=&quot;&quot;; if (filterUtils.getAuthToken()!=null){ String authToken = filterUtils.getAuthToken().replace(&quot;Bearer &quot;,&quot;&quot;); try { Claims claims = Jwts.parser() .setSigningKey(serviceConfig.getJwtSigningKey().getBytes(&quot;UTF-8&quot;)) .parseClaimsJws(authToken).getBody(); result = (String) claims.get(&quot;organizationId&quot;); } catch (Exception e){ e.printStackTrace(); } } return result;} 然后在run()方法中调用即可","link":"/2021/05/26/%E4%BF%9D%E6%8A%A4%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"title":"客户端弹性模式","text":"系统崩溃导致服务组件彻底损失，应用程序可以绕过 然而去检测那些服务性能不佳的服务并绕过它是非常困难的，原因： （1）间歇性问题导致服务性能下降，形成不可逆转势头，逐步降级导致资源耗尽并崩溃 （2）对远程服务的调用时同步的，调用时间可能很长 （3）应用程序经常被设计为处理远程资源的彻底故障，而非部分降级。程序会因为服务小故障而降级，但更有可能因为资源耗尽而崩溃 所以如何处理性能不佳的远程服务是本节关键，如果没有适当保护，可能会拖垮整个应用程序 客户端弹性模式重点：远程服务发生错误或表现不佳时保护远程资源（其他微服务调用或数据库查询）的客户端免于崩溃 目标：让客户端快速失败，而不消耗数据库连接和线程池的宝贵资源，防止问题向消费者”上游“传播 四种客户端弹性模式： （1）客户端负载均衡模式：客户端缓存服务发现检索到的微服务端点（Ribbon） （2）断路器模式：确保客户端不会重复调用失败的服务 远程服务被调用时，断路器会监视，如果调用时间太长，断路器会介入中断调用。 断路器会监视所有调用，如果对某一远程资源调用失败次数过多，断路器就会出现并采取快速失败 （3）后备模式：调用失败时询问是否有可执行的替代方案 远程服务调用失败，通常从另一数据源查找数据，或将用户请求排序以供将来处理 例如：调用商品推荐偏好服务，如果这个服务调用失败，则取检索一个更通用的偏好列表，这个通用列表可能来自不同服务和数据源 （4）舱壁模式：隔离不同的服务调用，确保表现不佳的服务不会耗尽客户端所有资源 将远程资源的调用分到线程池中，降低一个缓慢的远程资源调用拖垮整个应用程序的风险 线程池充当舱壁，一个服务响应很慢，这种服务调用的线程池就会饱和并停止处理请求 重要性场景： 服务C用于读写共享文件系统NAS 服务B连接数据源B，也可以调用服务C 服务A连接数据源A，可以调用服务B 问题：NAS出问题导致访问速度缓慢，导致服务C调用变慢，导致服务B调用数据源B耗尽以及调用服务C变慢，最终也会导致服务A变慢及资源耗尽，从而影响所有的三个服务 解决方法：断路器，服务C性能不佳时，对服务C的特定调用的断路器会跳闸，并且快速失败。服务B有多个端点而只有与服务C交互的端点才会受影响，服务B其余功能是完整的 断路器充当中间人，保护三个应用程序免于崩溃 B不会直接调用C，而是调用委托给断路器，断路器接管并将其包装在原始调用者的线程（由线程池管理）中。客户端也不再直接等待调用完成，而由断路器监视线程，如果线程运行时间太长就终止调用 断路器跳闸的方式： 1.愉快路径：维护定时器，定时器用完之前对完成远程服务调用，一切顺利 B-&gt;断路器-&gt;C 2.断路器（没有后备）：B-&gt;断路器-(在一定时间内服务C上发生足够多的错误，部分降级。调用C时，服务B可以立即接收到错误消息而不调用C )-&gt;C 3.断路器（带有后备）：B不去请求断路器调用服务C，而选择快速失败，或者执行替代代码（后备）。服务C也获得一个恢复的机会，让少量请求通过并重试，防止因降级发生级联死亡 断路器提供的能力： （1）快速失败 （2）优雅地失败 （3）无缝恢复 Hystrix 引入Hystrix依赖 通过Hystrix注解来运用断路器模式包装远程调用 远程资源上定制断路器。以便为每个调用定制超时，配置断路器“跳闸”之前的故障次数 调用失败或断路器必须中断调用时实现后备策略 使用单独线程池隔离服务调用（舱壁） 搭建许可证服务器，使用Spring Cloud和Hystrix许可证服务的pom文件中导入Spring Hystrix依赖项和Hystrix核心库 123456789&lt;dependency&gt;&lt;!-- Spring Hystrix依赖项--&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;!-- 核心Netflix Hystrix库--&gt; &lt;groupId&gt;com.netflix.hystrix&lt;/groupId&gt; &lt;artifactId&gt;hystrix-javanica&lt;/artifactId&gt; &lt;version&gt;1.5.9&lt;/version&gt;&lt;/dependency&gt; 使用@EnableCircuitBreaker标注许可证服务引导类 12345@SpringBootApplication@EnableEurekaClient@EnableCircuitBreaker//断路器标注许可证服务public class Application {} 实现断路器首先实现许可证数据库的断路器 使用@HystrixCommand，让断路器包装一个Service方法（动态代理），并通过专门处理远程调用的线程池来管理该方法所有调用 12345@HystrixCommandpublic List&lt;License&gt; getLicensesByOrg(String organizationId){ return licenseRepository.findByOrganizationId(organizationId);}//默认调用时间超过1000ms，断路器会中断对getLicensesByOrg()方法的调用 这里模拟数据库调用，让3次中的大约1次调用时间超过1000ms 12345678910111213141516171819private void randomlyRunLong(){ Random rand = new Random(); int randomNum = rand.nextInt((3 - 1) + 1) + 1; if (randomNum==3) sleep();}private void sleep(){ try { Thread.sleep(11000); } catch (InterruptedException e) { e.printStackTrace(); }}@HystrixCommandpublic List&lt;License&gt; getLicensesByOrg(String organizationId){ randomlyRunLong();//随机3次中1次休眠线程 return licenseRepository.findByOrganizationId(organizationId);} 如上图所示，休眠服务的调用时间超过一秒，报错 调用组织微服务的超时上面讲解了调用数据库的断路器设置，这里讲解许可证服务调用组织服务的断路器设置 标注RestTemplate的调用 1234@HystrixCommandprivate Organization getOrganization(String organizationId) { return organizationRestClient.getOrganization(organizationId);//调用RestTemplate远程调用组织服务，详情见上节} 定制断路器超时时间将附加参数传递给@HystrixCommand即可定制断路器 12345678@HystrixCommand( commandProperties={ @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value=&quot;12000&quot;)})//这里设置最大超时时间为12spublic List&lt;License&gt; getLicensesByOrg(String organizationId){ randomlyRunLong(); return licenseRepository.findByOrganizationId(organizationId);} 后备处理服务出现故障后，开发人员有机会拦截故障，并选择替代方案 1234567891011121314151617//待执行的后备方法，必须与@HystrixCommand保护的原始方法位于同一个类中，还必须和原始方法的签名完全相同，以便传参private List&lt;License&gt; buildFallbackLicenseList(String organizationId){ List&lt;License&gt; fallbackList = new ArrayList&lt;&gt;(); License license = new License() .withId(&quot;0000000-00-00000&quot;) .withOrganizationId( organizationId ) .withProductName(&quot;Sorry no licensing information currently available&quot;); fallbackList.add(license); return fallbackList;}@HystrixCommand(fallbackMethod = &quot;buildFallbackLicenseList&quot;)//这里设置失败调用后，执行后备方法buildFallbackLicenseListpublic List&lt;License&gt; getLicensesByOrg(String organizationId){ randomlyRunLong(); return licenseRepository.findByOrganizationId(organizationId);} 继续使用随机休眠方法，发现调用失败后不会报错，而是执行了替代方法 实现舱壁模式多个微服务调用可能默认使用同一批线程，高并发场景下大量请求导致所有线程被刷爆，同时堵塞新请求，导致Java容器崩溃。 舱壁模式将远程资源调用隔离在它们自己的线程池中，以便控制单个表现不佳的服务 使用@HystrixCommand注解实现隔离线程池。注解代码完成以下操作 （1）为getLicensesByOrg方法调用建立单独线程池 （2）设置线程池中的线程数 （3）设置单个线程繁忙时可排队的请求数的队列大小 1234567891011121314@HystrixCommand( threadPoolKey = &quot;licenseByOrgThreadPool&quot;,//请求建立新线程池，定义线程池唯一名称 threadPoolProperties = { @HystrixProperty(name = &quot;coreSize&quot;,value=&quot;30&quot;),//定义线程池中线程最大数量 @HystrixProperty(name=&quot;maxQueueSize&quot;, value=&quot;10&quot;)//线程池前的队列，对传入请求排队。一旦超过该大小，接下来的请求都将失败，直到队列中有空间 })public List&lt;License&gt; getLicensesByOrg(String organizationId){ logger.debug(&quot;LicenseService.getLicensesByOrg Correlation id: {}&quot;, UserContextHolder.getContext().getCorrelationId()); randomlyRunLong(); return licenseRepository.findByOrganizationId(organizationId);} 注意，maxQueueSize设置成-1时，使用SynchronousQueue保存传入的请求，设置成大于1时，导致Hystrix使用Java LinkedBlockingQueue，允许线程忙于处理请求时也能对请求进行排毒 Hystrix允许使用queueSizeRejectionThreshold属性动态更改队列大小，但只有maxQueueSize为0时才能使用这个$$自定义线程池大小=服务健康状态时每秒支撑的最大请求数×第99百分位延迟时间（以秒为单位）+用于缓冲的少量额外线程$$ 微调Hystrix不仅如此，Hystrix监控调用失败次数，失败次数多，Hystrix还会在请求发送到远程资源之前就自动阻止 原因：1.远程资源的性能问题，以防止等待超时，从而显著降低调用服务导致的资源耗尽问题和崩溃的风险 2.保持服务负载，不会使服务彻底崩溃，快速失败给了性能下降的系统一些时间去进行恢复 1234567断路器决策过程出现错误，开始一个10s活动窗口计时器（可配置）查看10s内的总调用数量，调用次数不超过默认值继续让调用通过超过最少调用次数，则查看整体故障百分比，该百分比超过错误阈值，则出发断路器，使将来几乎所有调用都失败如果未达到该阈值，10s窗口过去后重置断路器统计信息调用一个跳闸服务器时，开始一个新的活动窗口（可配置5s），每隔5s调用有问题的远程服务如果调用成功则重置断路器，重新让调用通过，如果失败，保持断路器断开，并在另一个5s窗口继续尝试 根据这些，开发人员可使用5个属性定制断路器行为 12345678910111213141516171819@HystrixCommand(fallbackMethod = &quot;buildFallbackLicenseList&quot;, threadPoolKey = &quot;licenseByOrgThreadPool&quot;, threadPoolProperties = {@HystrixProperty(name = &quot;coreSize&quot;,value=&quot;30&quot;), @HystrixProperty(name=&quot;maxQueueSize&quot;, value=&quot;10&quot;)}, commandProperties={ @HystrixProperty(name=&quot;circuitBreaker.requestVolumeThreshold&quot;, value=&quot;10&quot;),//控制10s之内必须发生的连续调用数量 @HystrixProperty(name=&quot;circuitBreaker.errorThresholdPercentage&quot;, value=&quot;75&quot;),//超过最少调用数后，调用失败所占总调用数的百分比，若超过则跳闸 @HystrixProperty(name=&quot;circuitBreaker.sleepWindowInMilliseconds&quot;, value=&quot;7000&quot;),//跳闸之后，每隔多长的时间可以允许一个调用通过，以便查看服务是否健康 @HystrixProperty(name=&quot;metrics.rollingStats.timeInMilliseconds&quot;, value=&quot;15000&quot;),//控制Hystrix监视服务调用问题的窗口大小 @HystrixProperty(name=&quot;metrics.rollingStats.numBuckets&quot;, value=&quot;5&quot;)} //在定义的滚动窗口中收集统计信息的次数（这里桶数量有5个，要求能被活动窗口时间整除，这里每个桶长度为15s/5=3s，统计信息将收集到这个5个3s长度的桶内，代表窗口内监控故障的时间） )public List&lt;License&gt; getLicensesByOrg(String organizationId){ logger.debug(&quot;LicenseService.getLicensesByOrg Correlation id: {}&quot;, UserContextHolder.getContext().getCorrelationId()); randomlyRunLong(); return licenseRepository.findByOrganizationId(organizationId);} 重新审视Hystrix配置3个Hystrix配置级别： （1）整个应用程序级别的默认值 （2）类级别的默认值 （3）类中定义的线程池级别 @DefaultProperties在类上配置默认值，让类中所有方法都遵循类上的默认值配置 1生产环境中，Hystrix数据一般都在Spring Cloud Config中配置 线程上下文与Hystrix@HystrixCommand隔离策略： （1）THREAD 每个Hystrix命令都在一个单独线程池中执行，不与父线程共享，保证线程调用可以被中断而不影响父线程其他活动 （2）SEMAPHORE Hystrix管理@HystrixCommand注解保护的分布式调用，不需启动新线程（轻量级隔离级别，适用于服务量很大的异步IO编程模型），调用超时会中断父线程。中断父线程导致开发人员无法捕获异常 隔离策略可以在@HystrixCommand注解中加入commandProperties属性，设置隔离级别 ThreadLocal问题场景：THREAD隔离级别，Hystrix不会将父线程上下文传播到Hystrix命令管理的线程中 问题复现 在@HystrixCommand包裹的方法（子线程）中，用日志打印父线程上下文存储的信息 12345678910111213141516171819202122232425262728//使用filter拦截REST请求的HTTP信息，存储在UserContextHolder的ThreadLocal上下文中@Componentpublic class UserContextFilter implements Filter { private static final Logger logger = LoggerFactory.getLogger(UserContextFilter.class); @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest; UserContextHolder.getContext().setCorrelationId( httpServletRequest.getHeader(UserContext.CORRELATION_ID) ); UserContextHolder.getContext().setUserId(httpServletRequest.getHeader(UserContext.USER_ID)); UserContextHolder.getContext().setAuthToken(httpServletRequest.getHeader(UserContext.AUTH_TOKEN)); UserContextHolder.getContext().setOrgId(httpServletRequest.getHeader(UserContext.ORG_ID)); logger.debug(&quot;UserContextFilter Correlation id: {}&quot;, UserContextHolder.getContext().getCorrelationId()); filterChain.doFilter(httpServletRequest, servletResponse); } @Override public void init(FilterConfig filterConfig) throws ServletException {} @Override public void destroy() {}} 12345678910111213141516171819202122232425//UserContextHolder用于控制ThreadLocal来保存上下文public class UserContextHolder { private static final ThreadLocal&lt;UserContext&gt; userContext = new ThreadLocal&lt;UserContext&gt;(); public static final UserContext getContext(){ UserContext context = userContext.get(); if (context == null) { context = createEmptyContext(); userContext.set(context); } return userContext.get(); } public static final void setContext(UserContext context) { Assert.notNull(context, &quot;Only non-null UserContext instances are permitted&quot;); userContext.set(context); } public static final UserContext createEmptyContext(){ return new UserContext(); }} 接着，在Hystrix线程管理的方法和上述Servlet过滤器（父线程）方法中分别增加打印日志功能，查看HTTP头传来的信息 得到结果 123c.t.licenses.utils.UserContextFilter: UserContextFilter Correlation id: TEST-CORRELATION-IDc.t.l.c.LicenseServiceController: LicenseServiceController Correlation id: TEST-CORRELATION-IDLicenseService.getLicensesByOrg Correlation id: 发现被@HystrixCommand包裹的方法获取不到关联ID的值（父线程ThreadLocal存储的信息） 而Hystrix和Spring Cloud提供了一种机制，可将父线程上下文传播到Hystrix管理的线程 HystrixConcurrrencyStrategy实战Hystrix允许的一种自定义并发策略。 该策略将Hystrix调用包装起来，并允许开发人员将附加的父线程上下文注入HystrixCommand管理的线程中 （1）定义自定义Hystrix并发策略类 （2）定义Callable类，将UserContext注入Hystrix命令中 （3）配置Spring cloud以使用自定义Hystrix并发策略 自定义Hystrix并发策略类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class ThreadLocalAwareStrategy extends HystrixConcurrencyStrategy{ private HystrixConcurrencyStrategy existingConcurrencyStrategy; public ThreadLocalAwareStrategy( HystrixConcurrencyStrategy existingConcurrencyStrategy) { //获取已存在并发策略 this.existingConcurrencyStrategy = existingConcurrencyStrategy; } /** *重写所有方法，如果已存在并发策略则复用这些方法（已存在并发策略常用于处理安全，很重要） * */ @Override public BlockingQueue&lt;Runnable&gt; getBlockingQueue(int maxQueueSize) { return existingConcurrencyStrategy != null ? existingConcurrencyStrategy.getBlockingQueue(maxQueueSize) : super.getBlockingQueue(maxQueueSize); } @Override public &lt;T&gt; HystrixRequestVariable&lt;T&gt; getRequestVariable( HystrixRequestVariableLifecycle&lt;T&gt; rv) { return existingConcurrencyStrategy != null ? existingConcurrencyStrategy.getRequestVariable(rv) : super.getRequestVariable(rv); } @Override public ThreadPoolExecutor getThreadPool(HystrixThreadPoolKey threadPoolKey, HystrixProperty&lt;Integer&gt; corePoolSize, HystrixProperty&lt;Integer&gt; maximumPoolSize, HystrixProperty&lt;Integer&gt; keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) { return existingConcurrencyStrategy != null ? existingConcurrencyStrategy.getThreadPool(threadPoolKey, corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue) : super.getThreadPool(threadPoolKey, corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue); } @Override public &lt;T&gt; Callable&lt;T&gt; wrapCallable(Callable&lt;T&gt; callable) { return existingConcurrencyStrategy != null ? existingConcurrencyStrategy .wrapCallable(new DelegatingUserContextCallable&lt;T&gt;(callable, UserContextHolder.getContext()))//注入callable实现，它将设置UserContext : super.wrapCallable(new DelegatingUserContextCallable&lt;T&gt;(callable, UserContextHolder.getContext())); }} 除了复用Spring Cloud已经定义好的HystrixConcurrencyStrategy方法，还要传递给callable实现DelegatingUserContextCallable， 将UserContext这个执行用户REST服务的父线程，设置成保护正在进行工作的方法的Hystrix命令线程 定义Callable类，将UserContext注入Hystrix命令中上述代码将DelegatingUserContextCallable类设置到并发策略当中，该类具体实现如下 12345678910111213141516171819202122232425public final class DelegatingUserContextCallable&lt;V&gt; implements Callable&lt;V&gt; { private final Callable&lt;V&gt; delegate; private UserContext originalUserContext; public DelegatingUserContextCallable(Callable&lt;V&gt; delegate, UserContext userContext) { this.delegate = delegate;//Hystrix保护的代码，目的将该线程与父线程相联系 this.originalUserContext = userContext;//父线程的UserContext } public V call() throws Exception {//call方法被@HystrixCommand注解保护前被调用 UserContextHolder.setContext( originalUserContext );//ThreadLocal变量与受@Hystrix保护的方法所在的线程相关联 try { return delegate.call();//UserContext设置后，Hystrix保护的方法上调用call()方法，如LicenseServevice.getLicenseByOrg(0方法) } finally { this.originalUserContext = null; } } public static &lt;V&gt; Callable&lt;V&gt; create(Callable&lt;V&gt; delegate, UserContext userContext) { return new DelegatingUserContextCallable&lt;V&gt;(delegate, userContext); }} 调用Hystrix保护的方法后， （1）Hystrix和Spring Cloud将实例化DelegatingUserContextCallable类的一个实例 （2）该实例传入Hystrix命令池管理的线程调用的Callable类。如上述代码，该Callable类存储在名为delegate的Java属性中 call()方法在调用Hystrix保护的方法前调用 call方法中，UserContext从发起调用的父线程传递出去，在DelegatingUserContextCallable实例创建时设置，在类的call方法中传递出去 call方法的setContext设置UserContext，将UserContext存储在ThreadLocal变量中，该ThreadLocal特定于正在运行的Hystrix线程中 设置完成后，就会调用Callable类的call方法，即Hystrix注解保护的方法 配置Spring Cloud，使用自定义Hystrix并发策略刚才的工作： （1）实现并发策略类，复用已存在的安全策略，重写wrapCallable方法以绑定策略，实现Hystrix线程和父线程上下文相联系 （2）Callable类将ThreadLocal的内容传递给Hystrix管理的线程 配置好自定义并发策略之后，需要将该策略与SpringCloud和Hystrix挂钩，具体如下 123456789101112131415161718192021222324252627@Configurationpublic class ThreadLocalConfiguration { @Autowired(required = false) private HystrixConcurrencyStrategy existingConcurrencyStrategy; @PostConstruct public void init() { // Keeps references of existing Hystrix plugins. HystrixEventNotifier eventNotifier = HystrixPlugins.getInstance() .getEventNotifier(); HystrixMetricsPublisher metricsPublisher = HystrixPlugins.getInstance() .getMetricsPublisher(); HystrixPropertiesStrategy propertiesStrategy = HystrixPlugins.getInstance() .getPropertiesStrategy(); HystrixCommandExecutionHook commandExecutionHook = HystrixPlugins.getInstance() .getCommandExecutionHook(); HystrixPlugins.reset();//上面保留已存在策略，下面添加新策略 HystrixPlugins.getInstance().registerConcurrencyStrategy(new ThreadLocalAwareStrategy(existingConcurrencyStrategy));//添加新的并发策略 //重新注册Hystrix插件的所有组件 HystrixPlugins.getInstance().registerEventNotifier(eventNotifier); HystrixPlugins.getInstance().registerMetricsPublisher(metricsPublisher); HystrixPlugins.getInstance().registerPropertiesStrategy(propertiesStrategy); HystrixPlugins.getInstance().registerCommandExecutionHook(commandExecutionHook); }} 最后重新编译运行项目，发现在Hystrix保护的方法中可以获取到父线程ThreadLocal的内容了","link":"/2021/05/16/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%B9%E6%80%A7%E6%A8%A1%E5%BC%8F/"},{"title":"服务路由","text":"跨多个服务调用的横切关注点：安全、日志记录、用户跟踪 直接构建这些功能的问题 每个服务很难始终实现这些功能 正确地实现这些功能是个挑战 所有服务中创建顽固依赖，难以在无需重新编译和部署的情况下添加新功能，共享库的核心功能升级也变得困难 解决方法服务网关：将这些横切关注点抽象成独立的，且作为应用程序中所有微服务调用的过滤器和路由器的服务。服务网关作为单个策略执行点，所有调用都通过其进行路由，然后被路由到最终目的地 Spring Cloud 和 Netflix的Zuul 所有服务调用放在一个URL下面，使用服务发现映射到实际的服务实例 对流经服务网关的每个服务调用注入关联ID 从客户端发回的HTTP响应中注入关联ID 构建动态路由机制，将各个组织路由到服务实例端点，该端点与其他人使用的服务实例端点不同 服务网关没有网关：直接调用服务，开发人员没法轻易实现诸如安全性或日志记录之类的横切关注点 有网关：客户端调用服务网关来调用服务，服务网关分离被调用的URL；此外还充当中央策略执行点，使得横切关注点在一个地方实现 横切关注点种类： 静态路由，服务设置单个URL后面 动态路由，根据请求和调用者身份进行智能路由（如参与测试版的客户可以路由到测试版本服务集群） 验证与授权，服务网关用于检查服务调用者是否进行验证并被授权进行服务调用的场所 度量数据收集和日志记录，不应该在单个服务上收集数据和日志记录，而是通过服务网关集中收集 1234构建服务网关的注意点：负载均衡器可能成为瓶颈代码无状态，不存信息代码轻量 Spring Cloud 和 Netflix ZuulZuul功能 所有服务的路由映射到一个URL，可定义多个路由条目，使路由映射非常细粒度 构建对网关请求进行检测和操作的过滤器 建立Zuul SpringBoot项目1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;&lt;/dependency&gt; 为Zuul服务使用Spring Cloud注解123@SpringBootApplication@EnableZuulProxypublic class ZuulServerApplication {} 配置Zuul与Eureka进行通信Zuul中配置路由Zuul核心：反向代理 反向代理：位于客户端和资源之间，负责捕获客户端的请求，然后代表客户端调用远程资源 Zuul将客户端调用映射到下游路由的几种机制： 通过服务发现自动映射路由 通过服务发现手动映射路由 通过静态URL手动映射路由 通过服务发现自动映射路由Zuul可以根据eureka服务ID自动路由请求，而不需要配置 例如调用http://localhost:5555/organizationservice/v1/organizations/e254f8c-c442-4ebe-a82a-e2fc1d1ff78a 这里服务名称（organizationservice）充当服务网关查找服务物理位置的键 通过Eureka实现添加和删除服务实例，无需修改Zuul而实现自动路由 可以访问http://localhost:5555/routes来访问Zuul服务器管理的路由 使用服务发现手动映射路由可以通过手动配置明确定义路由映射，来缩短组织名称，简化路由，而非单纯依赖EurekaID创建的自动路由 在zuulsvr的application.yml中 1234zuul: routes: organizationservice: /organization/** licensingservice: /licensing/** 即可自定义映射 配置完eurekaID自动路由依然存在 可通过配置排除这些自动映射的路由 123456zuul: # ignored-services: 'organizationservice' ignored-services: '*' routes: organizationservice: /organization/** licensingservice: /licensing/** 也可通过使用/api之类的标记为所有服务增加前缀 12zuul: prefix: /api 最终路由映射 使用静态URL手动映射路由Zuul可以路由不受Eureka管理的服务，例如一些python编写的服务等 12345zuul: routes: licensestatic: path: /licensestatic/** # 静态路由 url: http://licenseservice-static:8081 # 已建立许可证服务的静态实例，被直接调用而不是Eureka调用 问题：绕过Eureka，只有一条路径可以指向请求 开发人员可以手动配置Zuul来禁用Ribbon与Eureka集成，然后配置Ribbon将进行负载均衡的各个服务实例 12345678910111213zuul: routes: licensestatic: path: /licensestatic/** # 静态路由 serviceId: licensestatic # 定义一个服务ID，用于在Ribbon中查找服务ribbon: eureka: enabled: false #ribbon中禁用eureka支持licensestatic: ribbon: # 为licensestatic服务映射到多个路由并实现负载均衡 listOfServers: http://licenseservice-static1:8081, http://licenseservice-static2:8082 # 指定请求会路由到的服务器列表 处理非JVM任务的时候建议建立Sidecar实例，通过该实例可以让Eureka注册飞JVM任务 动态重新加载路由配置允许不回收服务器情况下更改路由映射，快速添加修改新的路由 在config实例中添加zuulservice文件夹，从中添加zuulservice.yml、zuulservice-dev.yml和zuulservice-prod.yml即可 将Zuul配置信息迁移进去 1234zuul.ignored-services: '*'zuul.prefix: /apizuul.routes.organizationservice: /organziation/**zuul.routes.licensingservice: /licensing/** Zuul公开了POST端点路由/refresh，可以让Zuul重新加载路由配置 Zuul和服务超时Zuul使用Netflix的Hystrix和Ribbon库来设置服务超时 1hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 2500 也可在服务中配置来覆盖掉config中的配置 Netflix Ribbon同样会超时5s的调用，可通过servicename.ribbon.ReadTimeout覆盖Ribbon超时 过滤器横切关注点：流经网关的服务调用的，自定义的，强制执行的，一组一致的应用程序策略 拦截行为，原始编码人员意识不到的情况下对调用行为进行更改 定义多个微服务请求在执行时都会经过的业务逻辑链 支持以下3种类型的过滤器 前置过滤器：发送目的地之前被调用（例如验证授权、消息格式是否妥当） 后置过滤器：响应返回客户端使调用（处理错误或审核敏感信息） 路由过滤器：调用服务之前拦截调用，确定是否进行某些级别的动态路由（如让少量用户路由到新版本以体验新功能） 根据这三种类型，对于EagleEye服务，定义如下过滤器 （1）TrackingFilter——TrackingFilter是前置过滤器，保证每个请求都有相关的关联ID，该ID是唯一的，用于跟踪一个调用经过一系列微服务调用发生的事件链 （2）SpecialRoutesFilter——路由过滤器，检查传入的路由是否需要进行A/B测试，即少数用户尝试新版本 （3）ResponseFilter——后置过滤器，将关联ID注入HTTP响应首部，访问与其发出的请求相关联的响应 构建前置过滤器要求检查所有到网关的传入请求，确定是否存在名为tmx-correlation-id的首部，该首部包含全局唯一通用ID，用于跟踪用户请求 如果不存在tmx-correlation-id，将生成并设置关联ID。 如果已经存在，则不会进行任何操作 实现TrackingFilter.java中实现如下代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Componentpublic class TrackingFilter extends ZuulFilter{//必须扩展ZuulFilter类并覆盖四个方法 private static final int FILTER_ORDER = 1; private static final boolean SHOULD_FILTER=true; private static final Logger logger = LoggerFactory.getLogger(TrackingFilter.class); @Autowired FilterUtils filterUtils;//封装所有过滤器使用的常用方法 @Override public String filterType() { return FilterUtils.PRE_FILTER_TYPE;//告诉Zuul该过滤器的类型 } @Override public int filterOrder() { return FILTER_ORDER;//指示不同类型过滤器的执行顺序 } public boolean shouldFilter() { return SHOULD_FILTER;//返回一个BOOL值类型指示该过滤器是否执行 } private boolean isCorrelationIdPresent(){ if (filterUtils.getCorrelationId() !=null){ return true; } return false; } private String generateCorrelationId(){//检查tmx-correlation-id是否存在，并且可以生产关联ID的值 return java.util.UUID.randomUUID().toString(); } public Object run() {//检查tmx-corelation-id是否存在，如果不存在则生成关联至，并设置HTTP首部tmx-correlation-id if (isCorrelationIdPresent()) { logger.debug(&quot;tmx-correlation-id found in tracking filter: {}. &quot;, filterUtils.getCorrelationId()); } else{ filterUtils.setCorrelationId(generateCorrelationId()); logger.debug(&quot;tmx-correlation-id generated in tracking filter: {}.&quot;, filterUtils.getCorrelationId()); } RequestContext ctx = RequestContext.getCurrentContext(); logger.debug(&quot;Processing incoming request for {}.&quot;, ctx.getRequest().getRequestURI()); return null; }} 这里实现FilterUtils类，get/set关键方法的代码如下 1234567891011121314public String getCorrelationId(){ RequestContext ctx = RequestContext.getCurrentContext(); if (ctx.getRequest().getHeader(CORRELATION_ID) !=null) {//检查是否设置，未设置则检查ZuulRequestHeaders，这是一个单独维护的HTTP首部映射，由setCorrealtionId创建 return ctx.getRequest().getHeader(CORRELATION_ID); } else{ return ctx.getZuulRequestHeaders().get(CORRELATION_ID); }}public void setCorrelationId(String correlationId){ RequestContext ctx = RequestContext.getCurrentContext(); ctx.addZuulRequestHeader(CORRELATION_ID, correlationId);//将correlationId注入HTTP头部} 在服务调用中使用关联ID如何确保： 正在被调用的微服务很容易访问到关联ID 下游服务调用微服务时可能会将关联ID传播到其它下游服务中 解决方案这里添加UserContextFilter类，将关联ID传到UserContext类，UserContext存储在本地线程存储中，以便稍后调用中使用 许可证业务需要对组织服务进行调用 RestTemplate用于调用组织服务，其使用自定义Spring拦截器类（UserContextInterceptor）将关联ID作为HTTP首部注入出站调用 UserContextFilter：拦截传入HTTP请求1234567891011121314@Overridepublic void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest; UserContextHolder.getContext().setCorrelationId( httpServletRequest.getHeader(UserContext.CORRELATION_ID) );//检索出首部的关联ID，并将值设置在UserContext中 UserContextHolder.getContext().setUserId(httpServletRequest.getHeader(UserContext.USER_ID)); UserContextHolder.getContext().setAuthToken(httpServletRequest.getHeader(UserContext.AUTH_TOKEN)); UserContextHolder.getContext().setOrgId(httpServletRequest.getHeader(UserContext.ORG_ID)); logger.debug(&quot;Special Routes Service Incoming Correlation id: {}&quot;, UserContextHolder.getContext().getCorrelationId()); filterChain.doFilter(httpServletRequest, servletResponse);} UserContext：使访问HTTP首部变得方便123456789101112131415161718192021222324252627282930313233343536373839404142@Componentpublic class UserContext { public static final String CORRELATION_ID = &quot;tmx-correlation-id&quot;; public static final String AUTH_TOKEN = &quot;tmx-auth-token&quot;; public static final String USER_ID = &quot;tmx-user-id&quot;; public static final String ORG_ID = &quot;tmx-org-id&quot;; private String correlationId= new String(); private String authToken= new String(); private String userId = new String(); private String orgId = new String(); public String getCorrelationId() { return correlationId;} public void setCorrelationId(String correlationId) { this.correlationId = correlationId; } public String getAuthToken() { return authToken; } public void setAuthToken(String authToken) { this.authToken = authToken; } public String getUserId() { return userId; } public void setUserId(String userId) { this.userId = userId; } public String getOrgId() { return orgId; } public void setOrgId(String orgId) { this.orgId = orgId; }} userContext提供geter和seter方法，保存HTTP请求中获取的值，使用一个UserContextHolder类将UserContext存储在ThreadLocal中 123456789101112131415161718192021222324public class UserContextHolder { private static final ThreadLocal&lt;UserContext&gt; userContext = new ThreadLocal&lt;UserContext&gt;(); public static final UserContext getContext(){ UserContext context = userContext.get(); if (context == null) { context = createEmptyContext(); userContext.set(context); } return userContext.get(); } public static final void setContext(UserContext context) { Assert.notNull(context, &quot;Only non-null UserContext instances are permitted&quot;); userContext.set(context); } public static final UserContext createEmptyContext(){ return new UserContext(); }} 自定义RestTemplate和UserContextInteceptor：确保关联ID被传播将关联ID注入HTTP传出服务请求中，这些请求由RestTemplate实例执行 为了建立服务调用之间的联系，需要使用一个拦截器，将UserContext注入RestTemplate类中， UserContextInterceptor拦截器代码如下 12345678910111213public class UserContextInterceptor implements ClientHttpRequestInterceptor { @Override public ClientHttpResponse intercept( HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException {//该方法在RestTemplate发生实际调用之前被调用 HttpHeaders headers = request.getHeaders(); headers.add(UserContext.CORRELATION_ID, UserContextHolder.getContext().getCorrelationId());//往传出的HTTp头部添加关联ID headers.add(UserContext.AUTH_TOKEN, UserContextHolder.getContext().getAuthToken()); return execution.execute(request, body); }} 为了使用上述拦截器，需要在RestTemplate bean创建之后把UserContextInterceptor添加进去 1234567891011121314@LoadBalanced//表明使用Ribbon@Beanpublic RestTemplate getRestTemplate(){ RestTemplate template = new RestTemplate(); List interceptors = template.getInterceptors(); if (interceptors==null){//将UserContextInterceptor添加到RestTemplate实例中 template.setInterceptors(Collections.singletonList(new UserContextInterceptor())); } else{ interceptors.add(new UserContextInterceptor()); template.setInterceptors(interceptors); } return template;} 构建接收关联ID的后置过滤器Zuul可以检查响应，然后以额外信息装饰它 后置过滤特别适合收集指标并完成用户事务相关的日志记录 这里我们将用户的关联ID传回用户，我们使用后置过滤器将关联ID注入HTTP响应首部 过滤器ResponseFilter.java代码如下 123456789101112131415161718192021222324252627282930313233343536@Componentpublic class ResponseFilter extends ZuulFilter{ private static final int FILTER_ORDER=1; private static final boolean SHOULD_FILTER=true; private static final Logger logger = LoggerFactory.getLogger(ResponseFilter.class); @Autowired FilterUtils filterUtils; @Override public String filterType() {//后置过滤器，设置过滤器类型为后置 return FilterUtils.POST_FILTER_TYPE; } @Override public int filterOrder() { return FILTER_ORDER; } @Override public boolean shouldFilter() { return SHOULD_FILTER; } @Override public Object run() { RequestContext ctx = RequestContext.getCurrentContext(); logger.debug(&quot;Adding the correlation id to the outbound headers. {}&quot;, filterUtils.getCorrelationId()); ctx.getResponse().addHeader(FilterUtils.CORRELATION_ID, filterUtils.getCorrelationId());//将原始HTTP请求的关联ID传入响应 logger.debug(&quot;Completing outgoing request for {}.&quot;, ctx.getRequest().getRequestURI());//记录传出请求URI，记录Zuul的用户请求的传入和传出条目 return null; }} 构建动态路由过滤器SpecialRoutesFilter检索被调用服务的服务ID SpecialRoutesFilter调用SpeicalRoutes服务，查询是否有目标端点的替代端点（服务的新版本），如果有则分配权重 SpecialRoutesFilter生成随机数，并将它与SpecialRoutes返回的权重进行比较。大于权重则将请求发送到新版本 无论新老版本，都将通过后置过滤器将响应发送回来 构建路由过滤器骨架SpecialRoutesFilter除了run方法，其他方法都和其他过滤器差不多 实现run方法123456789101112131415@Overridepublic Object run() { RequestContext ctx = RequestContext.getCurrentContext(); AbTestingRoute abTestRoute = getAbRoutingInfo( filterUtils.getServiceId() );//确定该服务ID是否有路由记录 if (abTestRoute!=null &amp;&amp; useSpecialRoute(abTestRoute)) {//useSpecialRoute将会创建路径权重，生成一个随机数，以确定是否将请求转发到替代服务 String route = buildRouteString(ctx.getRequest().getRequestURI(), abTestRoute.getEndpoint(), ctx.get(&quot;serviceId&quot;).toString());//有路由记录则将完整URL构建到由specialroutes服务指定的服务位置 forwardToSpecialRoute(route);//forwardToSpecialRoute()实现路由转发工作 } return null;} 路由记录：记录需要走路由的服务（这种服务大都有多个版本可以选择） 调用SpecialRouteservice以查看路由记录是否存在1234567891011121314private AbTestingRoute getAbRoutingInfo(String serviceName){ ResponseEntity&lt;AbTestingRoute&gt; restExchange = null; try { restExchange = restTemplate.exchange( &quot;http://specialroutesservice/v1/route/abtesting/{serviceName}&quot;, HttpMethod.GET, null, AbTestingRoute.class, serviceName); } catch(HttpClientErrorException ex){ if (ex.getStatusCode()== HttpStatus.NOT_FOUND) return null; throw ex; } return restExchange.getBody();} 确定了路由记录存在，则需要确定是否要将目标服务请求路由到替代服务位置，或者默认的服务位置 1234567891011public boolean useSpecialRoute(AbTestingRoute testRoute){ Random random = new Random(); if (testRoute.getActive().equals(&quot;N&quot;)) return false;//检查路由是否为活跃状态 int value = random.nextInt((10 - 1) + 1) + 1;//确定是否使用替代路由 if (testRoute.getWeight()&lt;value) return true; return false;} 转发路由通过Zuul提供的辅助方法，forwardToSpecialRoute()实现转发路由工作 12345678910111213141516171819202122232425262728293031323334353637private ProxyRequestHelper helper = new ProxyRequestHelper();//提供用于代理服务请求的辅助方法private void forwardToSpecialRoute(String route) { RequestContext context = RequestContext.getCurrentContext(); HttpServletRequest request = context.getRequest(); MultiValueMap&lt;String, String&gt; headers = this.helper .buildZuulRequestHeaders(request);//创建转发到服务的HTTP头部副本 MultiValueMap&lt;String, String&gt; params = this.helper .buildZuulRequestQueryParams(request);//创建HTTP请求参数副本 String verb = getVerb(request); InputStream requestEntity = getRequestBody(request);//创建HTTP请求的主体的副本 if (request.getContentLength() &lt; 0) { context.setChunkedRequestBody(); } this.helper.addIgnoredHeaders(); CloseableHttpClient httpClient = null; HttpResponse response = null; try { httpClient = HttpClients.createDefault(); response = forward(httpClient, verb, route, request, headers, params, requestEntity);//使用forward()辅助方法调用替代服务 setResponse(response);//将服务调用的响应结果保存回Zuul服务 } catch (Exception ex ) { ex.printStackTrace(); } finally{ try { httpClient.close(); } catch(IOException ex){} }} 整合许可证服务调用组织服务，SpecialRoutes中对应的数据库里面有组织服务的数据库记录，该记录指示50%概率把组织服务请求路由到现有服务，50%概率路由到替代组织服务 替代组织服务路径是http://orgservice-new，为了区分，将OLD::和NEW::添加到联系人姓名字段前缀上 发现路由过滤使得请求传到了替代服务那里 注意：启动项目的时候，一定要先启动配置服务，不然有些服务可能加载不到自己的配置而且不会瞬间报错","link":"/2021/05/20/%E6%9C%8D%E5%8A%A1%E8%B7%AF%E7%94%B1/"}],"tags":[{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"状态压缩","slug":"状态压缩","link":"/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"},{"name":"Trie树","slug":"Trie树","link":"/tags/Trie%E6%A0%91/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"《深入理解Java虚拟机》","slug":"《深入理解Java虚拟机》","link":"/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/"},{"name":"《高并发程序设计》","slug":"《高并发程序设计》","link":"/tags/%E3%80%8A%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"},{"name":"堆排序","slug":"堆排序","link":"/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"微服务","slug":"微服务","link":"/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"双向链表","slug":"双向链表","link":"/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"},{"name":"hashmap","slug":"hashmap","link":"/tags/hashmap/"}],"categories":[{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"面试","slug":"面试","link":"/categories/%E9%9D%A2%E8%AF%95/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"hexo说明","slug":"hexo说明","link":"/categories/hexo%E8%AF%B4%E6%98%8E/"}]}