<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Hexo"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Hexo"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Hexo","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/lrj1996123"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-25T14:19:57.000Z" title="2021-3-25 10:19:57 ├F10: PM┤">2021-03-25</time>发表</span><span class="level-item"><time dateTime="2021-03-25T15:28:27.536Z" title="2021-3-25 11:28:27 ├F10: PM┤">2021-03-25</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span><span class="level-item">8 分钟读完 (大约1130个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA2/">深入理解Java虚拟机2</a></h1><div class="content"><h2 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h2><p>线程共享区域：<strong>Java堆</strong>和<strong>方法区</strong>内存分配和回收不确定性</p>
<p>接口多个实现类，方法执行不同的条件分支，所占用的内存都可能不一样</p>
<p>这些部分内存的分配和回收是<strong>动态</strong>的，只有处于运行期间才知道</p>
<h3 id="判定对象是否存活"><a href="#判定对象是否存活" class="headerlink" title="判定对象是否存活"></a>判定对象是否存活</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>简介：对象添加一个引用计数器，每有一个地方引用，计数器加一；引用失效，计数器减一。任何时刻计数器为零的对象就是不能被再使用的  </p>
<p>Java没有采用</p>
<p>问题：很多例外情况没有考虑，需要大量额外处理，例如引用计数很难解决对象之间循环引用的问题</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>简介：通过一系列称为:”GC Roots”的根对象作为起始节点集，从这些节点的引用关系向下搜索，走过的路径称为<strong>引用链</strong>，如果对象到GCRoots之间没有引用链相连，证明对象不可能被再使用</p>
<p>Java采用</p>
<p>GCRoots对象</p>
<ol>
<li>虚拟机栈中引用的对象，各个线程被调用的方法堆栈中用到的参数、局部变量、临时变量等</li>
<li>方法区中类静态属性引用的对象，引用类型静态变量</li>
<li>常量引用的对象，字符串常量池中的引用</li>
<li>本地方法栈中native方法引用的对象</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的class对象，常驻异常对象，还有系统类加载器</li>
<li>所有被同步锁持有的对象</li>
<li>反映虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等等</li>
</ol>
<p>除了这些，还可根据垃圾回收器以及当前回收的内存区域不同，选择其他对象临时性加入</p>
<p>例如，分代收集和<strong>局部回收</strong>，局部回收某个内存区域，该可能有其他区域引用该区域，所以将这些关联区域的对象也一并加入GC Roots集合中，保证可达分析正确性</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>reference：存储的数值代表另一块内存的起始地址</p>
<p>希望描述一类对象：内存空间足够时，还能保存在内存中，而紧张时则可以抛弃——缓存</p>
<p>JDK1.2之后，细分了引用概念</p>
<p>强引用：Object obj = new Object() 只要存在则不会被回收</p>
<p>软引用：还有用，但非必须，在溢出异常发生前，会列入回收范围进行二次回收，回收完如果还是内存不足则发生内存溢出异常</p>
<p>弱引用：强度比软引用更弱，描述非必须对象，只能生存到下次垃圾收集发生为止</p>
<p>虚引用：最弱，无法取得对象实例，唯一目的是垃圾回收时收到一个系统通知</p>
<h4 id="判定对象生存还是死亡"><a href="#判定对象生存还是死亡" class="headerlink" title="判定对象生存还是死亡"></a>判定对象生存还是死亡</h4><p>判定不可达——》被标记——》对标记对象进行一次筛选，条件是是否有必要执行finalize()方法</p>
<p>没有必要或已经被虚拟机调用：视为没有必要执行</p>
<p>有必要执行：置入F-Queue队列，用<strong>Finalizer线程</strong>（优先级低）调用它们去执行finalize方法，对F-Queue进行第二次小规模标记，只要该对象重新和引用链上任何一个对象建立关联便可存活，从而将其移出“即将回收集合”</p>
<h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p>方法区垃圾收集：废弃的常量和不再使用的类型</p>
<p>判断类型不再被使用的条件：</p>
<ol>
<li>该类所有实例都已经被回收</li>
<li>加载该类的类加载器已经被回收</li>
<li>该类的java.lang.Class对象没有在任何地方被引用，也无法在任何地方通过反射访问该类的方法</li>
</ol>
<p>大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，都需要Java虚拟机具备<strong>类型卸载</strong>能力</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-16T04:09:47.000Z" title="2021-3-16 12:09:47 ├F10: PM┤">2021-03-16</time>发表</span><span class="level-item"><time dateTime="2021-03-24T08:59:52.273Z" title="2021-3-24 4:59:52 ├F10: PM┤">2021-03-24</time>更新</span><span class="level-item">几秒读完 (大约0个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/16/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB1-%E3%80%8AAttention-based-LSTM-for-Aspect-level-Sentiment-Classification%E3%80%8B/">文献阅读1.《Attention-based LSTM for Aspect-level Sentiment Classification》</a></h1><div class="content"></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-15T11:24:20.000Z" title="2021-3-15 7:24:20 ├F10: PM┤">2021-03-15</time>发表</span><span class="level-item"><time dateTime="2021-03-24T15:00:27.428Z" title="2021-3-24 11:00:27 ├F10: PM┤">2021-03-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span><span class="level-item">16 分钟读完 (大约2354个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA1/">深入理解Java虚拟机1</a></h1><div class="content"><h2 id="Java内存区域与内存溢出异常"><a href="#Java内存区域与内存溢出异常" class="headerlink" title="Java内存区域与内存溢出异常"></a>Java内存区域与内存溢出异常</h2><p>Java虚拟机自动内存管理机制，不需要为每个new操作去写配对的delete/free，不容易出现内存泄漏和内存溢出问题。</p>
<p>但是，控制内存的权利交给了Java虚拟机，一旦出现内存泄漏和内存溢出问题，排查错误并修正将会异常艰难。</p>
<h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>当前线程所执行字节码的行号指示器：字节码解释器通过改变计数器的值来选取下一条需要执行的字节码指令</p>
<p>程序控制流的指示器：分支、循环、跳转、异常处理、线程恢复等都依赖该计数器</p>
<p>多线程：线程轮流切换，分配处理器执行时间，任何一个确定时刻，一个处理器内核只会执行一条线程中的指令</p>
<p>线程私有：切换线程时，为了能够回到正确位置，每条线程都需要有个独立的程序计数器</p>
<h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>线程私有：生命周期和线程相同</p>
<p>Java方法执行的线程内存模型：方法被执行，Java虚拟机同步创建一个栈帧</p>
<p>JVM创建的栈帧：存储局部变量表、操作数栈、动态连接、方法出口等信息，</p>
<p>每一个方法被调用到执行完毕  &lt;——&gt; 一个栈帧从虚拟机栈入栈到出栈</p>
<h5 id="局部变量表：“栈”"><a href="#局部变量表：“栈”" class="headerlink" title="局部变量表：“栈”"></a>局部变量表：“栈”</h5><p>存放JVM<strong>基本数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference类型，它并不等同于对象本身，而是一个指向对象起始位置的引用指针，也可能指向一个代表对象的句柄或其他与此对象相关的位置）和<strong>returnAddress类型</strong>（指向了一条字节码指令的地址）</p>
<p>局部变量槽（Slot）：存储这些数据类型，除了long和double占用2个，其余占用1个</p>
<p>局部变量空间确定：进入一个方法时，局部变量空间大小（变量槽的数量）确定</p>
<p>内存区域异常：</p>
<p>StackOverflow异常：线程请求的深度大于虚拟机允许的深度</p>
<p>OutOfMemoryError异常：栈可以动态扩展的虚拟机（Hotspot不会）扩展时无法申请到足够内存会抛出OutOfMemoryError异常</p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>类似虚拟机栈，但本地方法栈为JVM用到的本地方法服务</p>
<p>异常和虚拟机栈类似</p>
<h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>JVM内存最大的一块</p>
<p>所有线程共享</p>
<p>存放对象实例和数组（几乎所有，但不一定，逃逸分析技术、栈上分配、标量替换优化手段导致一些微妙变化）</p>
<p><strong>垃圾回收器</strong>管理Java堆（GC堆）</p>
<p><strong>线程私有</strong>的<strong>分配缓冲区</strong>（TLAB）：提升对象分配效率,目的只是更好回收内存，更快分配内存</p>
<p>物理上不连续，逻辑上连续，但大对象可能要求连续</p>
<p>可扩展可固定大小：主流可扩展，没有完成实例分配，堆无法再扩展时，会抛出OutOfMemoryError异常</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>线程共享</p>
<p>存储JVM加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>
<p>本地空间实现元空间来代替永久代</p>
<p>不需连续内存，可选择固定大小或可扩展，甚至可以选择不实现垃圾收集</p>
<p>回收效果不好，尤其是类型的卸载，但有时又很有必要</p>
<p>OutOfMemoryError</p>
<h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>常量池表：编译期生成的各种字面量与符号引用，类加载后存放到方法区的运行时常量池中。</p>
<p>动态性：常量不一定只有编译期才能产生，String intern()</p>
<p>OutOfMemoryError</p>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>通道+缓冲区直接操作Native函数库分配堆外内存，通过DirectByteBuffer对象作为这块内存的引用，从而提高性能</p>
<h3 id="HotSpot虚拟机"><a href="#HotSpot虚拟机" class="headerlink" title="HotSpot虚拟机"></a>HotSpot虚拟机</h3><h4 id="HotSpot虚拟机Java堆中对象的创建"><a href="#HotSpot虚拟机Java堆中对象的创建" class="headerlink" title="HotSpot虚拟机Java堆中对象的创建"></a>HotSpot虚拟机Java堆中对象的创建</h4><p>检测到字节码<strong>new指令</strong></p>
<p>检查new指令的参数能否在<strong>常量池</strong>中定位到一个类的<strong>符号引用</strong></p>
<p>检查该符号引用代表的类是否已被加载，否则必须先执行<strong>类加载</strong></p>
<p>类加载检查通过后，虚拟机为新生对象分配内存。（类加载后对象所需内存大小即可完全确定）</p>
<p>给对象分配内存=把一块确定大小的内存从Java堆中划分出来</p>
<p>指针碰撞：假设所有被使用过的内存都放到一边，空闲内存放另一边，指针指向中间的分界点，内存分配就是向空闲内存一边挪动与新生对象大小相等的距离</p>
<p>空闲列表：已被使用的内存和空闲的内存相互交错在一起，虚拟机必须维护一个列表，记录哪些内存块可用，分配时在列表中找一块足够大的空间给对象实例，并更新表上的记录</p>
<p>如何选择分配内存方式？——Java堆是否规整决定</p>
<p>是否规整？——gc是否带有<strong>空间压缩整理</strong>的能力决定，例如Serail、ParNew能指针碰撞，而CMS基于清除算法，理论上只能空闲列表</p>
<p><strong>对象创建频繁，并发时线程不安全</strong></p>
<p>解决方案：</p>
<p>1.同步处理分配内存空间的动作，采用CAS配上失败重试</p>
<p>2.内存分配的动作按照线程划分在不从空间中进行，即每个线程在Java堆中预先分配一小块内存（本地线程分配缓冲 TLAB），优先使用线程自己的本地缓冲区，只有用完了，分配新缓冲区时才需要同步锁定.</p>
<p>内存分配完成后，分配到的内存空间初始化为0值（不包括对象头），也可TLAB分配之前就初始化，保证可以直接使用这些对象</p>
<p>然后，JVM对对象进行必要设置：哪个类的实例、如何找到元数据信息、对象的哈希码（实际上调用hashCode时才计算）、对象GC分代年龄等信息。这些信息存放在<strong>对象头</strong>中</p>
<p>对象头设置方式不同：由JVM当前运行状态决定</p>
<p>对象诞生了</p>
<p>但是Java程序的视角，对象创建刚开始——构造函数，new指令跟随invokespecial指令，随后按照程序员的意愿初始化，才将对象创建完毕</p>
<h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>三部分：对象头、实例数据、对齐填充</p>
<h5 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h5><p>MarkWord：存储对象自身运行时数据，头信息是与对象自身定义的数据无关的额外存储成本，一个动态定义的数据结构</p>
<table>
<thead>
<tr>
<th>存储内容</th>
<th>标志位</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>对象哈希码（25）、对象分代年龄（4）</td>
<td>01</td>
<td>未锁定</td>
</tr>
<tr>
<td>指向锁记录的指针（1）</td>
<td>00</td>
<td>轻量级锁定</td>
</tr>
<tr>
<td>指向重量级锁的指针（1）</td>
<td>10</td>
<td>膨胀（重量级锁定）</td>
</tr>
<tr>
<td>空，不需要记录信息（1）</td>
<td>11</td>
<td>GC标记</td>
</tr>
<tr>
<td>偏向线程ID、偏向时间戳、对象分代年龄</td>
<td>01</td>
<td>可偏向</td>
</tr>
</tbody></table>
<p>类型指针：指向类型元数据的指针，确定是哪个类的实例。对象数据上不一定保留类型指针。如果是Java数组，对象头还要有一块记录数组长度的数据</p>
<p><strong>实例数据信息</strong></p>
<p>程序代码里面定义的各种类型的字段内容</p>
<p>存储顺序会受<strong>分配策略参数</strong>和<strong>定义顺序</strong>影响</p>
<p>默认分配顺序：longs/doubles、ints、shorts/chars、bytes/booleans、oops 相同宽度的字段一起存放</p>
<p>父类定义的变量在子类之前</p>
<p><strong>对齐填充</strong></p>
<p>占位符，HotSpot要求对象起始地址是<strong>8字节整数倍</strong></p>
<p>即任何对象大小是8字节整数倍</p>
<h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>reference数据：在栈上，来操作堆上的具体对象</p>
<p>如何定位访问堆中对象具体位置：</p>
<p>1.句柄访问，Java堆中多出一块句柄池，reference存储对象的句柄地址，而句柄包含对象实例数据地址和类型数据的地址信息</p>
<p>2.直接指针访问，reference存储的直接就是对象地址，而需要考虑Java堆中对象的内存布局</p>
<p>句柄的好处：对象被移动时只会改变句柄中的实例数据指针，而不需要修改reference指针</p>
<p>直接指针好处：速度快，HotSpot使用这种，使用Shenandoah手机也会有一次额外转发</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-15T09:23:14.000Z" title="2021-3-15 5:23:14 ├F10: PM┤">2021-03-15</time>发表</span><span class="level-item"><time dateTime="2021-03-15T10:03:13.593Z" title="2021-3-15 6:03:13 ├F10: PM┤">2021-03-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span><span class="level-item">1 分钟读完 (大约223个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/15/JAVA%E9%9D%A2%E8%AF%951/">JAVA实习面试经验1.阿里CBU简历评估</a></h1><div class="content"><h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><p>1.自我介绍</p>
<p>2.项目介绍</p>
<p>做过什么项目？。。。</p>
<p>在团队当中充当了什么角色？后端</p>
<p>遇到了什么困难？数据库设计、业务逻辑设计方面</p>
<p>参考其他什么项目？之前公司的项目</p>
<p><strong>自己在设计方面发挥亮眼的地方</strong>……..这里需要</p>
<p>通过E-R图介绍自己项目的数据之间的关系等</p>
<p>Springboot和Spring相比的优势</p>
<p>古德拜</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>复习到的基础知识都没有问0.0</p>
<p>注重项目经验，一定要<strong>理清楚项目数据库中的各种设计</strong></p>
<p>分析自己在项目之中<strong>发挥的作用，解决的难题</strong></p>
<p>新技术的运用，想办法扯进去一点</p>
<h2 id="后续工作"><a href="#后续工作" class="headerlink" title="后续工作"></a>后续工作</h2><p>阅读《深入浅出JVM虚拟机》并做笔记</p>
<p>学习spring cloud和kafka</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-08T03:10:04.000Z" title="2021-3-8 11:10:04 ├F10: AM┤">2021-03-08</time>发表</span><span class="level-item"><time dateTime="2021-03-08T09:29:11.505Z" title="2021-3-8 5:29:11 ├F10: PM┤">2021-03-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/leetcode/">leetcode</a></span><span class="level-item">11 分钟读完 (大约1668个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/08/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%902-%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98/">算法分析2.俄罗斯套娃信封问题</a></h1><div class="content"><h3 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h3><p>给定二维数组envelopes，其中**envelopes[i] = [$w_i$,$h_i$]**，表示第i个信封的宽度和高度</p>
<p>要求：另一个信封的宽高都比这个信封大，这个信封就可以放进另一个信封里面，如同俄罗斯套娃，接连地一个套一个</p>
<p>计算最多能有多少个信封能组成一组“<strong>俄罗斯套娃信封序列</strong>”</p>
<p>注意：不允许旋转信封</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：envelopes &#x3D; [[5,4],[6,4],[6,7],[2,3]]</span><br><span class="line">输出：3</span><br><span class="line">解释：最多信封的个数为 3, 组合为: [2,3] &#x3D;&gt; [5,4] &#x3D;&gt; [6,7]。</span><br></pre></td></tr></table></figure>

<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;&#x3D; envelopes.length &lt;&#x3D; 5000</span><br><span class="line">envelopes[i].length &#x3D;&#x3D; 2</span><br><span class="line">1 &lt;&#x3D; wi, hi &lt;&#x3D; 104</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li><p>不允许旋转信封，即i套j的条件：$w_i &gt; w_j$ &amp;&amp; $h_i &gt; h_j$</p>
</li>
<li><p>因为需要分别对w和h进行排序，这里选择先对w升序排序</p>
</li>
<li><p>w已排好序，所以只需要通过判断h大小来进行套娃。但是，如果h也是升序排序，那么会导致同一大小的w中选择多个信封，然而只能从w相同的信封中选择一封</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">排完序的结果为[(w,h)]&#x3D;[(1,1),(1,2),(1,3),(1,4)]，由于这些信封的w值都相同，不存在一个信封可以装下另一个信封，那么我们只能在其中选择 11 个信封。然而如果我们完全忽略w维度，剩下的h维度为[1,2,3,4]，这是一个严格递增的序列，那么我们就可以选择所有的4个信封了，这就产生了错误。</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于w相同的信封只能从中选择一封，通过贪心策略得出，优先选择h小的，才能保证能有更多信封可以套它</p>
</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="一、-动态规划"><a href="#一、-动态规划" class="headerlink" title="一、 动态规划"></a>一、 动态规划</h3><p>将信封的w按照从小到大排序，然后<strong>w相同的信封的h按照从大到小排序</strong>，这样可以保证对于<strong>相同w的信封只能选择其中一封</strong></p>
<p>设f[i]为0~i的最长严格递增子序列的长度，</p>
<p>要求最后的选择为第i个信封，则倒数第二个选择的信封为$j$($j\lt i$)，遍历j，此时f[j]是已知的，所以如果第j个信封能够套入第i个信封，则0~i的最长递增子序列则为所有f[j]+1当中的最大值</p>
<p>由此得到状态转移公式<br>$$<br>f[i] = \max\limits_{j&lt;i \wedge d_j&lt;d_i}{f[j] + 1}<br>$$<br>得到代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (envelopes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = envelopes.length;</span><br><span class="line">        Arrays.sort(envelopes, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] e1, <span class="keyword">int</span>[] e2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (e1[<span class="number">0</span>] != e2[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> e1[<span class="number">0</span>] - e2[<span class="number">0</span>];<span class="comment">//w从小到大排序</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> e2[<span class="number">1</span>] - e1[<span class="number">1</span>];<span class="comment">//h从大到小排序</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//f[i]表示0~i可以组成的最大严格递增子序列，且必须选择第i个信封</span></span><br><span class="line">        Arrays.fill(f, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;<span class="comment">//选择第i个元素为最后一个所选择的信封</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;<span class="comment">//选择第j个元素为倒数第二个选择的信封</span></span><br><span class="line">                <span class="keyword">if</span> (envelopes[j][<span class="number">1</span>] &lt; envelopes[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                    f[i] = Math.max(f[i], f[j] + <span class="number">1</span>);<span class="comment">//这里f[i]初始化为1(第i个元素本身)，然后从所有f[j]+1中选择最大值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, f[i]);<span class="comment">//所有f当中的最大值即为答案</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、-二分查找-贪心算法"><a href="#二、-二分查找-贪心算法" class="headerlink" title="二、 二分查找+贪心算法"></a>二、 二分查找+贪心算法</h3><p>设f[j]为<strong>前i个元素可以组成的最长长度为j的严格递增子序列的末尾元素的h的最小值</strong></p>
<p>贪心思路：让序列上升得尽可能慢</p>
<p>f的性质：</p>
<ul>
<li><p>f值是严格单调递增的，因为越长的子序列末尾元素显然越大</p>
<p>证明：假设$f[j]\ge f[i]$且$j\lt i$ ，从长度为$i$的最长上升子序列末尾删除$i-j$个元素，那么这个序列长度变为j，末尾元素一定比i小，所以$f[j]’\lt f[i] \lt f[j] $ 但是f[j]是长度为j的递增子序列的最小值，所以矛盾</p>
</li>
<li><p>末尾元素是可以放的最小值</p>
<p>例如序列[1,2,3,6,4,5]中，1236和1234两个相同长度序列，只有f[3] = 4的时候，序列才可以变得更长</p>
</li>
</ul>
<p>状态转移方法：</p>
<p>考虑当前元素$h_{i}$</p>
<ul>
<li>$h_i$大于f中的最大值，那么$h_i$就可以接在f最大值之后</li>
<li>否则，从f中比$h_{i}$ 严格小的最大元素$f[j_{0}]$，得到$f[j_{0}]\lt h_{i} \lt f[j_{0} + 1]$ ,那么$h_{i} $就可以替换$f[j_{0}+1]$</li>
</ul>
<p>可以通过二分查找，找出满足要求的$j_{0}$</p>
<p>最终f的长度即为最长严格递增子序列的长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (envelopes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = envelopes.length;</span><br><span class="line">        Arrays.sort(envelopes, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] e1, <span class="keyword">int</span>[] e2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (e1[<span class="number">0</span>] != e2[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> e1[<span class="number">0</span>] - e2[<span class="number">0</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> e2[<span class="number">1</span>] - e1[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; f = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        f.add(envelopes[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//主要贪心策略</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = envelopes[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (num &gt; f.get(f.size() - <span class="number">1</span>)) &#123;</span><br><span class="line">                f.add(num);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> index = binarySearch(f, num);</span><br><span class="line">                f.set(index, num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f.size();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//二分查找，找到第一个大于target的元素的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;Integer&gt; f, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = f.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span> (f.get(mid) &lt; target) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他：二分查找变种"><a href="#其他：二分查找变种" class="headerlink" title="其他：二分查找变种"></a>其他：二分查找变种</h2><h3 id="一、二分查找寻找一个数（基本）"><a href="#一、二分查找寻找一个数（基本）" class="headerlink" title="一、二分查找寻找一个数（基本）"></a>一、二分查找寻找一个数（基本）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>; <span class="comment">// 注意，搜索空间为[left,right]的闭区间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123; <span class="comment">// 注意，left&gt;right表示搜索空间消失</span></span><br><span class="line">        <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意，搜索空间变为[mid+1,right]</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 注意，同上</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、二分查找寻找左侧边界（最左侧target下标）"><a href="#二、二分查找寻找左侧边界（最左侧target下标）" class="headerlink" title="二、二分查找寻找左侧边界（最左侧target下标）"></a>二、二分查找寻找左侧边界（最左侧target下标）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length; <span class="comment">// 注意,搜索空间为[left,right)的左闭右开区间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 注意,终止条件为left==right,即[left,left)</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;<span class="comment">//nums[mid]虽然等于target，但我们依然要在[left,mid)中搜索来锁定左侧边界</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; <span class="comment">// 注意，因为搜索空间是左闭右开，下一步搜索空间应该去掉mid即[left,mid)和[mid+1,right)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、-二分查找寻找右侧边界（最右侧target下标）"><a href="#三、-二分查找寻找右侧边界（最右侧target下标）" class="headerlink" title="三、 二分查找寻找右侧边界（最右侧target下标）"></a>三、 二分查找寻找右侧边界（最右侧target下标）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意，找到相等元素不要立刻返回，而是继续向右寻找[mid+1,right)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span>; <span class="comment">// 注意因为left=mid+1，所以最终left位置不等于target，所以left-1</span></span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-02T09:19:45.000Z" title="2021-3-2 5:19:45 ├F10: PM┤">2021-03-02</time>发表</span><span class="level-item"><time dateTime="2021-03-08T03:12:12.362Z" title="2021-3-8 11:12:12 ├F10: AM┤">2021-03-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/leetcode/">leetcode</a></span><span class="level-item">12 分钟读完 (大约1781个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/02/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%901-%E7%8C%9C%E5%AD%97%E8%B0%9C/">算法分析1.猜字谜</a></h1><div class="content"><h3 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h3><p>外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。</p>
<p>字谜的迷面 <strong>puzzle</strong> 按字符串形式给出，如果一个单词 <strong>word</strong> 符合下面两个条件，那么它就可以算作谜底：</p>
<ul>
<li><p>单词 <strong>word</strong> 中包含谜面 <strong>puzzle</strong> 的第一个字母。</p>
</li>
<li><p>单词 <strong>word</strong> 中的每一个字母都可以在谜面 <strong>puzzle</strong> 中找到。</p>
</li>
</ul>
<p>例如，如果字谜的谜面是 “<code>abcdefg</code>“，那么可以作为谜底的单词有 “<code>faced</code>“, “<code>cabbage</code>“, 和 “<code>baggage</code>“；而 “<code>beefed</code>“（不含字母 “a”）以及 “<code>based</code>“（其中的 “s” 没有出现在谜面中）都不能作为谜底。</p>
<p>返回一个答案数组 <strong>answer</strong>，数组中的每个元素 <strong>answer</strong>[i] 是在给出的单词列表 words 中可以作为字谜迷面 <strong>puzzles</strong>[i] 所对应的谜底的单词数目。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">words &#x3D; [&quot;aaaa&quot;,&quot;asas&quot;,&quot;able&quot;,&quot;ability&quot;,&quot;actt&quot;,&quot;actor&quot;,&quot;access&quot;], </span><br><span class="line">puzzles &#x3D; [&quot;aboveyz&quot;,&quot;abrodyz&quot;,&quot;abslute&quot;,&quot;absoryz&quot;,&quot;actresz&quot;,&quot;gaswxyz&quot;]</span><br><span class="line">输出：[1,1,3,2,4,0]</span><br><span class="line">解释：</span><br><span class="line">1 个单词可以作为 &quot;aboveyz&quot; 的谜底 : &quot;aaaa&quot; </span><br><span class="line">1 个单词可以作为 &quot;abrodyz&quot; 的谜底 : &quot;aaaa&quot;</span><br><span class="line">3 个单词可以作为 &quot;abslute&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;, &quot;able&quot;</span><br><span class="line">2 个单词可以作为 &quot;absoryz&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;</span><br><span class="line">4 个单词可以作为 &quot;actresz&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;, &quot;actt&quot;, &quot;access&quot;</span><br><span class="line">没有单词可以作为 &quot;gaswxyz&quot; 的谜底，因为列表中的单词都不含字母 &#39;g&#39;。</span><br></pre></td></tr></table></figure>

<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;&#x3D; words.length &lt;&#x3D; 10^5</span><br><span class="line">4 &lt;&#x3D; words[i].length &lt;&#x3D; 50</span><br><span class="line">1 &lt;&#x3D; puzzles.length &lt;&#x3D; 10^4</span><br><span class="line">puzzles[i].length &#x3D;&#x3D; 7</span><br><span class="line">words[i][j], puzzles[i][j] 都是小写英文字母。</span><br><span class="line">每个 puzzles[i] 所包含的字符都不重复。</span><br></pre></td></tr></table></figure>



<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li>word和puzzle均为小写字母，即由a~z26个字母组成</li>
<li>每个puzzle长度为7，所包含字符不重复</li>
<li>输出为每个puzzle对应的谜底word个数</li>
<li>要求puzzle含有word中每一个字母，且其中一个为puzzle首字母</li>
</ol>
<p>类似题型总结：<strong>字符串子集的匹配，不重复字符的子集，字符限制为小写或大写</strong></p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="一、二进制状态压缩"><a href="#一、二进制状态压缩" class="headerlink" title="一、二进制状态压缩"></a>一、二进制状态压缩</h3><p>由于words中的word含有重复字母，根据题意不考虑字母的个数，只判断字母的存在性，以此选择合适的表示方法</p>
<p>由于word中只包含小写英文字母a到z，所以word通过<strong>26位二进制</strong>来表示，0表示不存在，1表示存在</p>
<p>由于只利用的字母的存在性，可能有多个word的二进制表示是相同的，这里通过map来表示<strong>每种word的二进制表示的出现次数</strong></p>
<p>题目中要求输出每个puzzle（7位）所匹配的word个数，对puzzle的二进制表示，所以枚举每个puzzle的子集，特别地，该子集一定包含puzzle首字母，关于枚举这里有两个思路：</p>
<ul>
<li><p>思路一：<strong>枚举6位二进制数来选择puzzle1<del>6位所有的字母组合，以此遍历每个puzzle1</del>6位的子集</strong>，特别地，每次遍历都要加上puzzle第0位（题目要求word中必须有puzzle第0位的字母），代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findNumOfValidWords</span><span class="params">(String[] words, String[] puzzles)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; fre = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="comment">// word的二进制表示</span></span><br><span class="line">        <span class="keyword">for</span>(String word: words)&#123;</span><br><span class="line">            <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">                mask |= <span class="number">1</span> &lt;&lt; (word.charAt(i) - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(Integer.bitCount(mask) &lt;= <span class="number">7</span>)&#123;</span><br><span class="line">                fre.put(mask, fre.getOrDefault(mask, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String puzzle: puzzles)&#123;</span><br><span class="line">            <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 从000000到111111表示puzzle所有子集的组合形式，遍历这些子集</span></span><br><span class="line">            <span class="comment">// (puzzle第1位到第6位的子集，忽略第0位)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> choose = <span class="number">0</span>; choose &lt; (<span class="number">1</span> &lt;&lt; <span class="number">6</span>); choose++)&#123;</span><br><span class="line">                <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">                    <span class="comment">// choose表示puzzle子集的一种组合形式，通过&amp;操作来选取数字1对应的单词，0则忽略</span></span><br><span class="line">                    <span class="keyword">if</span>( (choose &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span> )&#123;</span><br><span class="line">                        mask |= <span class="number">1</span> &lt;&lt; (puzzle.charAt(i + <span class="number">1</span>) - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 要求谜底word中一定包含puzzle首字母，所以这里单独处理</span></span><br><span class="line">                mask |= <span class="number">1</span> &lt;&lt; (puzzle.charAt(<span class="number">0</span>) - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                <span class="comment">// 如果puzzle的子集（包含首字母）是谜底word，则将所有该形式加入</span></span><br><span class="line">                <span class="keyword">if</span>(fre.containsKey(mask))&#123;</span><br><span class="line">                    total += fre.get(mask);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(total);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>思路二：<strong>通过的位运算方法来枚举puzzle所有子集</strong>，对于puzzle1~6位的二进制表示mask，对subset初始化赋值mask，然后每次迭代进行如下操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subset = (subset - <span class="number">1</span>) &amp; mask</span><br></pre></td></tr></table></figure>

<p>由于subset中的1之间可能存在0，即不存在的字母和puzzle首位字母，所以对subset-1进行操作时，对subset-1和mask做“与”运算，保证不存在的字母永远不存在，实现了去冗，不断地减1使得subset中的1再次消失或再次出现，且保证subset越来越小，所以巧妙地遍历出所有子集</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findNumOfValidWords</span><span class="params">(String[] words, String[] puzzles)</span> </span>&#123;</span><br><span class="line">          Map&lt;Integer, Integer&gt; fre = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">          <span class="keyword">for</span>(String word: words)&#123;</span><br><span class="line">              <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">                  mask |= <span class="number">1</span> &lt;&lt; (word.charAt(i) - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span>(Integer.bitCount(mask) &lt;= <span class="number">7</span>)&#123;</span><br><span class="line">                  fre.put(mask, fre.getOrDefault(mask, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">          <span class="keyword">for</span>(String puzzle: puzzles)&#123;</span><br><span class="line">              <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">              <span class="comment">//对需要枚举的后六位进行二进制表示</span></span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">7</span>; i++)&#123;</span><br><span class="line">                  mask |= <span class="number">1</span> &lt;&lt; (puzzle.charAt(i) - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">int</span> subset = mask;</span><br><span class="line">              <span class="keyword">do</span>&#123;</span><br><span class="line">                  <span class="keyword">int</span> s = subset | <span class="number">1</span> &lt;&lt; (puzzle.charAt(<span class="number">0</span>) - <span class="string">&#x27;a&#x27;</span>);<span class="comment">//枚举操作和-1操作时只需要固定第0位，所以这里进行单独运算</span></span><br><span class="line">                  <span class="keyword">if</span>(fre.containsKey(s))&#123;</span><br><span class="line">                      total += fre.get(s);</span><br><span class="line">                  &#125;</span><br><span class="line">                  subset = (subset - <span class="number">1</span>) &amp; mask;</span><br><span class="line">              &#125;<span class="keyword">while</span>(subset != mask);<span class="comment">//subset为0时，-1代表所有位都为1，和mask“与”运算的结果必然与mask相等	</span></span><br><span class="line">              ans.add(total);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> ans;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="二、Trie树-回溯"><a href="#二、Trie树-回溯" class="headerlink" title="二、Trie树+回溯"></a>二、Trie树+回溯</h3><p>word中重复字母不考虑，puzzle无重复字母+遍历子集，所以可以采用Trie树方法将words所有单词保存，在每个单词最后一个字母处保存含有相同字母存在的单词个数</p>
<p>接着，遍历puzzles，对每个puzzle，我们需要通过Trie树查找该puzzle的子集，遍历子集的方式采用<strong>回溯法</strong>，分别<strong>考虑当前位置</strong>单词和<strong>忽略当前位置</strong>的下一个单词，特别注意的是，<strong>首字母不能忽略</strong></p>
<p>以上对Trie树的操作之前，首先要对word和puzzle进行排序，特别地，puzzle首字母要额外保存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findNumOfValidWords</span><span class="params">(String[] words, String[] puzzles)</span> </span>&#123;</span><br><span class="line">        TrieNode trieNode = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        <span class="comment">//word去重并添加入树</span></span><br><span class="line">        <span class="keyword">for</span>(String word: words)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] arr = word.toCharArray();</span><br><span class="line">            Arrays.sort(arr);</span><br><span class="line">            StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || arr[i] != arr[i - <span class="number">1</span>])&#123;</span><br><span class="line">                    sb.append(arr[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            add(trieNode, sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String puzzle: puzzles)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] arr = puzzle.toCharArray();</span><br><span class="line">            <span class="comment">//required表示puzzle的首字母，所以在排序前额外保留</span></span><br><span class="line">            <span class="keyword">char</span> required = arr[<span class="number">0</span>];</span><br><span class="line">            Arrays.sort(arr);</span><br><span class="line">            ans.add(find(trieNode, required, <span class="keyword">new</span> String(arr) ,<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(TrieNode root, String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.child[str.charAt(i) - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                root.child[str.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            root = root.child[str.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        root.fre++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(TrieNode cur, <span class="keyword">char</span> required, String puzzle, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cur!=null且pos==7的位置，包含puzzle所有子集的情况，cur.fre==0表示当前cur并非叶子结点</span></span><br><span class="line">        <span class="keyword">if</span>(pos == <span class="number">7</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> cur.fre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = find(cur.child[puzzle.charAt(pos) - <span class="string">&#x27;a&#x27;</span>], required, puzzle, pos + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果不是首字母，则额外考虑忽略pos位置字母的情况，不忽略与忽略两种情况相加</span></span><br><span class="line">        <span class="keyword">if</span>(puzzle.charAt(pos) != required)&#123;</span><br><span class="line">            ret += find(cur, required, puzzle,pos + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-01T12:33:19.674Z" title="2021-3-1 8:33:19 ├F10: PM┤">2021-03-01</time>发表</span><span class="level-item"><time dateTime="2021-03-02T02:00:32.814Z" title="2021-3-2 10:00:32 ├F10: AM┤">2021-03-02</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/web%E5%89%8D%E7%AB%AF/">web前端</a></span><span class="level-item">1 分钟读完 (大约123个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/01/hello-world/">Hello World</a></h1><div class="content"><p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="ParadoX"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">ParadoX</p><p class="is-size-6 is-block">Paradox的IT小屋</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>青岛，中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">11</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/lrj1996123" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/lrj1996123"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/leetcode/"><span class="level-start"><span class="level-item">leetcode</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/web%E5%89%8D%E7%AB%AF/"><span class="level-start"><span class="level-item">web前端</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">读书笔记</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%9D%A2%E8%AF%95/"><span class="level-start"><span class="level-item">面试</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/JS/"><span class="tag">JS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/REACT/"><span class="tag">REACT</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Trie%E6%A0%91/"><span class="tag">Trie树</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VUE/"><span class="tag">VUE</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/"><span class="tag">《深入理解Java虚拟机》</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"><span class="tag">二分查找</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="tag">动态规划</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"><span class="tag">状态压缩</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E8%AF%95/"><span class="tag">面试</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-25T14:19:57.000Z">2021-03-25</time></p><p class="title"><a href="/2021/03/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA2/">深入理解Java虚拟机2</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-16T04:09:47.000Z">2021-03-16</time></p><p class="title"><a href="/2021/03/16/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB1-%E3%80%8AAttention-based-LSTM-for-Aspect-level-Sentiment-Classification%E3%80%8B/">文献阅读1.《Attention-based LSTM for Aspect-level Sentiment Classification》</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-15T11:24:20.000Z">2021-03-15</time></p><p class="title"><a href="/2021/03/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA1/">深入理解Java虚拟机1</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-15T09:23:14.000Z">2021-03-15</time></p><p class="title"><a href="/2021/03/15/JAVA%E9%9D%A2%E8%AF%951/">JAVA实习面试经验1.阿里CBU简历评估</a></p><p class="categories"><a href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-08T03:10:04.000Z">2021-03-08</time></p><p class="title"><a href="/2021/03/08/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%902-%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98/">算法分析2.俄罗斯套娃信封问题</a></p><p class="categories"><a href="/categories/leetcode/">leetcode</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a><p class="is-size-7"><span>&copy; 2021 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>