<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Java高并发程序设计3 - Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="JDK并发包本章介绍JDK内部大量实用的框架，主要分为三个方面：  同步控制工具 线程池相关 并发容器  同步控制重入锁1234567891011121314151617181920212223public class ReenterLock implements Runnable&amp;amp;#123;    public static ReentrantLock lock &amp;#x3D; new ReentrantL"><meta property="og:type" content="blog"><meta property="og:title" content="Java高并发程序设计3"><meta property="og:url" content="https://lrj1996123.github.io/2021/04/07/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="JDK并发包本章介绍JDK内部大量实用的框架，主要分为三个方面：  同步控制工具 线程池相关 并发容器  同步控制重入锁1234567891011121314151617181920212223public class ReenterLock implements Runnable&amp;amp;#123;    public static ReentrantLock lock &amp;#x3D; new ReentrantL"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://lrj1996123.github.io/img/og_image.png"><meta property="article:published_time" content="2021-04-07T03:09:10.000Z"><meta property="article:modified_time" content="2021-04-26T07:45:50.688Z"><meta property="article:author" content="LRJ"><meta property="article:tag" content="Java"><meta property="article:tag" content="《高并发程序设计》"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://lrj1996123.github.io/2021/04/07/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},"headline":"Java高并发程序设计3","image":["https://lrj1996123.github.io/img/og_image.png"],"datePublished":"2021-04-07T03:09:10.000Z","dateModified":"2021-04-26T07:45:50.688Z","author":{"@type":"Person","name":"LRJ"},"description":"JDK并发包本章介绍JDK内部大量实用的框架，主要分为三个方面：  同步控制工具 线程池相关 并发容器  同步控制重入锁1234567891011121314151617181920212223public class ReenterLock implements Runnable&amp;#123;    public static ReentrantLock lock &#x3D; new ReentrantL"}</script><link rel="canonical" href="https://lrj1996123.github.io/2021/04/07/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.jpg" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/lrj1996123"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-07T03:09:10.000Z" title="2021-4-7 11:09:10 ├F10: AM┤">2021-04-07</time>发表</span><span class="level-item"><time dateTime="2021-04-26T07:45:50.688Z" title="2021-4-26 3:45:50 ├F10: PM┤">2021-04-26</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span><span class="level-item">15 分钟读完 (大约2245个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Java高并发程序设计3</h1><div class="content"><h2 id="JDK并发包"><a href="#JDK并发包" class="headerlink" title="JDK并发包"></a>JDK并发包</h2><p>本章介绍JDK内部大量实用的框架，主要分为三个方面：</p>
<ul>
<li>同步控制工具</li>
<li>线程池相关</li>
<li>并发容器</li>
</ul>
<h3 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h3><h4 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReenterLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000000</span>; j++)&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> trows InterruptedException</span>&#123;</span><br><span class="line">        ReenterLock rl = <span class="keyword">new</span> ReenterLock();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(rl);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(rl);</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>灵活：开发人员必须手动指定何时加锁，何时释放锁（<strong>退出临界区时必须释放锁</strong>）</p>
<p>重入：一个线程可以连续多次获得锁，但也必须释放相同次数</p>
<p>释放次数多会出现IllegalMonitorStateException异常</p>
<p>释放次数少会使其他线程无法进入临界区</p>
<span id="more"></span>

<h5 id="重入锁高级功能"><a href="#重入锁高级功能" class="headerlink" title="重入锁高级功能"></a>重入锁高级功能</h5><p>1.<strong>中断响应</strong></p>
<p>线程等待锁——&gt;获得锁/<strong>被中断</strong></p>
<p>通过重入锁实现对等待状态的中断，甚至可以解决死锁问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.lockInterruptibly();</span><br></pre></td></tr></table></figure>

<p>通过以上代码，线程等待获得锁，如果两线程请求的锁都被对方占用而无法释放，导致死锁，则会使其中一个线程中断释放资源，防止死锁发生，但最后只有一个线程完成了任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.isHeldByCurrentThread();</span><br></pre></td></tr></table></figure>

<p>上述代码表示判断当前线程是否拥有该锁</p>
<p>2.<strong>锁申请等待限时</strong></p>
<p>trylock第一个参数是等待时长，第二个时时间单位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(lock.tryLock(<span class="number">5</span>,TimeUnit.SECONDS))&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法可以使锁请求最多等待5秒，如果超过5秒就会自动放弃</p>
<p>tryLock方法也可以无参调用，如果锁未被占用则直接获取，如果被占用则不会等待，直接放弃本次请求，从而解决死锁问题</p>
<p>3.<strong>公平锁</strong></p>
<p>非公平锁：锁可用时随机给一个线程</p>
<p>保证先到先得，后到后得，不会产生饥饿现象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span></span></span><br></pre></td></tr></table></figure>

<p>fair为true则为公平锁，公平锁必然要维护一个有序队列，成本高，所以默认非公平</p>
<p>重入锁实现三要素：</p>
<ol>
<li>原子状态，使用CAS存储锁状态，判断锁是否被别的线程持有</li>
<li>等待队列，没有请求到锁的线程会进入等待队列进行等待，释放锁后会唤醒一个线程</li>
<li>阻塞原语park()和unpark()，用来挂起和恢复线程。没有得到锁的线程将会被挂起</li>
</ol>
<p>内核或微核提供核外调用的过程或函数称为<em>原语</em>(primitive)。<em>原语</em>是一段用机器指令编写的完成特定功能的程序,在执行过程中不允许中断。 </p>
<h5 id="重入锁搭档：Condition"><a href="#重入锁搭档：Condition" class="headerlink" title="重入锁搭档：Condition"></a>重入锁搭档：Condition</h5><p>类似wait和notify，wait和notify适合与synchronized一起用，Condition与重入锁一起用</p>
<p>通过lock接口的Condition newCondition()方法生成与当前重入锁绑定的Condition实例</p>
<p>让线程在合适时间等待，特定时刻得到通知</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;<span class="comment">//当前线程等待同时释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;<span class="comment">//不会在等待过程中响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;<span class="comment">//唤醒等待线程，重新获得锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;<span class="comment">//唤醒所有等待线程</span></span><br></pre></td></tr></table></figure>

<p>Condition功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReenterLockCondition</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line">        <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">static</span> ReenterLockCondition instance = <span class="keyword">new</span> ReenterLockCondition();</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException ie)&#123;</span><br><span class="line">                ie.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">            Thread t1 = <span class="keyword">new</span> Thread(condition);</span><br><span class="line">            t1.start();</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            lock.lock();</span><br><span class="line">            condition.signal();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>await要求线程持有相关重入锁，执行后释放这把锁</p>
<p>signal要求线程先获得相关锁，调用后从Condition对象的等待队列中唤醒一个线程，使之尝试重新获得与之绑定的重入锁，所以signal之后需要通过unlock释放锁才能真正唤醒t1</p>
<h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>指定多个线程同时访问某个资源，锁的扩展</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits,<span class="meta">@Nullable</span> <span class="keyword">boolean</span> fair)</span></span></span><br></pre></td></tr></table></figure>

<p>其主要逻辑方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span></span>;<span class="comment">//尝试获得一个准入许可，若无法获得则等待，直到有线程释放许可或中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span></span>;<span class="comment">//不响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span></span>;<span class="comment">//尝试获得一个许可 成功true 失败false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span>;<span class="comment">//限定时间内尝试获得许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span><span class="comment">//许可释放 一个acquire对应一个release否则会发生泄露</span></span></span><br></pre></td></tr></table></figure>

<h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><p>JDK5提供的读写分离锁</p>
<p>重写锁和内部锁的读、写都是串行操作，但是读操作并没有破坏数据，所以不合理</p>
<p><strong>读写锁允许多个线程同时读</strong></p>
<p>但是考虑数据完整性，<strong>写写操作</strong>和<strong>读写操作</strong>依然需要相互等待和持有锁</p>
<table>
<thead>
<tr>
<th></th>
<th>读</th>
<th>写</th>
</tr>
</thead>
<tbody><tr>
<td>读</td>
<td>非阻塞</td>
<td>阻塞</td>
</tr>
<tr>
<td>写</td>
<td>阻塞</td>
<td>阻塞</td>
</tr>
</tbody></table>
<p>读操作次数远远大于写操作次数时，读写锁就可以发挥最大功效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Lock readLock = readWriteLock.readLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Lock writeLock = readWriteLock.writeLock();</span><br></pre></td></tr></table></figure>

<p>读写锁分离，使得读操作非常快</p>
<h5 id="倒计数器：CountDownLatch"><a href="#倒计数器：CountDownLatch" class="headerlink" title="倒计数器：CountDownLatch"></a>倒计数器：CountDownLatch</h5><p>控制线程，让线程等待直到倒计数结束，再开始执行</p>
<p>场景：火箭发射前需要各项准备工作完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch end = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        end.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        exec.submit(demo);</span><br><span class="line">    &#125;</span><br><span class="line">    end.await();<span class="comment">//等待检查</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Fire！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如图，countDown方法通知CountDownLatch，一个线程完成任务，倒计数减一，任务全部完成后，再点火发射火箭</p>
<h5 id="循环栅栏：CyclicBarrier"><a href="#循环栅栏：CyclicBarrier" class="headerlink" title="循环栅栏：CyclicBarrier"></a>循环栅栏：CyclicBarrier</h5><p>类似倒计数器，但是有循环特性：如设置为10，第一批10个线程结束后，计数器就会归零，接着凑下一批10个线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span></span></span><br></pre></td></tr></table></figure>

<p>barrierAction表示一次计数完成后，系统会执行的动作</p>
<p>关键代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier cyclic;<span class="comment">//在main函数传参创建</span></span><br><span class="line"><span class="comment">//等待所有士兵到齐</span></span><br><span class="line">cyclic.await();</span><br><span class="line">doWork();</span><br><span class="line"><span class="comment">//等待所有士兵完成工作</span></span><br><span class="line">cyclic.await();</span><br></pre></td></tr></table></figure>

<p>第一次await，每个士兵线程会等待，直到集合完毕，barrierAction会执行一次</p>
<p>第二次await，进行下一次计数，在doWork执行完毕后进行，主要目的是监控是否所有士兵都完成了任务</p>
<p>注意：如果手动中断一个线程，其他9个线程会抛出BrokenBarrierException异常，避免永久无所谓的等待</p>
<h5 id="线程阻塞工具类：LockSupport"><a href="#线程阻塞工具类：LockSupport" class="headerlink" title="线程阻塞工具类：LockSupport"></a>线程阻塞工具类：LockSupport</h5><p>任意位置线程阻塞，不需要获得某个对象的锁</p>
<p>静态方法park()可以阻塞当前线程</p>
<p>用LockSupport的park和unpark替换掉第二章suspend和resume方法，结果导致程序正常运行！而没有永久挂起</p>
<p>原因：LockSupport类使用了类似信号量的机制，每个线程准备一个许可，如果许可可用，park方法立刻返回，许可变为不可用；如果许可不可用，就会阻塞，而unpark方法使一个许可变得可用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">run()&#123;</span><br><span class="line">    LockSupport.park();<span class="comment">//直接调用阻塞线程</span></span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">    LockSupport.unpark(t1);<span class="comment">//直接调用解挂t1阻塞状态，如果unpark发生在park()之前，也可以使下次park()立刻返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了定时阻塞，还可以支持中断影响</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">run()&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(u)&#123;</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        <span class="keyword">if</span>(Thread.interrupted())&#123;<span class="comment">//中断后可以直接响应</span></span><br><span class="line">            System.out.println(getName() +<span class="string">&quot;被中断了&quot;</span>)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.interrupt();<span class="comment">//中断t1,t1执行结束，之后t2才可进入临界区</span></span><br><span class="line">    LockSupport.unpark(t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Guava下限流工具RateLimiter"><a href="#Guava下限流工具RateLimiter" class="headerlink" title="Guava下限流工具RateLimiter"></a>Guava下限流工具RateLimiter</h5><p>对于一个应用来说，每秒能处理的请求是有限的，一旦突破上限，甚至可能压垮系统，因此限流很有必要</p>
<p>漏桶算法：利用一个缓存区，无论请求速率如何，都先进入缓存区保存，然后以固定速率处理请求</p>
<p>令牌桶算法：桶中存放令牌，每个单位时间产生一定量令牌存入桶中，处理程序拿到令牌才可处理请求，而且桶容量有限，桶慢则丢弃令牌</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> RateLimiter limiter = RateLimiter.create(<span class="number">2</span>);<span class="comment">//每秒生产2个令牌</span></span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">        limiter.acquire();<span class="comment">//请求令牌</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开50个线程，可能只需半秒，但我们规定一秒只能开2个线程，所以acquire使得过剩的流量等待，直到合适的时候执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!limiter.tryAcquire())&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task()).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可如上图，通过tryAcquire方法，直接丢弃过载请求，尽可能避免系统崩溃 500ms内所有都可完成，所以这里只有一个输出</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Java高并发程序设计3</p><p><a href="https://lrj1996123.github.io/2021/04/07/Java高并发程序设计3/">https://lrj1996123.github.io/2021/04/07/Java高并发程序设计3/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>LRJ</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-04-07</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-04-26</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Java/">Java</a><a class="link-muted mr-2" rel="tag" href="/tags/%E3%80%8A%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/">《高并发程序设计》</a></div><div class="bdsharebuttonbox"><a class="bds_more" href="#" data-cmd="more"></a><a class="bds_qzone" href="#" data-cmd="qzone" title="分享到QQ空间"></a><a class="bds_tsina" href="#" data-cmd="tsina" title="分享到新浪微博"></a><a class="bds_tqq" href="#" data-cmd="tqq" title="分享到腾讯微博"></a><a class="bds_renren" href="#" data-cmd="renren" title="分享到人人网"></a><a class="bds_weixin" href="#" data-cmd="weixin" title="分享到微信"></a></div><script>window._bd_share_config = { "common": { "bdSnsKey": {}, "bdText": "", "bdMini": "2", "bdPic": "", "bdStyle": "0", "bdSize": "16" }, "share": {} }; with (document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = 'http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=' + ~(-new Date() / 36e5)];</script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/04/08/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13-2/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Java高并发程序设计3-2</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/03/31/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"><span class="level-item">Java高并发程序设计2</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/valine/1.4.14/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread' ,
            appId: "Y3C4fyFR9V9oNevPXqUwcOaU-gzGzoHsz",
            appKey: "ETD7ffcWNFDIPikTHne6CEMJ",
            placeholder: "欢迎探讨评论~",
            avatar: "mm",
            
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            
            highlight: true,
            
            
            
            
            
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="ParadoX"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">ParadoX</p><p class="is-size-6 is-block">Paradox的IT小屋</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>青岛，中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">23</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">15</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/lrj1996123" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/lrj1996123"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/hexo%E8%AF%B4%E6%98%8E/"><span class="level-start"><span class="level-item">hexo说明</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/leetcode/"><span class="level-start"><span class="level-item">leetcode</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">读书笔记</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%9D%A2%E8%AF%95/"><span class="level-start"><span class="level-item">面试</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-26T08:51:32.000Z">2021-05-26</time></p><p class="title"><a href="/2021/05/26/%E4%BF%9D%E6%8A%A4%E5%BE%AE%E6%9C%8D%E5%8A%A1/">保护微服务</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-20T14:59:43.000Z">2021-05-20</time></p><p class="title"><a href="/2021/05/20/%E6%9C%8D%E5%8A%A1%E8%B7%AF%E7%94%B1/">服务路由</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-16T12:13:28.000Z">2021-05-16</time></p><p class="title"><a href="/2021/05/16/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%B9%E6%80%A7%E6%A8%A1%E5%BC%8F/">客户端弹性模式</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-10T07:30:47.000Z">2021-05-10</time></p><p class="title"><a href="/2021/05/10/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/">服务发现</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-08T09:52:19.000Z">2021-05-08</time></p><p class="title"><a href="/2021/05/08/Spring-Cloud%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A7%E5%88%B6%E9%85%8D%E7%BD%AE/">Spring Cloud配置服务器控制配置</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.jpg" alt="Hexo" height="28"></a><p class="is-size-7"><span>&copy; 2021 LRJ</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>