<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>客户端弹性模式 - Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="系统崩溃导致服务组件彻底损失，应用程序可以绕过 然而去检测那些服务性能不佳的服务并绕过它是非常困难的，原因： （1）间歇性问题导致服务性能下降，形成不可逆转势头，逐步降级导致资源耗尽并崩溃 （2）对远程服务的调用时同步的，调用时间可能很长 （3）应用程序经常被设计为处理远程资源的彻底故障，而非部分降级。程序会因为服务小故障而降级，但更有可能因为资源耗尽而崩溃 所以如何处理性能不佳的远程服务是本节关"><meta property="og:type" content="blog"><meta property="og:title" content="客户端弹性模式"><meta property="og:url" content="http://example.com/2021/05/16/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%B9%E6%80%A7%E6%A8%A1%E5%BC%8F/"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="系统崩溃导致服务组件彻底损失，应用程序可以绕过 然而去检测那些服务性能不佳的服务并绕过它是非常困难的，原因： （1）间歇性问题导致服务性能下降，形成不可逆转势头，逐步降级导致资源耗尽并崩溃 （2）对远程服务的调用时同步的，调用时间可能很长 （3）应用程序经常被设计为处理远程资源的彻底故障，而非部分降级。程序会因为服务小故障而降级，但更有可能因为资源耗尽而崩溃 所以如何处理性能不佳的远程服务是本节关"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/2021/05/16/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%B9%E6%80%A7%E6%A8%A1%E5%BC%8F/4-1.png"><meta property="og:image" content="http://example.com/2021/05/16/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%B9%E6%80%A7%E6%A8%A1%E5%BC%8F/4-2.png"><meta property="og:image" content="http://example.com/2021/05/16/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%B9%E6%80%A7%E6%A8%A1%E5%BC%8F/4-3.png"><meta property="og:image" content="http://example.com/2021/05/16/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%B9%E6%80%A7%E6%A8%A1%E5%BC%8F/4-4.png"><meta property="article:published_time" content="2021-05-16T12:13:28.000Z"><meta property="article:modified_time" content="2021-05-20T14:57:10.395Z"><meta property="article:author" content="LRJ"><meta property="article:tag" content="Java"><meta property="article:tag" content="Spring"><meta property="article:tag" content="微服务"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="4-1.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2021/05/16/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%B9%E6%80%A7%E6%A8%A1%E5%BC%8F/"},"headline":"客户端弹性模式","image":["http://example.com/2021/05/16/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%B9%E6%80%A7%E6%A8%A1%E5%BC%8F/4-1.png","http://example.com/2021/05/16/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%B9%E6%80%A7%E6%A8%A1%E5%BC%8F/4-2.png","http://example.com/2021/05/16/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%B9%E6%80%A7%E6%A8%A1%E5%BC%8F/4-3.png","http://example.com/2021/05/16/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%B9%E6%80%A7%E6%A8%A1%E5%BC%8F/4-4.png"],"datePublished":"2021-05-16T12:13:28.000Z","dateModified":"2021-05-20T14:57:10.395Z","author":{"@type":"Person","name":"LRJ"},"description":"系统崩溃导致服务组件彻底损失，应用程序可以绕过 然而去检测那些服务性能不佳的服务并绕过它是非常困难的，原因： （1）间歇性问题导致服务性能下降，形成不可逆转势头，逐步降级导致资源耗尽并崩溃 （2）对远程服务的调用时同步的，调用时间可能很长 （3）应用程序经常被设计为处理远程资源的彻底故障，而非部分降级。程序会因为服务小故障而降级，但更有可能因为资源耗尽而崩溃 所以如何处理性能不佳的远程服务是本节关"}</script><link rel="canonical" href="http://example.com/2021/05/16/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%B9%E6%80%A7%E6%A8%A1%E5%BC%8F/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.jpg" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/lrj1996123"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-16T12:13:28.000Z" title="2021-5-16 8:13:28 ├F10: PM┤">2021-05-16</time>发表</span><span class="level-item"><time dateTime="2021-05-20T14:57:10.395Z" title="2021-5-20 10:57:10 ├F10: PM┤">2021-05-20</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span><span class="level-item">30 分钟读完 (大约4544个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">客户端弹性模式</h1><div class="content"><p>系统崩溃导致服务组件彻底损失，应用程序可以绕过</p>
<p>然而去检测那些服务性能不佳的服务并绕过它是非常困难的，原因：</p>
<p>（1）间歇性问题导致服务性能下降，形成不可逆转势头，逐步降级导致资源耗尽并崩溃</p>
<p>（2）对远程服务的调用时同步的，调用时间可能很长</p>
<p>（3）应用程序经常被设计为处理远程资源的彻底故障，而非部分降级。程序会因为服务小故障而降级，但更有可能因为资源耗尽而崩溃</p>
<p>所以如何处理<strong>性能不佳的远程服务</strong>是本节关键，如果没有适当保护，可能会拖垮整个应用程序</p>
<h2 id="客户端弹性模式"><a href="#客户端弹性模式" class="headerlink" title="客户端弹性模式"></a>客户端弹性模式</h2><p>重点：远程服务发生错误或表现不佳时保护远程资源（其他微服务调用或数据库查询）的客户端免于崩溃</p>
<p>目标：让客户端<strong>快速失败</strong>，而不消耗数据库连接和线程池的宝贵资源，防止问题向消费者”上游“传播</p>
<p>四种客户端弹性模式：</p>
<p>（1）客户端负载均衡模式：客户端缓存服务发现检索到的微服务端点（Ribbon）</p>
<p>（2）断路器模式：确保客户端不会重复调用失败的服务</p>
<p>远程服务被调用时，断路器会监视，如果调用时间太长，断路器会介入中断调用。</p>
<p>断路器会监视所有调用，如果对某一远程资源调用失败次数过多，断路器就会出现并采取<strong>快速失败</strong></p>
<p>（3）后备模式：调用失败时询问是否有可执行的替代方案</p>
<p>远程服务调用失败，通常从另一数据源查找数据，或将用户请求排序以供将来处理</p>
<p>例如：调用商品推荐偏好服务，如果这个服务调用失败，则取检索一个更通用的偏好列表，这个通用列表可能来自不同服务和数据源</p>
<p>（4）舱壁模式：隔离不同的服务调用，确保表现不佳的服务不会耗尽客户端所有资源</p>
<p>将远程资源的调用分到线程池中，降低一个缓慢的远程资源调用拖垮整个应用程序的风险</p>
<p>线程池充当<strong>舱壁</strong>，一个服务响应很慢，这种服务调用的线程池就会饱和并停止处理请求</p>
<h2 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h2><p>场景：</p>
<p>服务C用于读写共享文件系统NAS</p>
<p>服务B连接数据源B，也可以调用服务C</p>
<p>服务A连接数据源A，可以调用服务B</p>
<p>问题：NAS出问题导致访问速度缓慢，导致服务C调用变慢，导致服务B调用数据源B耗尽以及调用服务C变慢，最终也会导致服务A变慢及资源耗尽，从而影响所有的三个服务</p>
<p>解决方法：断路器，服务C性能不佳时，对服务C的特定调用的断路器会跳闸，并且快速失败。服务B有多个端点而只有与服务C交互的端点才会受影响，服务B其余功能是完整的</p>
<p>断路器充当中间人，保护三个应用程序免于崩溃</p>
<p>B不会直接调用C，而是调用委托给断路器，断路器接管并将其包装在原始调用者的线程（由线程池管理）中。客户端也不再直接等待调用完成，而由断路器监视线程，如果线程运行时间太长就终止调用</p>
<p><strong>断路器跳闸的方式：</strong></p>
<p>1.愉快路径：维护定时器，定时器用完之前对完成远程服务调用，一切顺利 B-&gt;断路器-&gt;C</p>
<p>2.断路器（没有后备）：B-&gt;断路器-(在一定时间内服务C上发生足够多的错误，部分降级。调用C时，服务B可以立即接收到错误消息而不调用C )-&gt;C</p>
<p>3.断路器（带有后备）：B不去请求断路器调用服务C，而选择快速失败，或者执行替代代码（后备）。服务C也获得一个恢复的机会，让少量请求通过并重试，防止因降级发生级联死亡</p>
<p><strong>断路器提供的能力：</strong></p>
<p>（1）快速失败</p>
<p>（2）优雅地失败</p>
<p>（3）无缝恢复</p>
<h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><ul>
<li>引入Hystrix依赖</li>
<li>通过Hystrix注解来运用断路器模式包装远程调用</li>
<li>远程资源上定制断路器。以便为每个调用定制超时，配置断路器“跳闸”之前的故障次数</li>
<li>调用失败或断路器必须中断调用时实现后备策略</li>
<li>使用单独线程池隔离服务调用（舱壁）</li>
</ul>
<h2 id="搭建许可证服务器，使用Spring-Cloud和Hystrix"><a href="#搭建许可证服务器，使用Spring-Cloud和Hystrix" class="headerlink" title="搭建许可证服务器，使用Spring Cloud和Hystrix"></a>搭建许可证服务器，使用Spring Cloud和Hystrix</h2><p>许可证服务的pom文件中导入Spring Hystrix依赖项和Hystrix核心库</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!-- Spring Hystrix依赖项--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!-- 核心Netflix Hystrix库--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.hystrix<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hystrix-javanica<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用@EnableCircuitBreaker标注许可证服务引导类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span><span class="comment">//断路器标注许可证服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现断路器"><a href="#实现断路器" class="headerlink" title="实现断路器"></a>实现断路器</h2><p>首先实现许可证数据库的断路器</p>
<p>使用@HystrixCommand，让断路器包装一个Service方法（动态代理），并通过专门处理远程调用的线程池来管理该方法所有调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;License&gt; <span class="title">getLicensesByOrg</span><span class="params">(String organizationId)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> licenseRepository.findByOrganizationId(organizationId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//默认调用时间超过1000ms，断路器会中断对getLicensesByOrg()方法的调用</span></span><br></pre></td></tr></table></figure>

<p>这里模拟数据库调用，让3次中的大约1次调用时间超过1000ms</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">randomlyRunLong</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> randomNum = rand.nextInt((<span class="number">3</span> - <span class="number">1</span>) + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (randomNum==<span class="number">3</span>) sleep();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">11000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@HystrixCommand</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;License&gt; <span class="title">getLicensesByOrg</span><span class="params">(String organizationId)</span></span>&#123;</span><br><span class="line">    randomlyRunLong();<span class="comment">//随机3次中1次休眠线程</span></span><br><span class="line">    <span class="keyword">return</span> licenseRepository.findByOrganizationId(organizationId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="4-1.png"></p>
<p>如上图所示，休眠服务的调用时间超过一秒，报错</p>
<h3 id="调用组织微服务的超时"><a href="#调用组织微服务的超时" class="headerlink" title="调用组织微服务的超时"></a>调用组织微服务的超时</h3><p>上面讲解了调用数据库的断路器设置，这里讲解许可证服务调用组织服务的断路器设置</p>
<p>标注RestTemplate的调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Organization <span class="title">getOrganization</span><span class="params">(String organizationId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> organizationRestClient.getOrganization(organizationId);<span class="comment">//调用RestTemplate远程调用组织服务，详情见上节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定制断路器超时时间"><a href="#定制断路器超时时间" class="headerlink" title="定制断路器超时时间"></a>定制断路器超时时间</h3><p>将附加参数传递给@HystrixCommand即可定制断路器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(</span></span><br><span class="line"><span class="meta">    commandProperties=&#123;</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value=&quot;12000&quot;)&#125;)</span><span class="comment">//这里设置最大超时时间为12s</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;License&gt; <span class="title">getLicensesByOrg</span><span class="params">(String organizationId)</span></span>&#123;</span><br><span class="line">    randomlyRunLong();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> licenseRepository.findByOrganizationId(organizationId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="后备处理"><a href="#后备处理" class="headerlink" title="后备处理"></a>后备处理</h2><p>服务出现故障后，开发人员有机会拦截故障，并选择替代方案</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//待执行的后备方法，必须与@HystrixCommand保护的原始方法位于同一个类中，还必须和原始方法的签名完全相同，以便传参</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;License&gt; <span class="title">buildFallbackLicenseList</span><span class="params">(String organizationId)</span></span>&#123;</span><br><span class="line">    List&lt;License&gt; fallbackList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    License license = <span class="keyword">new</span> License()</span><br><span class="line">        .withId(<span class="string">&quot;0000000-00-00000&quot;</span>)</span><br><span class="line">        .withOrganizationId( organizationId )</span><br><span class="line">        .withProductName(<span class="string">&quot;Sorry no licensing information currently available&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fallbackList.add(license);</span><br><span class="line">    <span class="keyword">return</span> fallbackList;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;buildFallbackLicenseList&quot;)</span><span class="comment">//这里设置失败调用后，执行后备方法buildFallbackLicenseList</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;License&gt; <span class="title">getLicensesByOrg</span><span class="params">(String organizationId)</span></span>&#123;</span><br><span class="line">    randomlyRunLong();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> licenseRepository.findByOrganizationId(organizationId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续使用随机休眠方法，发现调用失败后不会报错，而是执行了替代方法</p>
<p><img src="4-2.png"></p>
<h2 id="实现舱壁模式"><a href="#实现舱壁模式" class="headerlink" title="实现舱壁模式"></a>实现舱壁模式</h2><p>多个微服务调用可能默认使用同一批线程，高并发场景下大量请求导致所有线程被刷爆，同时堵塞新请求，导致Java容器崩溃。</p>
<p>舱壁模式将远程资源调用隔离在它们自己的线程池中，以便控制单个表现不佳的服务</p>
<p>使用@HystrixCommand注解实现隔离线程池。注解代码完成以下操作</p>
<p>（1）为getLicensesByOrg方法调用建立单独线程池</p>
<p>（2）设置线程池中的线程数</p>
<p>（3）设置单个线程繁忙时可排队的请求数的队列大小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(</span></span><br><span class="line"><span class="meta">    threadPoolKey = &quot;licenseByOrgThreadPool&quot;,//请求建立新线程池，定义线程池唯一名称</span></span><br><span class="line"><span class="meta">    threadPoolProperties =</span></span><br><span class="line"><span class="meta">    &#123;</span></span><br><span class="line"><span class="meta">     @HystrixProperty(name = &quot;coreSize&quot;,value=&quot;30&quot;),//定义线程池中线程最大数量</span></span><br><span class="line"><span class="meta">     @HystrixProperty(name=&quot;maxQueueSize&quot;, value=&quot;10&quot;)//线程池前的队列，对传入请求排队。一旦超过该大小，接下来的请求都将失败，直到队列中有空间</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;License&gt; <span class="title">getLicensesByOrg</span><span class="params">(String organizationId)</span></span>&#123;</span><br><span class="line">    logger.debug(<span class="string">&quot;LicenseService.getLicensesByOrg  Correlation id: &#123;&#125;&quot;</span>, UserContextHolder.getContext().getCorrelationId());</span><br><span class="line">    randomlyRunLong();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> licenseRepository.findByOrganizationId(organizationId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，maxQueueSize设置成-1时，使用SynchronousQueue保存传入的请求，设置成大于1时，导致Hystrix使用Java LinkedBlockingQueue，允许线程忙于处理请求时也能对请求进行排毒</p>
<p>Hystrix允许使用queueSizeRejectionThreshold属性动态更改队列大小，但只有maxQueueSize为0时才能使用这个<br>$$<br>自定义线程池大小=服务健康状态时每秒支撑的最大请求数×第99百分位延迟时间（以秒为单位）+用于缓冲的少量额外线程<br>$$</p>
<h2 id="微调Hystrix"><a href="#微调Hystrix" class="headerlink" title="微调Hystrix"></a>微调Hystrix</h2><p>不仅如此，Hystrix监控调用失败次数，失败次数多，Hystrix还会在请求发送到远程资源之前就自动阻止</p>
<p>原因：1.远程资源的性能问题，以防止等待超时，从而显著降低调用服务导致的资源耗尽问题和崩溃的风险</p>
<p>2.保持服务负载，不会使服务彻底崩溃，快速失败给了性能下降的系统一些时间去进行恢复</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">断路器决策过程</span><br><span class="line">出现错误，开始一个10s活动窗口计时器（可配置）</span><br><span class="line">查看10s内的总调用数量，调用次数不超过默认值继续让调用通过</span><br><span class="line">超过最少调用次数，则查看整体故障百分比，该百分比超过错误阈值，则出发断路器，使将来几乎所有调用都失败</span><br><span class="line">如果未达到该阈值，10s窗口过去后重置断路器统计信息</span><br><span class="line">调用一个跳闸服务器时，开始一个新的活动窗口（可配置5s），每隔5s调用有问题的远程服务</span><br><span class="line">如果调用成功则重置断路器，重新让调用通过，如果失败，保持断路器断开，并在另一个5s窗口继续尝试</span><br></pre></td></tr></table></figure>

<p>根据这些，开发人员可使用5个属性定制断路器行为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;buildFallbackLicenseList&quot;,</span></span><br><span class="line"><span class="meta">                threadPoolKey = &quot;licenseByOrgThreadPool&quot;,</span></span><br><span class="line"><span class="meta">                threadPoolProperties =</span></span><br><span class="line"><span class="meta">                &#123;@HystrixProperty(name = &quot;coreSize&quot;,value=&quot;30&quot;),</span></span><br><span class="line"><span class="meta">                 @HystrixProperty(name=&quot;maxQueueSize&quot;, value=&quot;10&quot;)&#125;,</span></span><br><span class="line"><span class="meta">                commandProperties=&#123;</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name=&quot;circuitBreaker.requestVolumeThreshold&quot;, value=&quot;10&quot;),//控制10s之内必须发生的连续调用数量</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name=&quot;circuitBreaker.errorThresholdPercentage&quot;, value=&quot;75&quot;),//超过最少调用数后，调用失败所占总调用数的百分比，若超过则跳闸</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name=&quot;circuitBreaker.sleepWindowInMilliseconds&quot;, value=&quot;7000&quot;),//跳闸之后，每隔多长的时间可以允许一个调用通过，以便查看服务是否健康</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name=&quot;metrics.rollingStats.timeInMilliseconds&quot;, value=&quot;15000&quot;),//控制Hystrix监视服务调用问题的窗口大小</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name=&quot;metrics.rollingStats.numBuckets&quot;, value=&quot;5&quot;)&#125;</span></span><br><span class="line"><span class="meta">                	//在定义的滚动窗口中收集统计信息的次数（这里桶数量有5个，要求能被活动窗口时间整除，这里每个桶长度为15s/5=3s，统计信息将收集到这个5个3s长度的桶内，代表窗口内监控故障的时间）</span></span><br><span class="line"><span class="meta">               )</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;License&gt; <span class="title">getLicensesByOrg</span><span class="params">(String organizationId)</span></span>&#123;</span><br><span class="line">    logger.debug(<span class="string">&quot;LicenseService.getLicensesByOrg  Correlation id: &#123;&#125;&quot;</span>, UserContextHolder.getContext().getCorrelationId());</span><br><span class="line">    randomlyRunLong();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> licenseRepository.findByOrganizationId(organizationId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重新审视Hystrix配置"><a href="#重新审视Hystrix配置" class="headerlink" title="重新审视Hystrix配置"></a>重新审视Hystrix配置</h3><p>3个Hystrix配置级别：</p>
<p>（1）整个应用程序级别的默认值</p>
<p>（2）类级别的默认值</p>
<p>（3）类中定义的线程池级别</p>
<p>@DefaultProperties在类上配置默认值，让类中所有方法都遵循类上的默认值配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">生产环境中，Hystrix数据一般都在Spring Cloud Config中配置</span><br></pre></td></tr></table></figure>

<h2 id="线程上下文与Hystrix"><a href="#线程上下文与Hystrix" class="headerlink" title="线程上下文与Hystrix"></a>线程上下文与Hystrix</h2><p>@HystrixCommand隔离策略：</p>
<p>（1）THREAD</p>
<p>每个Hystrix命令都在一个单独线程池中执行，不与父线程共享，保证线程调用可以被中断而不影响父线程其他活动</p>
<p>（2）SEMAPHORE</p>
<p>Hystrix管理@HystrixCommand注解保护的分布式调用，不需启动新线程（轻量级隔离级别，适用于服务量很大的异步IO编程模型），调用超时会中断父线程。中断父线程导致开发人员无法捕获异常</p>
<p>隔离策略可以在@HystrixCommand注解中加入commandProperties属性，设置隔离级别</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>问题场景：THREAD隔离级别，Hystrix不会将父线程上下文传播到Hystrix命令管理的线程中</p>
<p>问题复现</p>
<p>在@HystrixCommand包裹的方法（子线程）中，用日志打印父线程上下文存储的信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用filter拦截REST请求的HTTP信息，存储在UserContextHolder的ThreadLocal上下文中</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContextFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(UserContextFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;</span><br><span class="line"></span><br><span class="line">        UserContextHolder.getContext().setCorrelationId(  httpServletRequest.getHeader(UserContext.CORRELATION_ID) );</span><br><span class="line">        UserContextHolder.getContext().setUserId(httpServletRequest.getHeader(UserContext.USER_ID));</span><br><span class="line">        UserContextHolder.getContext().setAuthToken(httpServletRequest.getHeader(UserContext.AUTH_TOKEN));</span><br><span class="line">        UserContextHolder.getContext().setOrgId(httpServletRequest.getHeader(UserContext.ORG_ID));</span><br><span class="line"></span><br><span class="line">        logger.debug(<span class="string">&quot;UserContextFilter Correlation id: &#123;&#125;&quot;</span>, UserContextHolder.getContext().getCorrelationId());</span><br><span class="line"></span><br><span class="line">        filterChain.doFilter(httpServletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UserContextHolder用于控制ThreadLocal来保存上下文</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContextHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserContext&gt; userContext = <span class="keyword">new</span> ThreadLocal&lt;UserContext&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> UserContext <span class="title">getContext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        UserContext context = userContext.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">            context = createEmptyContext();</span><br><span class="line">            userContext.set(context);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userContext.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(UserContext context)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(context, <span class="string">&quot;Only non-null UserContext instances are permitted&quot;</span>);</span><br><span class="line">        userContext.set(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> UserContext <span class="title">createEmptyContext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserContext();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接着，在Hystrix线程管理的方法和上述Servlet过滤器（父线程）方法中分别增加打印日志功能，查看HTTP头传来的信息</p>
<p><img src="4-3.png"></p>
<p>得到结果</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">c.t.licenses.utils.UserContextFilter: UserContextFilter Correlation id:</span> <span class="string">TEST-CORRELATION-ID</span></span><br><span class="line"><span class="attr">c.t.l.c.LicenseServiceController: LicenseServiceController Correlation id:</span> <span class="string">TEST-CORRELATION-ID</span></span><br><span class="line"><span class="attr">LicenseService.getLicensesByOrg  Correlation id:</span> </span><br></pre></td></tr></table></figure>

<p>发现被@HystrixCommand包裹的方法获取不到关联ID的值（父线程ThreadLocal存储的信息）</p>
<p>而Hystrix和Spring Cloud提供了一种机制，可将父线程上下文传播到Hystrix管理的线程</p>
<h2 id="HystrixConcurrrencyStrategy实战"><a href="#HystrixConcurrrencyStrategy实战" class="headerlink" title="HystrixConcurrrencyStrategy实战"></a>HystrixConcurrrencyStrategy实战</h2><p>Hystrix允许的一种自定义并发策略。</p>
<p>该策略将Hystrix调用包装起来，并允许开发人员将附加的父线程上下文注入HystrixCommand管理的线程中</p>
<p>（1）定义自定义Hystrix并发策略类</p>
<p>（2）定义Callable类，将UserContext注入Hystrix命令中</p>
<p>（3）配置Spring cloud以使用自定义Hystrix并发策略</p>
<h3 id="自定义Hystrix并发策略类"><a href="#自定义Hystrix并发策略类" class="headerlink" title="自定义Hystrix并发策略类"></a>自定义Hystrix并发策略类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalAwareStrategy</span> <span class="keyword">extends</span> <span class="title">HystrixConcurrencyStrategy</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HystrixConcurrencyStrategy existingConcurrencyStrategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadLocalAwareStrategy</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            HystrixConcurrencyStrategy existingConcurrencyStrategy)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取已存在并发策略</span></span><br><span class="line">        <span class="keyword">this</span>.existingConcurrencyStrategy = existingConcurrencyStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *重写所有方法，如果已存在并发策略则复用这些方法（已存在并发策略常用于处理安全，很重要）</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BlockingQueue&lt;Runnable&gt; <span class="title">getBlockingQueue</span><span class="params">(<span class="keyword">int</span> maxQueueSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> existingConcurrencyStrategy != <span class="keyword">null</span></span><br><span class="line">                ? existingConcurrencyStrategy.getBlockingQueue(maxQueueSize)</span><br><span class="line">                : <span class="keyword">super</span>.getBlockingQueue(maxQueueSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">HystrixRequestVariable&lt;T&gt; <span class="title">getRequestVariable</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            HystrixRequestVariableLifecycle&lt;T&gt; rv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> existingConcurrencyStrategy != <span class="keyword">null</span></span><br><span class="line">                ? existingConcurrencyStrategy.getRequestVariable(rv)</span><br><span class="line">                : <span class="keyword">super</span>.getRequestVariable(rv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolExecutor <span class="title">getThreadPool</span><span class="params">(HystrixThreadPoolKey threadPoolKey,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            HystrixProperty&lt;Integer&gt; corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            HystrixProperty&lt;Integer&gt; maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            HystrixProperty&lt;Integer&gt; keepAliveTime, TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> existingConcurrencyStrategy != <span class="keyword">null</span></span><br><span class="line">                ? existingConcurrencyStrategy.getThreadPool(threadPoolKey, corePoolSize,</span><br><span class="line">                maximumPoolSize, keepAliveTime, unit, workQueue)</span><br><span class="line">                : <span class="keyword">super</span>.getThreadPool(threadPoolKey, corePoolSize, maximumPoolSize,</span><br><span class="line">                keepAliveTime, unit, workQueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">wrapCallable</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> existingConcurrencyStrategy != <span class="keyword">null</span></span><br><span class="line">                ? existingConcurrencyStrategy</span><br><span class="line">                .wrapCallable(<span class="keyword">new</span> DelegatingUserContextCallable&lt;T&gt;(callable, UserContextHolder.getContext()))<span class="comment">//注入callable实现，它将设置UserContext</span></span><br><span class="line">                : <span class="keyword">super</span>.wrapCallable(<span class="keyword">new</span> DelegatingUserContextCallable&lt;T&gt;(callable, UserContextHolder.getContext()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了复用Spring Cloud已经定义好的HystrixConcurrencyStrategy方法，还要传递给callable实现DelegatingUserContextCallable，</p>
<p>将UserContext这个<strong>执行用户REST服务</strong>的父线程，设置成<strong>保护正在进行工作的方法</strong>的Hystrix命令线程</p>
<h3 id="定义Callable类，将UserContext注入Hystrix命令中"><a href="#定义Callable类，将UserContext注入Hystrix命令中" class="headerlink" title="定义Callable类，将UserContext注入Hystrix命令中"></a>定义Callable类，将UserContext注入Hystrix命令中</h3><p>上述代码将DelegatingUserContextCallable类设置到并发策略当中，该类具体实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingUserContextCallable</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Callable&lt;V&gt; delegate;</span><br><span class="line">    <span class="keyword">private</span> UserContext originalUserContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelegatingUserContextCallable</span><span class="params">(Callable&lt;V&gt; delegate,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             UserContext userContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;<span class="comment">//Hystrix保护的代码，目的将该线程与父线程相联系</span></span><br><span class="line">        <span class="keyword">this</span>.originalUserContext = userContext;<span class="comment">//父线程的UserContext</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;<span class="comment">//call方法被@HystrixCommand注解保护前被调用</span></span><br><span class="line">        UserContextHolder.setContext( originalUserContext );<span class="comment">//ThreadLocal变量与受@Hystrix保护的方法所在的线程相关联</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> delegate.call();<span class="comment">//UserContext设置后，Hystrix保护的方法上调用call()方法，如LicenseServevice.getLicenseByOrg(0方法)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.originalUserContext = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V&gt; <span class="function">Callable&lt;V&gt; <span class="title">create</span><span class="params">(Callable&lt;V&gt; delegate,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         UserContext userContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegatingUserContextCallable&lt;V&gt;(delegate, userContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用Hystrix保护的方法后，</p>
<p>（1）Hystrix和Spring Cloud将实例化DelegatingUserContextCallable类的一个实例</p>
<p>（2）该实例传入Hystrix命令池管理的线程调用的Callable类。如上述代码，该Callable类存储在名为delegate的Java属性中</p>
<p>call()方法在调用Hystrix保护的方法前调用</p>
<p>call方法中，UserContext从发起调用的父线程传递出去，在DelegatingUserContextCallable实例创建时设置，在类的call方法中传递出去</p>
<p>call方法的setContext设置UserContext，将UserContext存储在ThreadLocal变量中，该ThreadLocal特定于正在运行的Hystrix线程中</p>
<p>设置完成后，就会调用Callable类的call方法，即Hystrix注解保护的方法</p>
<h3 id="配置Spring-Cloud，使用自定义Hystrix并发策略"><a href="#配置Spring-Cloud，使用自定义Hystrix并发策略" class="headerlink" title="配置Spring Cloud，使用自定义Hystrix并发策略"></a>配置Spring Cloud，使用自定义Hystrix并发策略</h3><p>刚才的工作：</p>
<p>（1）实现并发策略类，复用已存在的安全策略，重写wrapCallable方法以绑定策略，实现Hystrix线程和父线程上下文相联系</p>
<p>（2）Callable类将ThreadLocal的内容传递给Hystrix管理的线程</p>
<p>配置好自定义并发策略之后，需要将该策略与SpringCloud和Hystrix挂钩，具体如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalConfiguration</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Autowired(required = false)</span></span><br><span class="line">        <span class="keyword">private</span> HystrixConcurrencyStrategy existingConcurrencyStrategy;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Keeps references of existing Hystrix plugins.</span></span><br><span class="line">            HystrixEventNotifier eventNotifier = HystrixPlugins.getInstance()</span><br><span class="line">                    .getEventNotifier();</span><br><span class="line">            HystrixMetricsPublisher metricsPublisher = HystrixPlugins.getInstance()</span><br><span class="line">                    .getMetricsPublisher();</span><br><span class="line">            HystrixPropertiesStrategy propertiesStrategy = HystrixPlugins.getInstance()</span><br><span class="line">                    .getPropertiesStrategy();</span><br><span class="line">            HystrixCommandExecutionHook commandExecutionHook = HystrixPlugins.getInstance()</span><br><span class="line">                    .getCommandExecutionHook();</span><br><span class="line"></span><br><span class="line">            HystrixPlugins.reset();<span class="comment">//上面保留已存在策略，下面添加新策略</span></span><br><span class="line"></span><br><span class="line">            HystrixPlugins.getInstance().registerConcurrencyStrategy(<span class="keyword">new</span> ThreadLocalAwareStrategy(existingConcurrencyStrategy));<span class="comment">//添加新的并发策略</span></span><br><span class="line">            <span class="comment">//重新注册Hystrix插件的所有组件</span></span><br><span class="line">            HystrixPlugins.getInstance().registerEventNotifier(eventNotifier);</span><br><span class="line">            HystrixPlugins.getInstance().registerMetricsPublisher(metricsPublisher);</span><br><span class="line">            HystrixPlugins.getInstance().registerPropertiesStrategy(propertiesStrategy);</span><br><span class="line">            HystrixPlugins.getInstance().registerCommandExecutionHook(commandExecutionHook);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后重新编译运行项目，发现在Hystrix保护的方法中可以获取到父线程ThreadLocal的内容了</p>
<p><img src="4-4.png"></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>客户端弹性模式</p><p><a href="http://example.com/2021/05/16/客户端弹性模式/">http://example.com/2021/05/16/客户端弹性模式/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>John Doe</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-05-16</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-05-20</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Java/">Java</a><a class="link-muted mr-2" rel="tag" href="/tags/Spring/">Spring</a><a class="link-muted mr-2" rel="tag" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a></div><div class="bdsharebuttonbox"><a class="bds_more" href="#" data-cmd="more"></a><a class="bds_qzone" href="#" data-cmd="qzone" title="分享到QQ空间"></a><a class="bds_tsina" href="#" data-cmd="tsina" title="分享到新浪微博"></a><a class="bds_tqq" href="#" data-cmd="tqq" title="分享到腾讯微博"></a><a class="bds_renren" href="#" data-cmd="renren" title="分享到人人网"></a><a class="bds_weixin" href="#" data-cmd="weixin" title="分享到微信"></a></div><script>window._bd_share_config = { "common": { "bdSnsKey": {}, "bdText": "", "bdMini": "2", "bdPic": "", "bdStyle": "0", "bdSize": "16" }, "share": {} }; with (document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = 'http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=' + ~(-new Date() / 36e5)];</script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/05/20/%E6%9C%8D%E5%8A%A1%E8%B7%AF%E7%94%B1/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">服务路由</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/05/10/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"><span class="level-item">服务发现</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/valine/1.4.14/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread' ,
            appId: "Y3C4fyFR9V9oNevPXqUwcOaU-gzGzoHsz",
            appKey: "ETD7ffcWNFDIPikTHne6CEMJ",
            placeholder: "欢迎探讨评论~",
            avatar: "mm",
            
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            
            highlight: true,
            
            
            
            
            
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="ParadoX"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">ParadoX</p><p class="is-size-6 is-block">Paradox的IT小屋</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>青岛，中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">23</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">15</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/lrj1996123" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/lrj1996123"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/hexo%E8%AF%B4%E6%98%8E/"><span class="level-start"><span class="level-item">hexo说明</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/leetcode/"><span class="level-start"><span class="level-item">leetcode</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">读书笔记</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%9D%A2%E8%AF%95/"><span class="level-start"><span class="level-item">面试</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-26T08:51:32.000Z">2021-05-26</time></p><p class="title"><a href="/2021/05/26/%E4%BF%9D%E6%8A%A4%E5%BE%AE%E6%9C%8D%E5%8A%A1/">保护微服务</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-20T14:59:43.000Z">2021-05-20</time></p><p class="title"><a href="/2021/05/20/%E6%9C%8D%E5%8A%A1%E8%B7%AF%E7%94%B1/">服务路由</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-16T12:13:28.000Z">2021-05-16</time></p><p class="title"><a href="/2021/05/16/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%B9%E6%80%A7%E6%A8%A1%E5%BC%8F/">客户端弹性模式</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-10T07:30:47.000Z">2021-05-10</time></p><p class="title"><a href="/2021/05/10/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/">服务发现</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-08T09:52:19.000Z">2021-05-08</time></p><p class="title"><a href="/2021/05/08/Spring-Cloud%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A7%E5%88%B6%E9%85%8D%E7%BD%AE/">Spring Cloud配置服务器控制配置</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.jpg" alt="Hexo" height="28"></a><p class="is-size-7"><span>&copy; 2021 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>